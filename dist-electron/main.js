var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { app, BrowserWindow, ipcMain } from "electron";
import { createRequire } from "node:module";
import { fileURLToPath } from "node:url";
import path$d from "node:path";
import fs$i from "node:fs/promises";
import require$$0$1 from "stream";
import require$$0$2 from "fs";
import require$$1 from "path";
import PDFDocument from "pdfkit";
import crypto$1 from "crypto";
import require$$2$1 from "events";
import require$$0$3 from "buffer";
import require$$0$4 from "util";
import require$$0$5 from "string_decoder";
import require$$0$6 from "constants";
import require$$5 from "assert";
import require$$0$7 from "zlib";
import require$$1$1 from "os";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var papaparse = { exports: {} };
/* @license
Papa Parse
v5.5.2
https://github.com/mholt/PapaParse
License: MIT
*/
(function(module, exports) {
  (function(root2, factory) {
    {
      module.exports = factory();
    }
  })(commonjsGlobal, function moduleFactory() {
    var global2 = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      return {};
    }();
    function getWorkerBlob() {
      var URL2 = global2.URL || global2.webkitURL || null;
      var code = moduleFactory.toString();
      return Papa2.BLOB_URL || (Papa2.BLOB_URL = URL2.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", code, ")();"], { type: "text/javascript" })));
    }
    var IS_WORKER = !global2.document && !!global2.postMessage, IS_PAPA_WORKER = global2.IS_PAPA_WORKER || false;
    var workers = {}, workerIdCounter = 0;
    var Papa2 = {};
    Papa2.parse = CsvToJson;
    Papa2.unparse = JsonToCsv;
    Papa2.RECORD_SEP = String.fromCharCode(30);
    Papa2.UNIT_SEP = String.fromCharCode(31);
    Papa2.BYTE_ORDER_MARK = "\uFEFF";
    Papa2.BAD_DELIMITERS = ["\r", "\n", '"', Papa2.BYTE_ORDER_MARK];
    Papa2.WORKERS_SUPPORTED = !IS_WORKER && !!global2.Worker;
    Papa2.NODE_STREAM_INPUT = 1;
    Papa2.LocalChunkSize = 1024 * 1024 * 10;
    Papa2.RemoteChunkSize = 1024 * 1024 * 5;
    Papa2.DefaultDelimiter = ",";
    Papa2.Parser = Parser2;
    Papa2.ParserHandle = ParserHandle;
    Papa2.NetworkStreamer = NetworkStreamer;
    Papa2.FileStreamer = FileStreamer;
    Papa2.StringStreamer = StringStreamer;
    Papa2.ReadableStreamStreamer = ReadableStreamStreamer;
    if (typeof PAPA_BROWSER_CONTEXT === "undefined") {
      Papa2.DuplexStreamStreamer = DuplexStreamStreamer;
    }
    if (global2.jQuery) {
      var $ = global2.jQuery;
      $.fn.parse = function(options) {
        var config = options.config || {};
        var queue2 = [];
        this.each(function(idx) {
          var supported = $(this).prop("tagName").toUpperCase() === "INPUT" && $(this).attr("type").toLowerCase() === "file" && global2.FileReader;
          if (!supported || !this.files || this.files.length === 0)
            return true;
          for (var i = 0; i < this.files.length; i++) {
            queue2.push({
              file: this.files[i],
              inputElem: this,
              instanceConfig: $.extend({}, config)
            });
          }
        });
        parseNextFile();
        return this;
        function parseNextFile() {
          if (queue2.length === 0) {
            if (isFunction2(options.complete))
              options.complete();
            return;
          }
          var f = queue2[0];
          if (isFunction2(options.before)) {
            var returned = options.before(f.file, f.inputElem);
            if (typeof returned === "object") {
              if (returned.action === "abort") {
                error2("AbortError", f.file, f.inputElem, returned.reason);
                return;
              } else if (returned.action === "skip") {
                fileComplete();
                return;
              } else if (typeof returned.config === "object")
                f.instanceConfig = $.extend(f.instanceConfig, returned.config);
            } else if (returned === "skip") {
              fileComplete();
              return;
            }
          }
          var userCompleteFunc = f.instanceConfig.complete;
          f.instanceConfig.complete = function(results) {
            if (isFunction2(userCompleteFunc))
              userCompleteFunc(results, f.file, f.inputElem);
            fileComplete();
          };
          Papa2.parse(f.file, f.instanceConfig);
        }
        function error2(name, file2, elem, reason) {
          if (isFunction2(options.error))
            options.error({ name }, file2, elem, reason);
        }
        function fileComplete() {
          queue2.splice(0, 1);
          parseNextFile();
        }
      };
    }
    if (IS_PAPA_WORKER) {
      global2.onmessage = workerThreadReceivedMessage;
    }
    function CsvToJson(_input, _config) {
      _config = _config || {};
      var dynamicTyping = _config.dynamicTyping || false;
      if (isFunction2(dynamicTyping)) {
        _config.dynamicTypingFunction = dynamicTyping;
        dynamicTyping = {};
      }
      _config.dynamicTyping = dynamicTyping;
      _config.transform = isFunction2(_config.transform) ? _config.transform : false;
      if (_config.worker && Papa2.WORKERS_SUPPORTED) {
        var w = newWorker();
        w.userStep = _config.step;
        w.userChunk = _config.chunk;
        w.userComplete = _config.complete;
        w.userError = _config.error;
        _config.step = isFunction2(_config.step);
        _config.chunk = isFunction2(_config.chunk);
        _config.complete = isFunction2(_config.complete);
        _config.error = isFunction2(_config.error);
        delete _config.worker;
        w.postMessage({
          input: _input,
          config: _config,
          workerId: w.id
        });
        return;
      }
      var streamer = null;
      if (_input === Papa2.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === "undefined") {
        streamer = new DuplexStreamStreamer(_config);
        return streamer.getStream();
      } else if (typeof _input === "string") {
        _input = stripBom(_input);
        if (_config.download)
          streamer = new NetworkStreamer(_config);
        else
          streamer = new StringStreamer(_config);
      } else if (_input.readable === true && isFunction2(_input.read) && isFunction2(_input.on)) {
        streamer = new ReadableStreamStreamer(_config);
      } else if (global2.File && _input instanceof File || _input instanceof Object)
        streamer = new FileStreamer(_config);
      return streamer.stream(_input);
      function stripBom(string) {
        if (string.charCodeAt(0) === 65279) {
          return string.slice(1);
        }
        return string;
      }
    }
    function JsonToCsv(_input, _config) {
      var _quotes = false;
      var _writeHeader = true;
      var _delimiter = ",";
      var _newline = "\r\n";
      var _quoteChar = '"';
      var _escapedQuote = _quoteChar + _quoteChar;
      var _skipEmptyLines = false;
      var _columns = null;
      var _escapeFormulae = false;
      unpackConfig();
      var quoteCharRegex = new RegExp(escapeRegExp2(_quoteChar), "g");
      if (typeof _input === "string")
        _input = JSON.parse(_input);
      if (Array.isArray(_input)) {
        if (!_input.length || Array.isArray(_input[0]))
          return serialize(null, _input, _skipEmptyLines);
        else if (typeof _input[0] === "object")
          return serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);
      } else if (typeof _input === "object") {
        if (typeof _input.data === "string")
          _input.data = JSON.parse(_input.data);
        if (Array.isArray(_input.data)) {
          if (!_input.fields)
            _input.fields = _input.meta && _input.meta.fields || _columns;
          if (!_input.fields)
            _input.fields = Array.isArray(_input.data[0]) ? _input.fields : typeof _input.data[0] === "object" ? Object.keys(_input.data[0]) : [];
          if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== "object")
            _input.data = [_input.data];
        }
        return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
      }
      throw new Error("Unable to serialize unrecognized input");
      function unpackConfig() {
        if (typeof _config !== "object")
          return;
        if (typeof _config.delimiter === "string" && !Papa2.BAD_DELIMITERS.filter(function(value) {
          return _config.delimiter.indexOf(value) !== -1;
        }).length) {
          _delimiter = _config.delimiter;
        }
        if (typeof _config.quotes === "boolean" || typeof _config.quotes === "function" || Array.isArray(_config.quotes))
          _quotes = _config.quotes;
        if (typeof _config.skipEmptyLines === "boolean" || typeof _config.skipEmptyLines === "string")
          _skipEmptyLines = _config.skipEmptyLines;
        if (typeof _config.newline === "string")
          _newline = _config.newline;
        if (typeof _config.quoteChar === "string")
          _quoteChar = _config.quoteChar;
        if (typeof _config.header === "boolean")
          _writeHeader = _config.header;
        if (Array.isArray(_config.columns)) {
          if (_config.columns.length === 0) throw new Error("Option columns is empty");
          _columns = _config.columns;
        }
        if (_config.escapeChar !== void 0) {
          _escapedQuote = _config.escapeChar + _quoteChar;
        }
        if (_config.escapeFormulae instanceof RegExp) {
          _escapeFormulae = _config.escapeFormulae;
        } else if (typeof _config.escapeFormulae === "boolean" && _config.escapeFormulae) {
          _escapeFormulae = /^[=+\-@\t\r].*$/;
        }
      }
      function serialize(fields, data, skipEmptyLines) {
        var csv2 = "";
        if (typeof fields === "string")
          fields = JSON.parse(fields);
        if (typeof data === "string")
          data = JSON.parse(data);
        var hasHeader = Array.isArray(fields) && fields.length > 0;
        var dataKeyedByField = !Array.isArray(data[0]);
        if (hasHeader && _writeHeader) {
          for (var i = 0; i < fields.length; i++) {
            if (i > 0)
              csv2 += _delimiter;
            csv2 += safe(fields[i], i);
          }
          if (data.length > 0)
            csv2 += _newline;
        }
        for (var row2 = 0; row2 < data.length; row2++) {
          var maxCol = hasHeader ? fields.length : data[row2].length;
          var emptyLine = false;
          var nullLine = hasHeader ? Object.keys(data[row2]).length === 0 : data[row2].length === 0;
          if (skipEmptyLines && !hasHeader) {
            emptyLine = skipEmptyLines === "greedy" ? data[row2].join("").trim() === "" : data[row2].length === 1 && data[row2][0].length === 0;
          }
          if (skipEmptyLines === "greedy" && hasHeader) {
            var line = [];
            for (var c2 = 0; c2 < maxCol; c2++) {
              var cx = dataKeyedByField ? fields[c2] : c2;
              line.push(data[row2][cx]);
            }
            emptyLine = line.join("").trim() === "";
          }
          if (!emptyLine) {
            for (var col = 0; col < maxCol; col++) {
              if (col > 0 && !nullLine)
                csv2 += _delimiter;
              var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
              csv2 += safe(data[row2][colIdx], col);
            }
            if (row2 < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {
              csv2 += _newline;
            }
          }
        }
        return csv2;
      }
      function safe(str, col) {
        if (typeof str === "undefined" || str === null)
          return "";
        if (str.constructor === Date)
          return JSON.stringify(str).slice(1, 25);
        var needsQuotes = false;
        if (_escapeFormulae && typeof str === "string" && _escapeFormulae.test(str)) {
          str = "'" + str;
          needsQuotes = true;
        }
        var escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);
        needsQuotes = needsQuotes || _quotes === true || typeof _quotes === "function" && _quotes(str, col) || Array.isArray(_quotes) && _quotes[col] || hasAny(escapedQuoteStr, Papa2.BAD_DELIMITERS) || escapedQuoteStr.indexOf(_delimiter) > -1 || escapedQuoteStr.charAt(0) === " " || escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === " ";
        return needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;
      }
      function hasAny(str, substrings) {
        for (var i = 0; i < substrings.length; i++)
          if (str.indexOf(substrings[i]) > -1)
            return true;
        return false;
      }
    }
    function ChunkStreamer(config) {
      this._handle = null;
      this._finished = false;
      this._completed = false;
      this._halted = false;
      this._input = null;
      this._baseIndex = 0;
      this._partialLine = "";
      this._rowCount = 0;
      this._start = 0;
      this._nextChunk = null;
      this.isFirstChunk = true;
      this._completeResults = {
        data: [],
        errors: [],
        meta: {}
      };
      replaceConfig.call(this, config);
      this.parseChunk = function(chunk, isFakeChunk) {
        const skipFirstNLines = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && skipFirstNLines > 0) {
          let _newline = this._config.newline;
          if (!_newline) {
            const quoteChar = this._config.quoteChar || '"';
            _newline = this._handle.guessLineEndings(chunk, quoteChar);
          }
          const splitChunk = chunk.split(_newline);
          chunk = [...splitChunk.slice(skipFirstNLines)].join(_newline);
        }
        if (this.isFirstChunk && isFunction2(this._config.beforeFirstChunk)) {
          var modifiedChunk = this._config.beforeFirstChunk(chunk);
          if (modifiedChunk !== void 0)
            chunk = modifiedChunk;
        }
        this.isFirstChunk = false;
        this._halted = false;
        var aggregate = this._partialLine + chunk;
        this._partialLine = "";
        var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
        if (this._handle.paused() || this._handle.aborted()) {
          this._halted = true;
          return;
        }
        var lastIndex = results.meta.cursor;
        if (!this._finished) {
          this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
          this._baseIndex = lastIndex;
        }
        if (results && results.data)
          this._rowCount += results.data.length;
        var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;
        if (IS_PAPA_WORKER) {
          global2.postMessage({
            results,
            workerId: Papa2.WORKER_ID,
            finished: finishedIncludingPreview
          });
        } else if (isFunction2(this._config.chunk) && !isFakeChunk) {
          this._config.chunk(results, this._handle);
          if (this._handle.paused() || this._handle.aborted()) {
            this._halted = true;
            return;
          }
          results = void 0;
          this._completeResults = void 0;
        }
        if (!this._config.step && !this._config.chunk) {
          this._completeResults.data = this._completeResults.data.concat(results.data);
          this._completeResults.errors = this._completeResults.errors.concat(results.errors);
          this._completeResults.meta = results.meta;
        }
        if (!this._completed && finishedIncludingPreview && isFunction2(this._config.complete) && (!results || !results.meta.aborted)) {
          this._config.complete(this._completeResults, this._input);
          this._completed = true;
        }
        if (!finishedIncludingPreview && (!results || !results.meta.paused))
          this._nextChunk();
        return results;
      };
      this._sendError = function(error2) {
        if (isFunction2(this._config.error))
          this._config.error(error2);
        else if (IS_PAPA_WORKER && this._config.error) {
          global2.postMessage({
            workerId: Papa2.WORKER_ID,
            error: error2,
            finished: false
          });
        }
      };
      function replaceConfig(config2) {
        var configCopy = copy3(config2);
        configCopy.chunkSize = parseInt(configCopy.chunkSize);
        if (!config2.step && !config2.chunk)
          configCopy.chunkSize = null;
        this._handle = new ParserHandle(configCopy);
        this._handle.streamer = this;
        this._config = configCopy;
      }
    }
    function NetworkStreamer(config) {
      config = config || {};
      if (!config.chunkSize)
        config.chunkSize = Papa2.RemoteChunkSize;
      ChunkStreamer.call(this, config);
      var xhr;
      if (IS_WORKER) {
        this._nextChunk = function() {
          this._readChunk();
          this._chunkLoaded();
        };
      } else {
        this._nextChunk = function() {
          this._readChunk();
        };
      }
      this.stream = function(url) {
        this._input = url;
        this._nextChunk();
      };
      this._readChunk = function() {
        if (this._finished) {
          this._chunkLoaded();
          return;
        }
        xhr = new XMLHttpRequest();
        if (this._config.withCredentials) {
          xhr.withCredentials = this._config.withCredentials;
        }
        if (!IS_WORKER) {
          xhr.onload = bindFunction(this._chunkLoaded, this);
          xhr.onerror = bindFunction(this._chunkError, this);
        }
        xhr.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !IS_WORKER);
        if (this._config.downloadRequestHeaders) {
          var headers2 = this._config.downloadRequestHeaders;
          for (var headerName in headers2) {
            xhr.setRequestHeader(headerName, headers2[headerName]);
          }
        }
        if (this._config.chunkSize) {
          var end2 = this._start + this._config.chunkSize - 1;
          xhr.setRequestHeader("Range", "bytes=" + this._start + "-" + end2);
        }
        try {
          xhr.send(this._config.downloadRequestBody);
        } catch (err2) {
          this._chunkError(err2.message);
        }
        if (IS_WORKER && xhr.status === 0)
          this._chunkError();
      };
      this._chunkLoaded = function() {
        if (xhr.readyState !== 4)
          return;
        if (xhr.status < 200 || xhr.status >= 400) {
          this._chunkError();
          return;
        }
        this._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;
        this._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);
        this.parseChunk(xhr.responseText);
      };
      this._chunkError = function(errorMessage) {
        var errorText = xhr.statusText || errorMessage;
        this._sendError(new Error(errorText));
      };
      function getFileSize(xhr2) {
        var contentRange = xhr2.getResponseHeader("Content-Range");
        if (contentRange === null) {
          return -1;
        }
        return parseInt(contentRange.substring(contentRange.lastIndexOf("/") + 1));
      }
    }
    NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
    NetworkStreamer.prototype.constructor = NetworkStreamer;
    function FileStreamer(config) {
      config = config || {};
      if (!config.chunkSize)
        config.chunkSize = Papa2.LocalChunkSize;
      ChunkStreamer.call(this, config);
      var reader2, slice3;
      var usingAsyncReader = typeof FileReader !== "undefined";
      this.stream = function(file2) {
        this._input = file2;
        slice3 = file2.slice || file2.webkitSlice || file2.mozSlice;
        if (usingAsyncReader) {
          reader2 = new FileReader();
          reader2.onload = bindFunction(this._chunkLoaded, this);
          reader2.onerror = bindFunction(this._chunkError, this);
        } else
          reader2 = new FileReaderSync();
        this._nextChunk();
      };
      this._nextChunk = function() {
        if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
          this._readChunk();
      };
      this._readChunk = function() {
        var input = this._input;
        if (this._config.chunkSize) {
          var end2 = Math.min(this._start + this._config.chunkSize, this._input.size);
          input = slice3.call(input, this._start, end2);
        }
        var txt = reader2.readAsText(input, this._config.encoding);
        if (!usingAsyncReader)
          this._chunkLoaded({ target: { result: txt } });
      };
      this._chunkLoaded = function(event) {
        this._start += this._config.chunkSize;
        this._finished = !this._config.chunkSize || this._start >= this._input.size;
        this.parseChunk(event.target.result);
      };
      this._chunkError = function() {
        this._sendError(reader2.error);
      };
    }
    FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
    FileStreamer.prototype.constructor = FileStreamer;
    function StringStreamer(config) {
      config = config || {};
      ChunkStreamer.call(this, config);
      var remaining;
      this.stream = function(s) {
        remaining = s;
        return this._nextChunk();
      };
      this._nextChunk = function() {
        if (this._finished) return;
        var size = this._config.chunkSize;
        var chunk;
        if (size) {
          chunk = remaining.substring(0, size);
          remaining = remaining.substring(size);
        } else {
          chunk = remaining;
          remaining = "";
        }
        this._finished = !remaining;
        return this.parseChunk(chunk);
      };
    }
    StringStreamer.prototype = Object.create(StringStreamer.prototype);
    StringStreamer.prototype.constructor = StringStreamer;
    function ReadableStreamStreamer(config) {
      config = config || {};
      ChunkStreamer.call(this, config);
      var queue2 = [];
      var parseOnData = true;
      var streamHasEnded = false;
      this.pause = function() {
        ChunkStreamer.prototype.pause.apply(this, arguments);
        this._input.pause();
      };
      this.resume = function() {
        ChunkStreamer.prototype.resume.apply(this, arguments);
        this._input.resume();
      };
      this.stream = function(stream2) {
        this._input = stream2;
        this._input.on("data", this._streamData);
        this._input.on("end", this._streamEnd);
        this._input.on("error", this._streamError);
      };
      this._checkIsFinished = function() {
        if (streamHasEnded && queue2.length === 1) {
          this._finished = true;
        }
      };
      this._nextChunk = function() {
        this._checkIsFinished();
        if (queue2.length) {
          this.parseChunk(queue2.shift());
        } else {
          parseOnData = true;
        }
      };
      this._streamData = bindFunction(function(chunk) {
        try {
          queue2.push(typeof chunk === "string" ? chunk : chunk.toString(this._config.encoding));
          if (parseOnData) {
            parseOnData = false;
            this._checkIsFinished();
            this.parseChunk(queue2.shift());
          }
        } catch (error2) {
          this._streamError(error2);
        }
      }, this);
      this._streamError = bindFunction(function(error2) {
        this._streamCleanUp();
        this._sendError(error2);
      }, this);
      this._streamEnd = bindFunction(function() {
        this._streamCleanUp();
        streamHasEnded = true;
        this._streamData("");
      }, this);
      this._streamCleanUp = bindFunction(function() {
        this._input.removeListener("data", this._streamData);
        this._input.removeListener("end", this._streamEnd);
        this._input.removeListener("error", this._streamError);
      }, this);
    }
    ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
    ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;
    function DuplexStreamStreamer(_config) {
      var Duplex = require$$0$1.Duplex;
      var config = copy3(_config);
      var parseOnWrite = true;
      var writeStreamHasFinished = false;
      var parseCallbackQueue = [];
      var stream2 = null;
      this._onCsvData = function(results) {
        var data = results.data;
        if (!stream2.push(data) && !this._handle.paused()) {
          this._handle.pause();
        }
      };
      this._onCsvComplete = function() {
        stream2.push(null);
      };
      config.step = bindFunction(this._onCsvData, this);
      config.complete = bindFunction(this._onCsvComplete, this);
      ChunkStreamer.call(this, config);
      this._nextChunk = function() {
        if (writeStreamHasFinished && parseCallbackQueue.length === 1) {
          this._finished = true;
        }
        if (parseCallbackQueue.length) {
          parseCallbackQueue.shift()();
        } else {
          parseOnWrite = true;
        }
      };
      this._addToParseQueue = function(chunk, callback) {
        parseCallbackQueue.push(bindFunction(function() {
          this.parseChunk(typeof chunk === "string" ? chunk : chunk.toString(config.encoding));
          if (isFunction2(callback)) {
            return callback();
          }
        }, this));
        if (parseOnWrite) {
          parseOnWrite = false;
          this._nextChunk();
        }
      };
      this._onRead = function() {
        if (this._handle.paused()) {
          this._handle.resume();
        }
      };
      this._onWrite = function(chunk, encoding, callback) {
        this._addToParseQueue(chunk, callback);
      };
      this._onWriteComplete = function() {
        writeStreamHasFinished = true;
        this._addToParseQueue("");
      };
      this.getStream = function() {
        return stream2;
      };
      stream2 = new Duplex({
        readableObjectMode: true,
        decodeStrings: false,
        read: bindFunction(this._onRead, this),
        write: bindFunction(this._onWrite, this)
      });
      stream2.once("finish", bindFunction(this._onWriteComplete, this));
    }
    if (typeof PAPA_BROWSER_CONTEXT === "undefined") {
      DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);
      DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;
    }
    function ParserHandle(_config) {
      var MAX_FLOAT = Math.pow(2, 53);
      var MIN_FLOAT = -MAX_FLOAT;
      var FLOAT = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/;
      var ISO_DATE = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/;
      var self2 = this;
      var _stepCounter = 0;
      var _rowCounter = 0;
      var _input;
      var _parser;
      var _paused = false;
      var _aborted = false;
      var _delimiterError;
      var _fields = [];
      var _results = {
        // The last results returned from the parser
        data: [],
        errors: [],
        meta: {}
      };
      if (isFunction2(_config.step)) {
        var userStep = _config.step;
        _config.step = function(results) {
          _results = results;
          if (needsHeaderRow())
            processResults();
          else {
            processResults();
            if (_results.data.length === 0)
              return;
            _stepCounter += results.data.length;
            if (_config.preview && _stepCounter > _config.preview)
              _parser.abort();
            else {
              _results.data = _results.data[0];
              userStep(_results, self2);
            }
          }
        };
      }
      this.parse = function(input, baseIndex, ignoreLastRow) {
        var quoteChar = _config.quoteChar || '"';
        if (!_config.newline)
          _config.newline = this.guessLineEndings(input, quoteChar);
        _delimiterError = false;
        if (!_config.delimiter) {
          var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);
          if (delimGuess.successful)
            _config.delimiter = delimGuess.bestDelimiter;
          else {
            _delimiterError = true;
            _config.delimiter = Papa2.DefaultDelimiter;
          }
          _results.meta.delimiter = _config.delimiter;
        } else if (isFunction2(_config.delimiter)) {
          _config.delimiter = _config.delimiter(input);
          _results.meta.delimiter = _config.delimiter;
        }
        var parserConfig = copy3(_config);
        if (_config.preview && _config.header)
          parserConfig.preview++;
        _input = input;
        _parser = new Parser2(parserConfig);
        _results = _parser.parse(_input, baseIndex, ignoreLastRow);
        processResults();
        return _paused ? { meta: { paused: true } } : _results || { meta: { paused: false } };
      };
      this.paused = function() {
        return _paused;
      };
      this.pause = function() {
        _paused = true;
        _parser.abort();
        _input = isFunction2(_config.chunk) ? "" : _input.substring(_parser.getCharIndex());
      };
      this.resume = function() {
        if (self2.streamer._halted) {
          _paused = false;
          self2.streamer.parseChunk(_input, true);
        } else {
          setTimeout(self2.resume, 3);
        }
      };
      this.aborted = function() {
        return _aborted;
      };
      this.abort = function() {
        _aborted = true;
        _parser.abort();
        _results.meta.aborted = true;
        if (isFunction2(_config.complete))
          _config.complete(_results);
        _input = "";
      };
      this.guessLineEndings = function(input, quoteChar) {
        input = input.substring(0, 1024 * 1024);
        var re = new RegExp(escapeRegExp2(quoteChar) + "([^]*?)" + escapeRegExp2(quoteChar), "gm");
        input = input.replace(re, "");
        var r = input.split("\r");
        var n = input.split("\n");
        var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;
        if (r.length === 1 || nAppearsFirst)
          return "\n";
        var numWithN = 0;
        for (var i = 0; i < r.length; i++) {
          if (r[i][0] === "\n")
            numWithN++;
        }
        return numWithN >= r.length / 2 ? "\r\n" : "\r";
      };
      function testEmptyLine(s) {
        return _config.skipEmptyLines === "greedy" ? s.join("").trim() === "" : s.length === 1 && s[0].length === 0;
      }
      function testFloat(s) {
        if (FLOAT.test(s)) {
          var floatValue = parseFloat(s);
          if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {
            return true;
          }
        }
        return false;
      }
      function processResults() {
        if (_results && _delimiterError) {
          addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Papa2.DefaultDelimiter + "'");
          _delimiterError = false;
        }
        if (_config.skipEmptyLines) {
          _results.data = _results.data.filter(function(d) {
            return !testEmptyLine(d);
          });
        }
        if (needsHeaderRow())
          fillHeaderFields();
        return applyHeaderAndDynamicTypingAndTransformation();
      }
      function needsHeaderRow() {
        return _config.header && _fields.length === 0;
      }
      function fillHeaderFields() {
        if (!_results)
          return;
        function addHeader(header, i2) {
          if (isFunction2(_config.transformHeader))
            header = _config.transformHeader(header, i2);
          _fields.push(header);
        }
        if (Array.isArray(_results.data[0])) {
          for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
            _results.data[i].forEach(addHeader);
          _results.data.splice(0, 1);
        } else
          _results.data.forEach(addHeader);
      }
      function shouldApplyDynamicTyping(field) {
        if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === void 0) {
          _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
        }
        return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
      }
      function parseDynamic(field, value) {
        if (shouldApplyDynamicTyping(field)) {
          if (value === "true" || value === "TRUE")
            return true;
          else if (value === "false" || value === "FALSE")
            return false;
          else if (testFloat(value))
            return parseFloat(value);
          else if (ISO_DATE.test(value))
            return new Date(value);
          else
            return value === "" ? null : value;
        }
        return value;
      }
      function applyHeaderAndDynamicTypingAndTransformation() {
        if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform)
          return _results;
        function processRow(rowSource, i) {
          var row2 = _config.header ? {} : [];
          var j;
          for (j = 0; j < rowSource.length; j++) {
            var field = j;
            var value = rowSource[j];
            if (_config.header)
              field = j >= _fields.length ? "__parsed_extra" : _fields[j];
            if (_config.transform)
              value = _config.transform(value, field);
            value = parseDynamic(field, value);
            if (field === "__parsed_extra") {
              row2[field] = row2[field] || [];
              row2[field].push(value);
            } else
              row2[field] = value;
          }
          if (_config.header) {
            if (j > _fields.length)
              addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, _rowCounter + i);
            else if (j < _fields.length)
              addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, _rowCounter + i);
          }
          return row2;
        }
        var incrementBy = 1;
        if (!_results.data.length || Array.isArray(_results.data[0])) {
          _results.data = _results.data.map(processRow);
          incrementBy = _results.data.length;
        } else
          _results.data = processRow(_results.data, 0);
        if (_config.header && _results.meta)
          _results.meta.fields = _fields;
        _rowCounter += incrementBy;
        return _results;
      }
      function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
        var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;
        delimitersToGuess = delimitersToGuess || [",", "	", "|", ";", Papa2.RECORD_SEP, Papa2.UNIT_SEP];
        for (var i = 0; i < delimitersToGuess.length; i++) {
          var delim = delimitersToGuess[i];
          var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;
          fieldCountPrevRow = void 0;
          var preview = new Parser2({
            comments,
            delimiter: delim,
            newline,
            preview: 10
          }).parse(input);
          for (var j = 0; j < preview.data.length; j++) {
            if (skipEmptyLines && testEmptyLine(preview.data[j])) {
              emptyLinesCount++;
              continue;
            }
            var fieldCount = preview.data[j].length;
            avgFieldCount += fieldCount;
            if (typeof fieldCountPrevRow === "undefined") {
              fieldCountPrevRow = fieldCount;
              continue;
            } else if (fieldCount > 0) {
              delta += Math.abs(fieldCount - fieldCountPrevRow);
              fieldCountPrevRow = fieldCount;
            }
          }
          if (preview.data.length > 0)
            avgFieldCount /= preview.data.length - emptyLinesCount;
          if ((typeof bestDelta === "undefined" || delta <= bestDelta) && (typeof maxFieldCount === "undefined" || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {
            bestDelta = delta;
            bestDelim = delim;
            maxFieldCount = avgFieldCount;
          }
        }
        _config.delimiter = bestDelim;
        return {
          successful: !!bestDelim,
          bestDelimiter: bestDelim
        };
      }
      function addError(type, code, msg2, row2) {
        var error2 = {
          type,
          code,
          message: msg2
        };
        if (row2 !== void 0) {
          error2.row = row2;
        }
        _results.errors.push(error2);
      }
    }
    function escapeRegExp2(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Parser2(config) {
      config = config || {};
      var delim = config.delimiter;
      var newline = config.newline;
      var comments = config.comments;
      var step = config.step;
      var preview = config.preview;
      var fastMode = config.fastMode;
      var quoteChar;
      var renamedHeaders = null;
      var headerParsed = false;
      if (config.quoteChar === void 0 || config.quoteChar === null) {
        quoteChar = '"';
      } else {
        quoteChar = config.quoteChar;
      }
      var escapeChar = quoteChar;
      if (config.escapeChar !== void 0) {
        escapeChar = config.escapeChar;
      }
      if (typeof delim !== "string" || Papa2.BAD_DELIMITERS.indexOf(delim) > -1)
        delim = ",";
      if (comments === delim)
        throw new Error("Comment character same as delimiter");
      else if (comments === true)
        comments = "#";
      else if (typeof comments !== "string" || Papa2.BAD_DELIMITERS.indexOf(comments) > -1)
        comments = false;
      if (newline !== "\n" && newline !== "\r" && newline !== "\r\n")
        newline = "\n";
      var cursor = 0;
      var aborted = false;
      this.parse = function(input, baseIndex, ignoreLastRow) {
        if (typeof input !== "string")
          throw new Error("Input must be a string");
        var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length;
        var stepIsFunction = isFunction2(step);
        cursor = 0;
        var data = [], errors2 = [], row2 = [], lastCursor = 0;
        if (!input)
          return returnable();
        if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {
          var rows = input.split(newline);
          for (var i = 0; i < rows.length; i++) {
            row2 = rows[i];
            cursor += row2.length;
            if (i !== rows.length - 1)
              cursor += newline.length;
            else if (ignoreLastRow)
              return returnable();
            if (comments && row2.substring(0, commentsLen) === comments)
              continue;
            if (stepIsFunction) {
              data = [];
              pushRow(row2.split(delim));
              doStep();
              if (aborted)
                return returnable();
            } else
              pushRow(row2.split(delim));
            if (preview && i >= preview) {
              data = data.slice(0, preview);
              return returnable(true);
            }
          }
          return returnable();
        }
        var nextDelim = input.indexOf(delim, cursor);
        var nextNewline = input.indexOf(newline, cursor);
        var quoteCharRegex = new RegExp(escapeRegExp2(escapeChar) + escapeRegExp2(quoteChar), "g");
        var quoteSearch = input.indexOf(quoteChar, cursor);
        for (; ; ) {
          if (input[cursor] === quoteChar) {
            quoteSearch = cursor;
            cursor++;
            for (; ; ) {
              quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);
              if (quoteSearch === -1) {
                if (!ignoreLastRow) {
                  errors2.push({
                    type: "Quotes",
                    code: "MissingQuotes",
                    message: "Quoted field unterminated",
                    row: data.length,
                    // row has yet to be inserted
                    index: cursor
                  });
                }
                return finish2();
              }
              if (quoteSearch === inputLen - 1) {
                var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
                return finish2(value);
              }
              if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
                quoteSearch++;
                continue;
              }
              if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {
                continue;
              }
              if (nextDelim !== -1 && nextDelim < quoteSearch + 1) {
                nextDelim = input.indexOf(delim, quoteSearch + 1);
              }
              if (nextNewline !== -1 && nextNewline < quoteSearch + 1) {
                nextNewline = input.indexOf(newline, quoteSearch + 1);
              }
              var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
              var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);
              if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndDelimiter, delimLen) === delim) {
                row2.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
                cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
                if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar) {
                  quoteSearch = input.indexOf(quoteChar, cursor);
                }
                nextDelim = input.indexOf(delim, cursor);
                nextNewline = input.indexOf(newline, cursor);
                break;
              }
              var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);
              if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {
                row2.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
                saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
                nextDelim = input.indexOf(delim, cursor);
                quoteSearch = input.indexOf(quoteChar, cursor);
                if (stepIsFunction) {
                  doStep();
                  if (aborted)
                    return returnable();
                }
                if (preview && data.length >= preview)
                  return returnable(true);
                break;
              }
              errors2.push({
                type: "Quotes",
                code: "InvalidQuotes",
                message: "Trailing quote on quoted field is malformed",
                row: data.length,
                // row has yet to be inserted
                index: cursor
              });
              quoteSearch++;
              continue;
            }
            continue;
          }
          if (comments && row2.length === 0 && input.substring(cursor, cursor + commentsLen) === comments) {
            if (nextNewline === -1)
              return returnable();
            cursor = nextNewline + newlineLen;
            nextNewline = input.indexOf(newline, cursor);
            nextDelim = input.indexOf(delim, cursor);
            continue;
          }
          if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
            row2.push(input.substring(cursor, nextDelim));
            cursor = nextDelim + delimLen;
            nextDelim = input.indexOf(delim, cursor);
            continue;
          }
          if (nextNewline !== -1) {
            row2.push(input.substring(cursor, nextNewline));
            saveRow(nextNewline + newlineLen);
            if (stepIsFunction) {
              doStep();
              if (aborted)
                return returnable();
            }
            if (preview && data.length >= preview)
              return returnable(true);
            continue;
          }
          break;
        }
        return finish2();
        function pushRow(row3) {
          data.push(row3);
          lastCursor = cursor;
        }
        function extraSpaces(index2) {
          var spaceLength = 0;
          if (index2 !== -1) {
            var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index2);
            if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === "") {
              spaceLength = textBetweenClosingQuoteAndIndex.length;
            }
          }
          return spaceLength;
        }
        function finish2(value2) {
          if (ignoreLastRow)
            return returnable();
          if (typeof value2 === "undefined")
            value2 = input.substring(cursor);
          row2.push(value2);
          cursor = inputLen;
          pushRow(row2);
          if (stepIsFunction)
            doStep();
          return returnable();
        }
        function saveRow(newCursor) {
          cursor = newCursor;
          pushRow(row2);
          row2 = [];
          nextNewline = input.indexOf(newline, cursor);
        }
        function returnable(stopped) {
          if (config.header && !baseIndex && data.length && !headerParsed) {
            const result = data[0];
            const headerCount = {};
            const usedHeaders = new Set(result);
            let duplicateHeaders = false;
            for (let i2 = 0; i2 < result.length; i2++) {
              let header = result[i2];
              if (isFunction2(config.transformHeader))
                header = config.transformHeader(header, i2);
              if (!headerCount[header]) {
                headerCount[header] = 1;
                result[i2] = header;
              } else {
                let newHeader;
                let suffixCount = headerCount[header];
                do {
                  newHeader = `${header}_${suffixCount}`;
                  suffixCount++;
                } while (usedHeaders.has(newHeader));
                usedHeaders.add(newHeader);
                result[i2] = newHeader;
                headerCount[header]++;
                duplicateHeaders = true;
                if (renamedHeaders === null) {
                  renamedHeaders = {};
                }
                renamedHeaders[newHeader] = header;
              }
              usedHeaders.add(header);
            }
            if (duplicateHeaders) {
              console.warn("Duplicate headers found and renamed.");
            }
            headerParsed = true;
          }
          return {
            data,
            errors: errors2,
            meta: {
              delimiter: delim,
              linebreak: newline,
              aborted,
              truncated: !!stopped,
              cursor: lastCursor + (baseIndex || 0),
              renamedHeaders
            }
          };
        }
        function doStep() {
          step(returnable());
          data = [];
          errors2 = [];
        }
      };
      this.abort = function() {
        aborted = true;
      };
      this.getCharIndex = function() {
        return cursor;
      };
    }
    function newWorker() {
      if (!Papa2.WORKERS_SUPPORTED)
        return false;
      var workerUrl = getWorkerBlob();
      var w = new global2.Worker(workerUrl);
      w.onmessage = mainThreadReceivedMessage;
      w.id = workerIdCounter++;
      workers[w.id] = w;
      return w;
    }
    function mainThreadReceivedMessage(e) {
      var msg2 = e.data;
      var worker = workers[msg2.workerId];
      var aborted = false;
      if (msg2.error)
        worker.userError(msg2.error, msg2.file);
      else if (msg2.results && msg2.results.data) {
        var abort = function() {
          aborted = true;
          completeWorker(msg2.workerId, { data: [], errors: [], meta: { aborted: true } });
        };
        var handle = {
          abort,
          pause: notImplemented,
          resume: notImplemented
        };
        if (isFunction2(worker.userStep)) {
          for (var i = 0; i < msg2.results.data.length; i++) {
            worker.userStep({
              data: msg2.results.data[i],
              errors: msg2.results.errors,
              meta: msg2.results.meta
            }, handle);
            if (aborted)
              break;
          }
          delete msg2.results;
        } else if (isFunction2(worker.userChunk)) {
          worker.userChunk(msg2.results, handle, msg2.file);
          delete msg2.results;
        }
      }
      if (msg2.finished && !aborted)
        completeWorker(msg2.workerId, msg2.results);
    }
    function completeWorker(workerId, results) {
      var worker = workers[workerId];
      if (isFunction2(worker.userComplete))
        worker.userComplete(results);
      worker.terminate();
      delete workers[workerId];
    }
    function notImplemented() {
      throw new Error("Not implemented.");
    }
    function workerThreadReceivedMessage(e) {
      var msg2 = e.data;
      if (typeof Papa2.WORKER_ID === "undefined" && msg2)
        Papa2.WORKER_ID = msg2.workerId;
      if (typeof msg2.input === "string") {
        global2.postMessage({
          workerId: Papa2.WORKER_ID,
          results: Papa2.parse(msg2.input, msg2.config),
          finished: true
        });
      } else if (global2.File && msg2.input instanceof File || msg2.input instanceof Object) {
        var results = Papa2.parse(msg2.input, msg2.config);
        if (results)
          global2.postMessage({
            workerId: Papa2.WORKER_ID,
            results,
            finished: true
          });
      }
    }
    function copy3(obj) {
      if (typeof obj !== "object" || obj === null)
        return obj;
      var cpy = Array.isArray(obj) ? [] : {};
      for (var key in obj)
        cpy[key] = copy3(obj[key]);
      return cpy;
    }
    function bindFunction(f, self2) {
      return function() {
        f.apply(self2, arguments);
      };
    }
    function isFunction2(func) {
      return typeof func === "function";
    }
    return Papa2;
  });
})(papaparse);
var papaparseExports = papaparse.exports;
const Papa = /* @__PURE__ */ getDefaultExportFromCjs(papaparseExports);
function generateAttendanceSheet(options) {
  console.log("[AttendanceGen] Starting generation with options:", options);
  return new Promise((resolve2, reject2) => {
    const { data, outputFile } = options;
    const doc = new PDFDocument({ size: "A4", layout: "portrait", margin: 30 });
    const stream2 = require$$0$2.createWriteStream(outputFile);
    doc.pipe(stream2);
    const pageWidth = doc.page.width;
    const pageHeight = doc.page.height;
    const margin = 30;
    const maxRowsPerPage = 25;
    const totalPages = Math.ceil(data.students.length / maxRowsPerPage) || 1;
    console.log(`[AttendanceGen] Calculated total pages: ${totalPages}`);
    const baseHeaders = ["S. No", "Batch", "Sem.", "Student Name", "University Roll No", "Answer Sheet Serial No.", "Machine No.", "Signature", "Time Out"];
    const baseColWidths = [35, 40, 35, 120, 80, 70, 60, 70, 50];
    const rowHeight = 20;
    for (let currentPage = 1; currentPage <= totalPages; currentPage++) {
      console.log(`[AttendanceGen] Processing page: ${currentPage}`);
      let yPos = margin;
      if (data.logoPath) {
        try {
          doc.image(data.logoPath, margin, yPos, { width: 50 });
        } catch (err2) {
          console.warn(`Warning: Logo image not found at ${data.logoPath}`);
        }
      }
      doc.fontSize(10).font("Helvetica").text(`${currentPage}/${totalPages}`, pageWidth - margin - 50, yPos, { width: 50, align: "right" });
      yPos += 5;
      doc.fontSize(14).font("Helvetica-Bold").text(data.universityName, margin, yPos, { align: "center" });
      yPos += 16;
      doc.fontSize(11).font("Helvetica").text(data.examTitle, margin, yPos, { align: "center" });
      yPos += 20;
      doc.fontSize(9).font("Helvetica-Bold").text("Note:", margin, yPos);
      yPos += 12;
      doc.font("Helvetica");
      data.noteLines.forEach((line) => {
        doc.text(line, margin + 10, yPos, { continued: false, indent: 5 });
        yPos += 11;
      });
      yPos += 30;
      const detailStartY = yPos;
      doc.fontSize(10).font("Helvetica-Bold");
      doc.text(`Date & Session: ${data.dateAndSession}`, margin, yPos);
      yPos += 14;
      doc.text(`Subject: ${data.subject}`, margin, yPos);
      yPos += 14;
      doc.text(`Mode of Examination: ${data.modeOfExamination}`, margin, yPos);
      yPos = detailStartY;
      const rightColX = pageWidth / 2 + 20;
      doc.text(`Branch/Sem/Batch: ${data.branchSemBatch}`, rightColX, yPos, { align: "right" });
      yPos += 14;
      doc.text(`Subject Code: ${data.subjectCode}`, rightColX, yPos, { align: "right" });
      yPos += 14;
      doc.text(`Session-${data.session}`, rightColX, yPos, { align: "right" });
      yPos += 25;
      const tableTop = yPos;
      let headers2 = [...baseHeaders];
      let colWidths = [...baseColWidths];
      if (data.modeOfExamination.toUpperCase() === "OFFLINE") {
        const machineNoIndex = headers2.indexOf("Machine No.");
        if (machineNoIndex > -1) {
          headers2.splice(machineNoIndex, 1);
          colWidths.splice(machineNoIndex, 1);
        }
        const timeOutIndex = headers2.indexOf("Time Out");
        if (timeOutIndex > -1) {
          headers2.splice(timeOutIndex, 1);
          colWidths.splice(timeOutIndex, 1);
        }
      }
      const tableWidth = colWidths.reduce((a, b) => a + b, 0);
      const tableStartX = (pageWidth - tableWidth) / 2;
      doc.font("Helvetica-Bold").fontSize(8);
      let currentX = tableStartX;
      const headerRowHeight = rowHeight * (headers2.some((h) => h.includes("\n")) ? 1.5 : 1);
      headers2.forEach((header, i) => {
        const headerHeightMultiplier = header.includes("\n") ? 1.5 : 1;
        const headerYOffset = header.includes("Answer Sheet") ? 1.5 : 7;
        doc.rect(currentX, tableTop, colWidths[i], rowHeight * headerHeightMultiplier).stroke();
        doc.text(header.replace("\n", "\n"), currentX + 2, tableTop + headerYOffset, { width: colWidths[i] - 4, align: "center" });
        currentX += colWidths[i];
      });
      doc.font("Helvetica").fontSize(8);
      const startStudentIndex = (currentPage - 1) * maxRowsPerPage;
      const endStudentIndex = Math.min(startStudentIndex + maxRowsPerPage, data.students.length);
      console.log(`[AttendanceGen] Page ${currentPage} - Student index range: ${startStudentIndex} to ${endStudentIndex - 1}`);
      let tableBottom = tableTop + headerRowHeight;
      for (let i = startStudentIndex; i < endStudentIndex; i++) {
        const student = data.students[i];
        const rowIndexOnPage = i - startStudentIndex;
        const currentY = tableTop + headerRowHeight + rowIndexOnPage * rowHeight;
        console.log(`[AttendanceGen] Page ${currentPage} - Drawing row for student index ${i} at Y: ${currentY}`);
        currentX = tableStartX;
        if (currentY + rowHeight > pageHeight - 100) break;
        colWidths.forEach((colWidth, j) => {
          doc.rect(currentX, currentY, colWidth, rowHeight).stroke();
          let cellText = "";
          const header = headers2[j];
          if (student) {
            switch (header) {
              case "S. No":
                cellText = (i + 1).toString();
                break;
              case "Batch":
                cellText = student.batch.toString();
                break;
              case "Sem.":
                cellText = student.sem.toString();
                break;
              case "Student Name":
                cellText = student.studentName;
                break;
              case "University Roll No":
                cellText = student.universityRollNo;
                break;
              default:
                cellText = "";
            }
          }
          let align = "left";
          if (["S. No", "Batch", "Sem.", "University Roll No"].includes(header)) {
            align = "center";
          }
          doc.text(cellText, currentX + 2, currentY + 5, {
            width: colWidth - 4,
            align
          });
          currentX += colWidth;
        });
        tableBottom = currentY + rowHeight;
      }
      let footerYPos = tableBottom + 20;
      console.log(`[AttendanceGen] Page ${currentPage} - Calculated footer Y position: ${footerYPos}`);
      doc.fontSize(9).font("Helvetica");
      doc.text("Total No. of Presentees: __________", margin, footerYPos);
      doc.text("Total No. of Absentees: __________", margin + 220, footerYPos);
      doc.text("Total No. of Detainees: __________", margin + 420, footerYPos);
      footerYPos += 20;
      doc.text("Unfair Means Case(s) Roll No. (if any): ____________________", margin, footerYPos);
      footerYPos += 30;
      doc.text("Name of the Invigilators", margin, footerYPos);
      doc.text("Signature of the Invigilators", pageWidth - margin - 150, footerYPos, { align: "right" });
      footerYPos += 10;
      if (currentPage < totalPages) {
        doc.addPage();
      }
    }
    doc.end();
    stream2.on("finish", () => {
      console.log(`[AttendanceGen] PDF generation finished for: ${outputFile}`);
      resolve2(outputFile);
    });
    stream2.on("error", (err2) => {
      console.error(`[AttendanceGen] Error generating PDF: ${outputFile}`, err2);
      reject2(err2);
    });
  });
}
const { toString: toString$3 } = Object.prototype;
const escapeHtmlRegex = /["&<>]/;
const _$m = {
  each: function each(obj, cb) {
    if (obj) {
      if (Array.isArray(obj)) {
        obj.forEach(cb);
      } else {
        Object.keys(obj).forEach((key) => {
          cb(obj[key], key);
        });
      }
    }
  },
  some: function some(obj, cb) {
    if (obj) {
      if (Array.isArray(obj)) {
        return obj.some(cb);
      }
      return Object.keys(obj).some((key) => cb(obj[key], key));
    }
    return false;
  },
  every: function every(obj, cb) {
    if (obj) {
      if (Array.isArray(obj)) {
        return obj.every(cb);
      }
      return Object.keys(obj).every((key) => cb(obj[key], key));
    }
    return true;
  },
  map: function map(obj, cb) {
    if (obj) {
      if (Array.isArray(obj)) {
        return obj.map(cb);
      }
      return Object.keys(obj).map((key) => cb(obj[key], key));
    }
    return [];
  },
  keyBy(a, p) {
    return a.reduce((o, v) => {
      o[v[p]] = v;
      return o;
    }, {});
  },
  isEqual: function isEqual(a, b) {
    const aType = typeof a;
    const bType = typeof b;
    const aArray = Array.isArray(a);
    const bArray = Array.isArray(b);
    let keys;
    if (aType !== bType) {
      return false;
    }
    switch (typeof a) {
      case "object":
        if (aArray || bArray) {
          if (aArray && bArray) {
            return a.length === b.length && a.every((aValue, index2) => {
              const bValue = b[index2];
              return _$m.isEqual(aValue, bValue);
            });
          }
          return false;
        }
        if (a === null || b === null) {
          return a === b;
        }
        keys = Object.keys(a);
        if (Object.keys(b).length !== keys.length) {
          return false;
        }
        for (const key of keys) {
          if (!b.hasOwnProperty(key)) {
            return false;
          }
        }
        return _$m.every(a, (aValue, key) => {
          const bValue = b[key];
          return _$m.isEqual(aValue, bValue);
        });
      default:
        return a === b;
    }
  },
  escapeHtml(html) {
    const regexResult = escapeHtmlRegex.exec(html);
    if (!regexResult) return html;
    let result = "";
    let escape = "";
    let lastIndex = 0;
    let i = regexResult.index;
    for (; i < html.length; i++) {
      switch (html.charAt(i)) {
        case '"':
          escape = "&quot;";
          break;
        case "&":
          escape = "&amp;";
          break;
        case "'":
          escape = "&apos;";
          break;
        case "<":
          escape = "&lt;";
          break;
        case ">":
          escape = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== i) result += html.substring(lastIndex, i);
      lastIndex = i + 1;
      result += escape;
    }
    if (lastIndex !== i) return result + html.substring(lastIndex, i);
    return result;
  },
  strcmp(a, b) {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  },
  isUndefined(val) {
    return toString$3.call(val) === "[object Undefined]";
  },
  isObject(val) {
    return toString$3.call(val) === "[object Object]";
  },
  deepMerge() {
    const target = arguments[0] || {};
    const { length } = arguments;
    let src2, clone2, copyIsArray;
    function assignValue2(val, key) {
      src2 = target[key];
      copyIsArray = Array.isArray(val);
      if (_$m.isObject(val) || copyIsArray) {
        if (copyIsArray) {
          copyIsArray = false;
          clone2 = src2 && Array.isArray(src2) ? src2 : [];
        } else {
          clone2 = src2 && _$m.isObject(src2) ? src2 : {};
        }
        target[key] = _$m.deepMerge(clone2, val);
      } else if (!_$m.isUndefined(val)) {
        target[key] = val;
      }
    }
    for (let i = 0; i < length; i++) {
      _$m.each(arguments[i], assignValue2);
    }
    return target;
  }
};
var underDash = _$m;
const addressRegex = /^[A-Z]+\d+$/;
const colCache$m = {
  _dictionary: [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z"
  ],
  _l2nFill: 0,
  _l2n: {},
  _n2l: [],
  _level(n) {
    if (n <= 26) {
      return 1;
    }
    if (n <= 26 * 26) {
      return 2;
    }
    return 3;
  },
  _fill(level) {
    let c2;
    let v;
    let l1;
    let l2;
    let l3;
    let n = 1;
    if (level >= 4) {
      throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
    }
    if (this._l2nFill < 1 && level >= 1) {
      while (n <= 26) {
        c2 = this._dictionary[n - 1];
        this._n2l[n] = c2;
        this._l2n[c2] = n;
        n++;
      }
      this._l2nFill = 1;
    }
    if (this._l2nFill < 2 && level >= 2) {
      n = 27;
      while (n <= 26 + 26 * 26) {
        v = n - (26 + 1);
        l1 = v % 26;
        l2 = Math.floor(v / 26);
        c2 = this._dictionary[l2] + this._dictionary[l1];
        this._n2l[n] = c2;
        this._l2n[c2] = n;
        n++;
      }
      this._l2nFill = 2;
    }
    if (this._l2nFill < 3 && level >= 3) {
      n = 26 + 26 * 26 + 1;
      while (n <= 16384) {
        v = n - (26 * 26 + 26 + 1);
        l1 = v % 26;
        l2 = Math.floor(v / 26) % 26;
        l3 = Math.floor(v / (26 * 26));
        c2 = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
        this._n2l[n] = c2;
        this._l2n[c2] = n;
        n++;
      }
      this._l2nFill = 3;
    }
  },
  l2n(l) {
    if (!this._l2n[l]) {
      this._fill(l.length);
    }
    if (!this._l2n[l]) {
      throw new Error(`Out of bounds. Invalid column letter: ${l}`);
    }
    return this._l2n[l];
  },
  n2l(n) {
    if (n < 1 || n > 16384) {
      throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);
    }
    if (!this._n2l[n]) {
      this._fill(this._level(n));
    }
    return this._n2l[n];
  },
  // =========================================================================
  // Address processing
  _hash: {},
  // check if value looks like an address
  validateAddress(value) {
    if (!addressRegex.test(value)) {
      throw new Error(`Invalid Address: ${value}`);
    }
    return true;
  },
  // convert address string into structure
  decodeAddress(value) {
    const addr = value.length < 5 && this._hash[value];
    if (addr) {
      return addr;
    }
    let hasCol = false;
    let col = "";
    let colNumber = 0;
    let hasRow = false;
    let row2 = "";
    let rowNumber = 0;
    for (let i = 0, char; i < value.length; i++) {
      char = value.charCodeAt(i);
      if (!hasRow && char >= 65 && char <= 90) {
        hasCol = true;
        col += value[i];
        colNumber = colNumber * 26 + char - 64;
      } else if (char >= 48 && char <= 57) {
        hasRow = true;
        row2 += value[i];
        rowNumber = rowNumber * 10 + char - 48;
      } else if (hasRow && hasCol && char !== 36) {
        break;
      }
    }
    if (!hasCol) {
      colNumber = void 0;
    } else if (colNumber > 16384) {
      throw new Error(`Out of bounds. Invalid column letter: ${col}`);
    }
    if (!hasRow) {
      rowNumber = void 0;
    }
    value = col + row2;
    const address = {
      address: value,
      col: colNumber,
      row: rowNumber,
      $col$row: `$${col}$${row2}`
    };
    if (colNumber <= 100 && rowNumber <= 100) {
      this._hash[value] = address;
      this._hash[address.$col$row] = address;
    }
    return address;
  },
  // convert r,c into structure (if only 1 arg, assume r is address string)
  getAddress(r, c2) {
    if (c2) {
      const address = this.n2l(c2) + r;
      return this.decodeAddress(address);
    }
    return this.decodeAddress(r);
  },
  // convert [address], [tl:br] into address structures
  decode(value) {
    const parts = value.split(":");
    if (parts.length === 2) {
      const tl = this.decodeAddress(parts[0]);
      const br = this.decodeAddress(parts[1]);
      const result = {
        top: Math.min(tl.row, br.row),
        left: Math.min(tl.col, br.col),
        bottom: Math.max(tl.row, br.row),
        right: Math.max(tl.col, br.col)
      };
      result.tl = this.n2l(result.left) + result.top;
      result.br = this.n2l(result.right) + result.bottom;
      result.dimensions = `${result.tl}:${result.br}`;
      return result;
    }
    return this.decodeAddress(value);
  },
  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures
  decodeEx(value) {
    const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);
    const sheetName = groups[1] || groups[2];
    const reference = groups[3];
    const parts = reference.split(":");
    if (parts.length > 1) {
      let tl = this.decodeAddress(parts[0]);
      let br = this.decodeAddress(parts[1]);
      const top = Math.min(tl.row, br.row);
      const left = Math.min(tl.col, br.col);
      const bottom = Math.max(tl.row, br.row);
      const right = Math.max(tl.col, br.col);
      tl = this.n2l(left) + top;
      br = this.n2l(right) + bottom;
      return {
        top,
        left,
        bottom,
        right,
        sheetName,
        tl: { address: tl, col: left, row: top, $col$row: `$${this.n2l(left)}$${top}`, sheetName },
        br: {
          address: br,
          col: right,
          row: bottom,
          $col$row: `$${this.n2l(right)}$${bottom}`,
          sheetName
        },
        dimensions: `${tl}:${br}`
      };
    }
    if (reference.startsWith("#")) {
      return sheetName ? { sheetName, error: reference } : { error: reference };
    }
    const address = this.decodeAddress(reference);
    return sheetName ? { sheetName, ...address } : address;
  },
  // convert row,col into address string
  encodeAddress(row2, col) {
    return colCache$m.n2l(col) + row2;
  },
  // convert row,col into string address or t,l,b,r into range
  encode() {
    switch (arguments.length) {
      case 2:
        return colCache$m.encodeAddress(arguments[0], arguments[1]);
      case 4:
        return `${colCache$m.encodeAddress(arguments[0], arguments[1])}:${colCache$m.encodeAddress(
          arguments[2],
          arguments[3]
        )}`;
      default:
        throw new Error("Can only encode with 2 or 4 arguments");
    }
  },
  // return true if address is contained within range
  inRange(range2, address) {
    const [left, top, , right, bottom] = range2;
    const [col, row2] = address;
    return col >= left && col <= right && row2 >= top && row2 <= bottom;
  }
};
var colCache_1 = colCache$m;
const colCache$l = colCache_1;
let Range$6 = class Range {
  constructor() {
    this.decode(arguments);
  }
  setTLBR(t, l, b, r, s) {
    if (arguments.length < 4) {
      const tl = colCache$l.decodeAddress(t);
      const br = colCache$l.decodeAddress(l);
      this.model = {
        top: Math.min(tl.row, br.row),
        left: Math.min(tl.col, br.col),
        bottom: Math.max(tl.row, br.row),
        right: Math.max(tl.col, br.col),
        sheetName: b
      };
      this.setTLBR(tl.row, tl.col, br.row, br.col, s);
    } else {
      this.model = {
        top: Math.min(t, b),
        left: Math.min(l, r),
        bottom: Math.max(t, b),
        right: Math.max(l, r),
        sheetName: s
      };
    }
  }
  decode(argv) {
    switch (argv.length) {
      case 5:
        this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);
        break;
      case 4:
        this.setTLBR(argv[0], argv[1], argv[2], argv[3]);
        break;
      case 3:
        this.setTLBR(argv[0], argv[1], argv[2]);
        break;
      case 2:
        this.setTLBR(argv[0], argv[1]);
        break;
      case 1: {
        const value = argv[0];
        if (value instanceof Range) {
          this.model = {
            top: value.model.top,
            left: value.model.left,
            bottom: value.model.bottom,
            right: value.model.right,
            sheetName: value.sheetName
          };
        } else if (value instanceof Array) {
          this.decode(value);
        } else if (value.top && value.left && value.bottom && value.right) {
          this.model = {
            top: value.top,
            left: value.left,
            bottom: value.bottom,
            right: value.right,
            sheetName: value.sheetName
          };
        } else {
          const tlbr = colCache$l.decodeEx(value);
          if (tlbr.top) {
            this.model = {
              top: tlbr.top,
              left: tlbr.left,
              bottom: tlbr.bottom,
              right: tlbr.right,
              sheetName: tlbr.sheetName
            };
          } else {
            this.model = {
              top: tlbr.row,
              left: tlbr.col,
              bottom: tlbr.row,
              right: tlbr.col,
              sheetName: tlbr.sheetName
            };
          }
        }
        break;
      }
      case 0:
        this.model = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        };
        break;
      default:
        throw new Error(`Invalid number of arguments to _getDimensions() - ${argv.length}`);
    }
  }
  get top() {
    return this.model.top || 1;
  }
  set top(value) {
    this.model.top = value;
  }
  get left() {
    return this.model.left || 1;
  }
  set left(value) {
    this.model.left = value;
  }
  get bottom() {
    return this.model.bottom || 1;
  }
  set bottom(value) {
    this.model.bottom = value;
  }
  get right() {
    return this.model.right || 1;
  }
  set right(value) {
    this.model.right = value;
  }
  get sheetName() {
    return this.model.sheetName;
  }
  set sheetName(value) {
    this.model.sheetName = value;
  }
  get _serialisedSheetName() {
    const { sheetName } = this.model;
    if (sheetName) {
      if (/^[a-zA-Z0-9]*$/.test(sheetName)) {
        return `${sheetName}!`;
      }
      return `'${sheetName}'!`;
    }
    return "";
  }
  expand(top, left, bottom, right) {
    if (!this.model.top || top < this.top) this.top = top;
    if (!this.model.left || left < this.left) this.left = left;
    if (!this.model.bottom || bottom > this.bottom) this.bottom = bottom;
    if (!this.model.right || right > this.right) this.right = right;
  }
  expandRow(row2) {
    if (row2) {
      const { dimensions, number } = row2;
      if (dimensions) {
        this.expand(number, dimensions.min, number, dimensions.max);
      }
    }
  }
  expandToAddress(addressStr) {
    const address = colCache$l.decodeEx(addressStr);
    this.expand(address.row, address.col, address.row, address.col);
  }
  get tl() {
    return colCache$l.n2l(this.left) + this.top;
  }
  get $t$l() {
    return `$${colCache$l.n2l(this.left)}$${this.top}`;
  }
  get br() {
    return colCache$l.n2l(this.right) + this.bottom;
  }
  get $b$r() {
    return `$${colCache$l.n2l(this.right)}$${this.bottom}`;
  }
  get range() {
    return `${this._serialisedSheetName + this.tl}:${this.br}`;
  }
  get $range() {
    return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;
  }
  get shortRange() {
    return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
  }
  get $shortRange() {
    return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
  }
  get count() {
    return (1 + this.bottom - this.top) * (1 + this.right - this.left);
  }
  toString() {
    return this.range;
  }
  intersects(other) {
    if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName) return false;
    if (other.bottom < this.top) return false;
    if (other.top > this.bottom) return false;
    if (other.right < this.left) return false;
    if (other.left > this.right) return false;
    return true;
  }
  contains(addressStr) {
    const address = colCache$l.decodeEx(addressStr);
    return this.containsEx(address);
  }
  containsEx(address) {
    if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName) return false;
    return address.row >= this.top && address.row <= this.bottom && address.col >= this.left && address.col <= this.right;
  }
  forEachAddress(cb) {
    for (let col = this.left; col <= this.right; col++) {
      for (let row2 = this.top; row2 <= this.bottom; row2++) {
        cb(colCache$l.encodeAddress(row2, col), row2, col);
      }
    }
  }
};
var range$2 = Range$6;
var enums = {
  ValueType: {
    Null: 0,
    Merge: 1,
    Number: 2,
    String: 3,
    Date: 4,
    Hyperlink: 5,
    Formula: 6,
    SharedString: 7,
    RichText: 8,
    Boolean: 9,
    Error: 10
  },
  FormulaType: {
    None: 0,
    Master: 1,
    Shared: 2
  },
  RelationshipType: {
    None: 0,
    OfficeDocument: 1,
    Worksheet: 2,
    CalcChain: 3,
    SharedStrings: 4,
    Styles: 5,
    Theme: 6,
    Hyperlink: 7
  },
  DocumentType: {
    Xlsx: 1
  },
  ReadingOrder: {
    LeftToRight: 1,
    RightToLeft: 2
  },
  ErrorValue: {
    NotApplicable: "#N/A",
    Ref: "#REF!",
    Name: "#NAME?",
    DivZero: "#DIV/0!",
    Null: "#NULL!",
    Value: "#VALUE!",
    Num: "#NUM!"
  }
};
const colCache$k = colCache_1;
const replacementCandidateRx = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;
const CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
function slideFormula$1(formula, fromCell, toCell) {
  const offset = colCache$k.decode(fromCell);
  const to = colCache$k.decode(toCell);
  return formula.replace(
    replacementCandidateRx,
    (refMatch, sheet, sheetMaybe, addrPart, trailingParen) => {
      if (trailingParen) {
        return refMatch;
      }
      const match2 = CRrx.exec(addrPart);
      if (match2) {
        const colDollar = match2[1];
        const colStr = match2[2].toUpperCase();
        const rowDollar = match2[3];
        const rowStr = match2[4];
        if (colStr.length > 3 || colStr.length === 3 && colStr > "XFD") {
          return refMatch;
        }
        let col = colCache$k.l2n(colStr);
        let row2 = parseInt(rowStr, 10);
        if (!colDollar) {
          col += to.col - offset.col;
        }
        if (!rowDollar) {
          row2 += to.row - offset.row;
        }
        const res = (sheet || "") + (colDollar || "") + colCache$k.n2l(col) + (rowDollar || "") + row2;
        return res;
      }
      return refMatch;
    }
  );
}
var sharedFormula = {
  slideFormula: slideFormula$1
};
const _$l = underDash;
let Note$1 = class Note {
  constructor(note2) {
    this.note = note2;
  }
  get model() {
    let value = null;
    switch (typeof this.note) {
      case "string":
        value = {
          type: "note",
          note: {
            texts: [
              {
                text: this.note
              }
            ]
          }
        };
        break;
      default:
        value = {
          type: "note",
          note: this.note
        };
        break;
    }
    return _$l.deepMerge({}, Note.DEFAULT_CONFIGS, value);
  }
  set model(value) {
    const { note: note2 } = value;
    const { texts } = note2;
    if (texts.length === 1 && Object.keys(texts[0]).length === 1) {
      this.note = texts[0].text;
    } else {
      this.note = note2;
    }
  }
  static fromModel(model) {
    const note2 = new Note();
    note2.model = model;
    return note2;
  }
};
Note$1.DEFAULT_CONFIGS = {
  note: {
    margins: {
      insetmode: "auto",
      inset: [0.13, 0.13, 0.25, 0.25]
    },
    protection: {
      locked: "True",
      lockText: "True"
    },
    editAs: "absolute"
  }
};
var note = Note$1;
const colCache$j = colCache_1;
const _$k = underDash;
const Enums$8 = enums;
const { slideFormula } = sharedFormula;
const Note2 = note;
let Cell$1 = class Cell {
  constructor(row2, column2, address) {
    if (!row2 || !column2) {
      throw new Error("A Cell needs a Row");
    }
    this._row = row2;
    this._column = column2;
    colCache$j.validateAddress(address);
    this._address = address;
    this._value = Value.create(Cell.Types.Null, this);
    this.style = this._mergeStyle(row2.style, column2.style, {});
    this._mergeCount = 0;
  }
  get worksheet() {
    return this._row.worksheet;
  }
  get workbook() {
    return this._row.worksheet.workbook;
  }
  // help GC by removing cyclic (and other) references
  destroy() {
    delete this.style;
    delete this._value;
    delete this._row;
    delete this._column;
    delete this._address;
  }
  // =========================================================================
  // Styles stuff
  get numFmt() {
    return this.style.numFmt;
  }
  set numFmt(value) {
    this.style.numFmt = value;
  }
  get font() {
    return this.style.font;
  }
  set font(value) {
    this.style.font = value;
  }
  get alignment() {
    return this.style.alignment;
  }
  set alignment(value) {
    this.style.alignment = value;
  }
  get border() {
    return this.style.border;
  }
  set border(value) {
    this.style.border = value;
  }
  get fill() {
    return this.style.fill;
  }
  set fill(value) {
    this.style.fill = value;
  }
  get protection() {
    return this.style.protection;
  }
  set protection(value) {
    this.style.protection = value;
  }
  _mergeStyle(rowStyle, colStyle, style) {
    const numFmt = rowStyle && rowStyle.numFmt || colStyle && colStyle.numFmt;
    if (numFmt) style.numFmt = numFmt;
    const font = rowStyle && rowStyle.font || colStyle && colStyle.font;
    if (font) style.font = font;
    const alignment = rowStyle && rowStyle.alignment || colStyle && colStyle.alignment;
    if (alignment) style.alignment = alignment;
    const border = rowStyle && rowStyle.border || colStyle && colStyle.border;
    if (border) style.border = border;
    const fill = rowStyle && rowStyle.fill || colStyle && colStyle.fill;
    if (fill) style.fill = fill;
    const protection = rowStyle && rowStyle.protection || colStyle && colStyle.protection;
    if (protection) style.protection = protection;
    return style;
  }
  // =========================================================================
  // return the address for this cell
  get address() {
    return this._address;
  }
  get row() {
    return this._row.number;
  }
  get col() {
    return this._column.number;
  }
  get $col$row() {
    return `$${this._column.letter}$${this.row}`;
  }
  // =========================================================================
  // Value stuff
  get type() {
    return this._value.type;
  }
  get effectiveType() {
    return this._value.effectiveType;
  }
  toCsvString() {
    return this._value.toCsvString();
  }
  // =========================================================================
  // Merge stuff
  addMergeRef() {
    this._mergeCount++;
  }
  releaseMergeRef() {
    this._mergeCount--;
  }
  get isMerged() {
    return this._mergeCount > 0 || this.type === Cell.Types.Merge;
  }
  merge(master, ignoreStyle) {
    this._value.release();
    this._value = Value.create(Cell.Types.Merge, this, master);
    if (!ignoreStyle) {
      this.style = master.style;
    }
  }
  unmerge() {
    if (this.type === Cell.Types.Merge) {
      this._value.release();
      this._value = Value.create(Cell.Types.Null, this);
      this.style = this._mergeStyle(this._row.style, this._column.style, {});
    }
  }
  isMergedTo(master) {
    if (this._value.type !== Cell.Types.Merge) return false;
    return this._value.isMergedTo(master);
  }
  get master() {
    if (this.type === Cell.Types.Merge) {
      return this._value.master;
    }
    return this;
  }
  get isHyperlink() {
    return this._value.type === Cell.Types.Hyperlink;
  }
  get hyperlink() {
    return this._value.hyperlink;
  }
  // return the value
  get value() {
    return this._value.value;
  }
  // set the value - can be number, string or raw
  set value(v) {
    if (this.type === Cell.Types.Merge) {
      this._value.master.value = v;
      return;
    }
    this._value.release();
    this._value = Value.create(Value.getType(v), this, v);
  }
  get note() {
    return this._comment && this._comment.note;
  }
  set note(note2) {
    this._comment = new Note2(note2);
  }
  get text() {
    return this._value.toString();
  }
  get html() {
    return _$k.escapeHtml(this.text);
  }
  toString() {
    return this.text;
  }
  _upgradeToHyperlink(hyperlink) {
    if (this.type === Cell.Types.String) {
      this._value = Value.create(Cell.Types.Hyperlink, this, {
        text: this._value.value,
        hyperlink
      });
    }
  }
  // =========================================================================
  // Formula stuff
  get formula() {
    return this._value.formula;
  }
  get result() {
    return this._value.result;
  }
  get formulaType() {
    return this._value.formulaType;
  }
  // =========================================================================
  // Name stuff
  get fullAddress() {
    const { worksheet: worksheet2 } = this._row;
    return {
      sheetName: worksheet2.name,
      address: this.address,
      row: this.row,
      col: this.col
    };
  }
  get name() {
    return this.names[0];
  }
  set name(value) {
    this.names = [value];
  }
  get names() {
    return this.workbook.definedNames.getNamesEx(this.fullAddress);
  }
  set names(value) {
    const { definedNames: definedNames2 } = this.workbook;
    definedNames2.removeAllNames(this.fullAddress);
    value.forEach((name) => {
      definedNames2.addEx(this.fullAddress, name);
    });
  }
  addName(name) {
    this.workbook.definedNames.addEx(this.fullAddress, name);
  }
  removeName(name) {
    this.workbook.definedNames.removeEx(this.fullAddress, name);
  }
  removeAllNames() {
    this.workbook.definedNames.removeAllNames(this.fullAddress);
  }
  // =========================================================================
  // Data Validation stuff
  get _dataValidations() {
    return this.worksheet.dataValidations;
  }
  get dataValidation() {
    return this._dataValidations.find(this.address);
  }
  set dataValidation(value) {
    this._dataValidations.add(this.address, value);
  }
  // =========================================================================
  // Model stuff
  get model() {
    const { model } = this._value;
    model.style = this.style;
    if (this._comment) {
      model.comment = this._comment.model;
    }
    return model;
  }
  set model(value) {
    this._value.release();
    this._value = Value.create(value.type, this);
    this._value.model = value;
    if (value.comment) {
      switch (value.comment.type) {
        case "note":
          this._comment = Note2.fromModel(value.comment);
          break;
      }
    }
    if (value.style) {
      this.style = value.style;
    } else {
      this.style = {};
    }
  }
};
Cell$1.Types = Enums$8.ValueType;
class NullValue {
  constructor(cell2) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Null
    };
  }
  get value() {
    return null;
  }
  set value(value) {
  }
  get type() {
    return Cell$1.Types.Null;
  }
  get effectiveType() {
    return Cell$1.Types.Null;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return "";
  }
  release() {
  }
  toString() {
    return "";
  }
}
class NumberValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Number,
      value
    };
  }
  get value() {
    return this.model.value;
  }
  set value(value) {
    this.model.value = value;
  }
  get type() {
    return Cell$1.Types.Number;
  }
  get effectiveType() {
    return Cell$1.Types.Number;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return this.model.value.toString();
  }
  release() {
  }
  toString() {
    return this.model.value.toString();
  }
}
class StringValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.String,
      value
    };
  }
  get value() {
    return this.model.value;
  }
  set value(value) {
    this.model.value = value;
  }
  get type() {
    return Cell$1.Types.String;
  }
  get effectiveType() {
    return Cell$1.Types.String;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return `"${this.model.value.replace(/"/g, '""')}"`;
  }
  release() {
  }
  toString() {
    return this.model.value;
  }
}
class RichTextValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.String,
      value
    };
  }
  get value() {
    return this.model.value;
  }
  set value(value) {
    this.model.value = value;
  }
  toString() {
    return this.model.value.richText.map((t) => t.text).join("");
  }
  get type() {
    return Cell$1.Types.RichText;
  }
  get effectiveType() {
    return Cell$1.Types.RichText;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return `"${this.text.replace(/"/g, '""')}"`;
  }
  release() {
  }
}
class DateValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Date,
      value
    };
  }
  get value() {
    return this.model.value;
  }
  set value(value) {
    this.model.value = value;
  }
  get type() {
    return Cell$1.Types.Date;
  }
  get effectiveType() {
    return Cell$1.Types.Date;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return this.model.value.toISOString();
  }
  release() {
  }
  toString() {
    return this.model.value.toString();
  }
}
class HyperlinkValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Hyperlink,
      text: value ? value.text : void 0,
      hyperlink: value ? value.hyperlink : void 0
    };
    if (value && value.tooltip) {
      this.model.tooltip = value.tooltip;
    }
  }
  get value() {
    const v = {
      text: this.model.text,
      hyperlink: this.model.hyperlink
    };
    if (this.model.tooltip) {
      v.tooltip = this.model.tooltip;
    }
    return v;
  }
  set value(value) {
    this.model = {
      text: value.text,
      hyperlink: value.hyperlink
    };
    if (value.tooltip) {
      this.model.tooltip = value.tooltip;
    }
  }
  get text() {
    return this.model.text;
  }
  set text(value) {
    this.model.text = value;
  }
  /*
    get tooltip() {
      return this.model.tooltip;
    }
  
    set tooltip(value) {
      this.model.tooltip = value;
    } */
  get hyperlink() {
    return this.model.hyperlink;
  }
  set hyperlink(value) {
    this.model.hyperlink = value;
  }
  get type() {
    return Cell$1.Types.Hyperlink;
  }
  get effectiveType() {
    return Cell$1.Types.Hyperlink;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return this.model.hyperlink;
  }
  release() {
  }
  toString() {
    return this.model.text;
  }
}
class MergeValue {
  constructor(cell2, master) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Merge,
      master: master ? master.address : void 0
    };
    this._master = master;
    if (master) {
      master.addMergeRef();
    }
  }
  get value() {
    return this._master.value;
  }
  set value(value) {
    if (value instanceof Cell$1) {
      if (this._master) {
        this._master.releaseMergeRef();
      }
      value.addMergeRef();
      this._master = value;
    } else {
      this._master.value = value;
    }
  }
  isMergedTo(master) {
    return master === this._master;
  }
  get master() {
    return this._master;
  }
  get type() {
    return Cell$1.Types.Merge;
  }
  get effectiveType() {
    return this._master.effectiveType;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return "";
  }
  release() {
    this._master.releaseMergeRef();
  }
  toString() {
    return this.value.toString();
  }
}
class FormulaValue {
  constructor(cell2, value) {
    this.cell = cell2;
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Formula,
      shareType: value ? value.shareType : void 0,
      ref: value ? value.ref : void 0,
      formula: value ? value.formula : void 0,
      sharedFormula: value ? value.sharedFormula : void 0,
      result: value ? value.result : void 0
    };
  }
  _copyModel(model) {
    const copy3 = {};
    const cp = (name) => {
      const value = model[name];
      if (value) {
        copy3[name] = value;
      }
    };
    cp("formula");
    cp("result");
    cp("ref");
    cp("shareType");
    cp("sharedFormula");
    return copy3;
  }
  get value() {
    return this._copyModel(this.model);
  }
  set value(value) {
    this.model = this._copyModel(value);
  }
  validate(value) {
    switch (Value.getType(value)) {
      case Cell$1.Types.Null:
      case Cell$1.Types.String:
      case Cell$1.Types.Number:
      case Cell$1.Types.Date:
        break;
      case Cell$1.Types.Hyperlink:
      case Cell$1.Types.Formula:
      default:
        throw new Error("Cannot process that type of result value");
    }
  }
  get dependencies() {
    const ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g);
    const cells = this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g);
    return {
      ranges,
      cells
    };
  }
  get formula() {
    return this.model.formula || this._getTranslatedFormula();
  }
  set formula(value) {
    this.model.formula = value;
  }
  get formulaType() {
    if (this.model.formula) {
      return Enums$8.FormulaType.Master;
    }
    if (this.model.sharedFormula) {
      return Enums$8.FormulaType.Shared;
    }
    return Enums$8.FormulaType.None;
  }
  get result() {
    return this.model.result;
  }
  set result(value) {
    this.model.result = value;
  }
  get type() {
    return Cell$1.Types.Formula;
  }
  get effectiveType() {
    const v = this.model.result;
    if (v === null || v === void 0) {
      return Enums$8.ValueType.Null;
    }
    if (v instanceof String || typeof v === "string") {
      return Enums$8.ValueType.String;
    }
    if (typeof v === "number") {
      return Enums$8.ValueType.Number;
    }
    if (v instanceof Date) {
      return Enums$8.ValueType.Date;
    }
    if (v.text && v.hyperlink) {
      return Enums$8.ValueType.Hyperlink;
    }
    if (v.formula) {
      return Enums$8.ValueType.Formula;
    }
    return Enums$8.ValueType.Null;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  _getTranslatedFormula() {
    if (!this._translatedFormula && this.model.sharedFormula) {
      const { worksheet: worksheet2 } = this.cell;
      const master = worksheet2.findCell(this.model.sharedFormula);
      this._translatedFormula = master && slideFormula(master.formula, master.address, this.model.address);
    }
    return this._translatedFormula;
  }
  toCsvString() {
    return `${this.model.result || ""}`;
  }
  release() {
  }
  toString() {
    return this.model.result ? this.model.result.toString() : "";
  }
}
class SharedStringValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.SharedString,
      value
    };
  }
  get value() {
    return this.model.value;
  }
  set value(value) {
    this.model.value = value;
  }
  get type() {
    return Cell$1.Types.SharedString;
  }
  get effectiveType() {
    return Cell$1.Types.SharedString;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return this.model.value.toString();
  }
  release() {
  }
  toString() {
    return this.model.value.toString();
  }
}
class BooleanValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Boolean,
      value
    };
  }
  get value() {
    return this.model.value;
  }
  set value(value) {
    this.model.value = value;
  }
  get type() {
    return Cell$1.Types.Boolean;
  }
  get effectiveType() {
    return Cell$1.Types.Boolean;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return this.model.value ? 1 : 0;
  }
  release() {
  }
  toString() {
    return this.model.value.toString();
  }
}
class ErrorValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.Error,
      value
    };
  }
  get value() {
    return this.model.value;
  }
  set value(value) {
    this.model.value = value;
  }
  get type() {
    return Cell$1.Types.Error;
  }
  get effectiveType() {
    return Cell$1.Types.Error;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return this.toString();
  }
  release() {
  }
  toString() {
    return this.model.value.error.toString();
  }
}
class JSONValue {
  constructor(cell2, value) {
    this.model = {
      address: cell2.address,
      type: Cell$1.Types.String,
      value: JSON.stringify(value),
      rawValue: value
    };
  }
  get value() {
    return this.model.rawValue;
  }
  set value(value) {
    this.model.rawValue = value;
    this.model.value = JSON.stringify(value);
  }
  get type() {
    return Cell$1.Types.String;
  }
  get effectiveType() {
    return Cell$1.Types.String;
  }
  get address() {
    return this.model.address;
  }
  set address(value) {
    this.model.address = value;
  }
  toCsvString() {
    return this.model.value;
  }
  release() {
  }
  toString() {
    return this.model.value;
  }
}
const Value = {
  getType(value) {
    if (value === null || value === void 0) {
      return Cell$1.Types.Null;
    }
    if (value instanceof String || typeof value === "string") {
      return Cell$1.Types.String;
    }
    if (typeof value === "number") {
      return Cell$1.Types.Number;
    }
    if (typeof value === "boolean") {
      return Cell$1.Types.Boolean;
    }
    if (value instanceof Date) {
      return Cell$1.Types.Date;
    }
    if (value.text && value.hyperlink) {
      return Cell$1.Types.Hyperlink;
    }
    if (value.formula || value.sharedFormula) {
      return Cell$1.Types.Formula;
    }
    if (value.richText) {
      return Cell$1.Types.RichText;
    }
    if (value.sharedString) {
      return Cell$1.Types.SharedString;
    }
    if (value.error) {
      return Cell$1.Types.Error;
    }
    return Cell$1.Types.JSON;
  },
  // map valueType to constructor
  types: [
    { t: Cell$1.Types.Null, f: NullValue },
    { t: Cell$1.Types.Number, f: NumberValue },
    { t: Cell$1.Types.String, f: StringValue },
    { t: Cell$1.Types.Date, f: DateValue },
    { t: Cell$1.Types.Hyperlink, f: HyperlinkValue },
    { t: Cell$1.Types.Formula, f: FormulaValue },
    { t: Cell$1.Types.Merge, f: MergeValue },
    { t: Cell$1.Types.JSON, f: JSONValue },
    { t: Cell$1.Types.SharedString, f: SharedStringValue },
    { t: Cell$1.Types.RichText, f: RichTextValue },
    { t: Cell$1.Types.Boolean, f: BooleanValue },
    { t: Cell$1.Types.Error, f: ErrorValue }
  ].reduce((p, t) => {
    p[t.t] = t.f;
    return p;
  }, []),
  create(type, cell2, value) {
    const T = this.types[type];
    if (!T) {
      throw new Error(`Could not create Value of type ${type}`);
    }
    return new T(cell2, value);
  }
};
var cell = Cell$1;
const _$j = underDash;
const Enums$7 = enums;
const colCache$i = colCache_1;
const Cell2 = cell;
let Row$3 = class Row {
  constructor(worksheet2, number) {
    this._worksheet = worksheet2;
    this._number = number;
    this._cells = [];
    this.style = {};
    this.outlineLevel = 0;
  }
  // return the row number
  get number() {
    return this._number;
  }
  get worksheet() {
    return this._worksheet;
  }
  // Inform Streaming Writer that this row (and all rows before it) are complete
  // and ready to write. Has no effect on Worksheet document
  commit() {
    this._worksheet._commitRow(this);
  }
  // helps GC by breaking cyclic references
  destroy() {
    delete this._worksheet;
    delete this._cells;
    delete this.style;
  }
  findCell(colNumber) {
    return this._cells[colNumber - 1];
  }
  // given {address, row, col}, find or create new cell
  getCellEx(address) {
    let cell2 = this._cells[address.col - 1];
    if (!cell2) {
      const column2 = this._worksheet.getColumn(address.col);
      cell2 = new Cell2(this, column2, address.address);
      this._cells[address.col - 1] = cell2;
    }
    return cell2;
  }
  // get cell by key, letter or column number
  getCell(col) {
    if (typeof col === "string") {
      const column2 = this._worksheet.getColumnKey(col);
      if (column2) {
        col = column2.number;
      } else {
        col = colCache$i.l2n(col);
      }
    }
    return this._cells[col - 1] || this.getCellEx({
      address: colCache$i.encodeAddress(this._number, col),
      row: this._number,
      col
    });
  }
  // remove cell(s) and shift all higher cells down by count
  splice(start, count, ...inserts) {
    const nKeep = start + count;
    const nExpand = inserts.length - count;
    const nEnd = this._cells.length;
    let i;
    let cSrc;
    let cDst;
    if (nExpand < 0) {
      for (i = start + inserts.length; i <= nEnd; i++) {
        cDst = this._cells[i - 1];
        cSrc = this._cells[i - nExpand - 1];
        if (cSrc) {
          cDst = this.getCell(i);
          cDst.value = cSrc.value;
          cDst.style = cSrc.style;
          cDst._comment = cSrc._comment;
        } else if (cDst) {
          cDst.value = null;
          cDst.style = {};
          cDst._comment = void 0;
        }
      }
    } else if (nExpand > 0) {
      for (i = nEnd; i >= nKeep; i--) {
        cSrc = this._cells[i - 1];
        if (cSrc) {
          cDst = this.getCell(i + nExpand);
          cDst.value = cSrc.value;
          cDst.style = cSrc.style;
          cDst._comment = cSrc._comment;
        } else {
          this._cells[i + nExpand - 1] = void 0;
        }
      }
    }
    for (i = 0; i < inserts.length; i++) {
      cDst = this.getCell(start + i);
      cDst.value = inserts[i];
      cDst.style = {};
      cDst._comment = void 0;
    }
  }
  // Iterate over all non-null cells in this row
  eachCell(options, iteratee) {
    if (!iteratee) {
      iteratee = options;
      options = null;
    }
    if (options && options.includeEmpty) {
      const n = this._cells.length;
      for (let i = 1; i <= n; i++) {
        iteratee(this.getCell(i), i);
      }
    } else {
      this._cells.forEach((cell2, index2) => {
        if (cell2 && cell2.type !== Enums$7.ValueType.Null) {
          iteratee(cell2, index2 + 1);
        }
      });
    }
  }
  // ===========================================================================
  // Page Breaks
  addPageBreak(lft, rght) {
    const ws = this._worksheet;
    const left = Math.max(0, lft - 1) || 0;
    const right = Math.max(0, rght - 1) || 16838;
    const pb = {
      id: this._number,
      max: right,
      man: 1
    };
    if (left) pb.min = left;
    ws.rowBreaks.push(pb);
  }
  // return a sparse array of cell values
  get values() {
    const values = [];
    this._cells.forEach((cell2) => {
      if (cell2 && cell2.type !== Enums$7.ValueType.Null) {
        values[cell2.col] = cell2.value;
      }
    });
    return values;
  }
  // set the values by contiguous or sparse array, or by key'd object literal
  set values(value) {
    this._cells = [];
    if (!value) ;
    else if (value instanceof Array) {
      let offset = 0;
      if (value.hasOwnProperty("0")) {
        offset = 1;
      }
      value.forEach((item, index2) => {
        if (item !== void 0) {
          this.getCellEx({
            address: colCache$i.encodeAddress(this._number, index2 + offset),
            row: this._number,
            col: index2 + offset
          }).value = item;
        }
      });
    } else {
      this._worksheet.eachColumnKey((column2, key) => {
        if (value[key] !== void 0) {
          this.getCellEx({
            address: colCache$i.encodeAddress(this._number, column2.number),
            row: this._number,
            col: column2.number
          }).value = value[key];
        }
      });
    }
  }
  // returns true if the row includes at least one cell with a value
  get hasValues() {
    return _$j.some(this._cells, (cell2) => cell2 && cell2.type !== Enums$7.ValueType.Null);
  }
  get cellCount() {
    return this._cells.length;
  }
  get actualCellCount() {
    let count = 0;
    this.eachCell(() => {
      count++;
    });
    return count;
  }
  // get the min and max column number for the non-null cells in this row or null
  get dimensions() {
    let min = 0;
    let max = 0;
    this._cells.forEach((cell2) => {
      if (cell2 && cell2.type !== Enums$7.ValueType.Null) {
        if (!min || min > cell2.col) {
          min = cell2.col;
        }
        if (max < cell2.col) {
          max = cell2.col;
        }
      }
    });
    return min > 0 ? {
      min,
      max
    } : null;
  }
  // =========================================================================
  // styles
  _applyStyle(name, value) {
    this.style[name] = value;
    this._cells.forEach((cell2) => {
      if (cell2) {
        cell2[name] = value;
      }
    });
    return value;
  }
  get numFmt() {
    return this.style.numFmt;
  }
  set numFmt(value) {
    this._applyStyle("numFmt", value);
  }
  get font() {
    return this.style.font;
  }
  set font(value) {
    this._applyStyle("font", value);
  }
  get alignment() {
    return this.style.alignment;
  }
  set alignment(value) {
    this._applyStyle("alignment", value);
  }
  get protection() {
    return this.style.protection;
  }
  set protection(value) {
    this._applyStyle("protection", value);
  }
  get border() {
    return this.style.border;
  }
  set border(value) {
    this._applyStyle("border", value);
  }
  get fill() {
    return this.style.fill;
  }
  set fill(value) {
    this._applyStyle("fill", value);
  }
  get hidden() {
    return !!this._hidden;
  }
  set hidden(value) {
    this._hidden = value;
  }
  get outlineLevel() {
    return this._outlineLevel || 0;
  }
  set outlineLevel(value) {
    this._outlineLevel = value;
  }
  get collapsed() {
    return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
  }
  // =========================================================================
  get model() {
    const cells = [];
    let min = 0;
    let max = 0;
    this._cells.forEach((cell2) => {
      if (cell2) {
        const cellModel = cell2.model;
        if (cellModel) {
          if (!min || min > cell2.col) {
            min = cell2.col;
          }
          if (max < cell2.col) {
            max = cell2.col;
          }
          cells.push(cellModel);
        }
      }
    });
    return this.height || cells.length ? {
      cells,
      number: this.number,
      min,
      max,
      height: this.height,
      style: this.style,
      hidden: this.hidden,
      outlineLevel: this.outlineLevel,
      collapsed: this.collapsed
    } : null;
  }
  set model(value) {
    if (value.number !== this._number) {
      throw new Error("Invalid row number in model");
    }
    this._cells = [];
    let previousAddress;
    value.cells.forEach((cellModel) => {
      switch (cellModel.type) {
        case Cell2.Types.Merge:
          break;
        default: {
          let address;
          if (cellModel.address) {
            address = colCache$i.decodeAddress(cellModel.address);
          } else if (previousAddress) {
            const { row: row2 } = previousAddress;
            const col = previousAddress.col + 1;
            address = {
              row: row2,
              col,
              address: colCache$i.encodeAddress(row2, col),
              $col$row: `$${colCache$i.n2l(col)}$${row2}`
            };
          }
          previousAddress = address;
          const cell2 = this.getCellEx(address);
          cell2.model = cellModel;
          break;
        }
      }
    });
    if (value.height) {
      this.height = value.height;
    } else {
      delete this.height;
    }
    this.hidden = value.hidden;
    this.outlineLevel = value.outlineLevel || 0;
    this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};
  }
};
var row = Row$3;
const _$i = underDash;
const Enums$6 = enums;
const colCache$h = colCache_1;
const DEFAULT_COLUMN_WIDTH = 9;
let Column$4 = class Column {
  constructor(worksheet2, number, defn) {
    this._worksheet = worksheet2;
    this._number = number;
    if (defn !== false) {
      this.defn = defn;
    }
  }
  get number() {
    return this._number;
  }
  get worksheet() {
    return this._worksheet;
  }
  get letter() {
    return colCache$h.n2l(this._number);
  }
  get isCustomWidth() {
    return this.width !== void 0 && this.width !== DEFAULT_COLUMN_WIDTH;
  }
  get defn() {
    return {
      header: this._header,
      key: this.key,
      width: this.width,
      style: this.style,
      hidden: this.hidden,
      outlineLevel: this.outlineLevel
    };
  }
  set defn(value) {
    if (value) {
      this.key = value.key;
      this.width = value.width !== void 0 ? value.width : DEFAULT_COLUMN_WIDTH;
      this.outlineLevel = value.outlineLevel;
      if (value.style) {
        this.style = value.style;
      } else {
        this.style = {};
      }
      this.header = value.header;
      this._hidden = !!value.hidden;
    } else {
      delete this._header;
      delete this._key;
      delete this.width;
      this.style = {};
      this.outlineLevel = 0;
    }
  }
  get headers() {
    return this._header && this._header instanceof Array ? this._header : [this._header];
  }
  get header() {
    return this._header;
  }
  set header(value) {
    if (value !== void 0) {
      this._header = value;
      this.headers.forEach((text, index2) => {
        this._worksheet.getCell(index2 + 1, this.number).value = text;
      });
    } else {
      this._header = void 0;
    }
  }
  get key() {
    return this._key;
  }
  set key(value) {
    const column2 = this._key && this._worksheet.getColumnKey(this._key);
    if (column2 === this) {
      this._worksheet.deleteColumnKey(this._key);
    }
    this._key = value;
    if (value) {
      this._worksheet.setColumnKey(this._key, this);
    }
  }
  get hidden() {
    return !!this._hidden;
  }
  set hidden(value) {
    this._hidden = value;
  }
  get outlineLevel() {
    return this._outlineLevel || 0;
  }
  set outlineLevel(value) {
    this._outlineLevel = value;
  }
  get collapsed() {
    return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
  }
  toString() {
    return JSON.stringify({
      key: this.key,
      width: this.width,
      headers: this.headers.length ? this.headers : void 0
    });
  }
  equivalentTo(other) {
    return this.width === other.width && this.hidden === other.hidden && this.outlineLevel === other.outlineLevel && _$i.isEqual(this.style, other.style);
  }
  get isDefault() {
    if (this.isCustomWidth) {
      return false;
    }
    if (this.hidden) {
      return false;
    }
    if (this.outlineLevel) {
      return false;
    }
    const s = this.style;
    if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {
      return false;
    }
    return true;
  }
  get headerCount() {
    return this.headers.length;
  }
  eachCell(options, iteratee) {
    const colNumber = this.number;
    if (!iteratee) {
      iteratee = options;
      options = null;
    }
    this._worksheet.eachRow(options, (row2, rowNumber) => {
      iteratee(row2.getCell(colNumber), rowNumber);
    });
  }
  get values() {
    const v = [];
    this.eachCell((cell2, rowNumber) => {
      if (cell2 && cell2.type !== Enums$6.ValueType.Null) {
        v[rowNumber] = cell2.value;
      }
    });
    return v;
  }
  set values(v) {
    if (!v) {
      return;
    }
    const colNumber = this.number;
    let offset = 0;
    if (v.hasOwnProperty("0")) {
      offset = 1;
    }
    v.forEach((value, index2) => {
      this._worksheet.getCell(index2 + offset, colNumber).value = value;
    });
  }
  // =========================================================================
  // styles
  _applyStyle(name, value) {
    this.style[name] = value;
    this.eachCell((cell2) => {
      cell2[name] = value;
    });
    return value;
  }
  get numFmt() {
    return this.style.numFmt;
  }
  set numFmt(value) {
    this._applyStyle("numFmt", value);
  }
  get font() {
    return this.style.font;
  }
  set font(value) {
    this._applyStyle("font", value);
  }
  get alignment() {
    return this.style.alignment;
  }
  set alignment(value) {
    this._applyStyle("alignment", value);
  }
  get protection() {
    return this.style.protection;
  }
  set protection(value) {
    this._applyStyle("protection", value);
  }
  get border() {
    return this.style.border;
  }
  set border(value) {
    this._applyStyle("border", value);
  }
  get fill() {
    return this.style.fill;
  }
  set fill(value) {
    this._applyStyle("fill", value);
  }
  // =============================================================================
  // static functions
  static toModel(columns) {
    const cols = [];
    let col = null;
    if (columns) {
      columns.forEach((column2, index2) => {
        if (column2.isDefault) {
          if (col) {
            col = null;
          }
        } else if (!col || !column2.equivalentTo(col)) {
          col = {
            min: index2 + 1,
            max: index2 + 1,
            width: column2.width !== void 0 ? column2.width : DEFAULT_COLUMN_WIDTH,
            style: column2.style,
            isCustomWidth: column2.isCustomWidth,
            hidden: column2.hidden,
            outlineLevel: column2.outlineLevel,
            collapsed: column2.collapsed
          };
          cols.push(col);
        } else {
          col.max = index2 + 1;
        }
      });
    }
    return cols.length ? cols : void 0;
  }
  static fromModel(worksheet2, cols) {
    cols = cols || [];
    const columns = [];
    let count = 1;
    let index2 = 0;
    cols = cols.sort(function(pre, next) {
      return pre.min - next.min;
    });
    while (index2 < cols.length) {
      const col = cols[index2++];
      while (count < col.min) {
        columns.push(new Column(worksheet2, count++));
      }
      while (count <= col.max) {
        columns.push(new Column(worksheet2, count++, col));
      }
    }
    return columns.length ? columns : null;
  }
};
var column$1 = Column$4;
const colCache$g = colCache_1;
let Anchor$1 = class Anchor {
  constructor(worksheet2, address, offset = 0) {
    this.worksheet = worksheet2;
    if (!address) {
      this.nativeCol = 0;
      this.nativeColOff = 0;
      this.nativeRow = 0;
      this.nativeRowOff = 0;
    } else if (typeof address === "string") {
      const decoded = colCache$g.decodeAddress(address);
      this.nativeCol = decoded.col + offset;
      this.nativeColOff = 0;
      this.nativeRow = decoded.row + offset;
      this.nativeRowOff = 0;
    } else if (address.nativeCol !== void 0) {
      this.nativeCol = address.nativeCol || 0;
      this.nativeColOff = address.nativeColOff || 0;
      this.nativeRow = address.nativeRow || 0;
      this.nativeRowOff = address.nativeRowOff || 0;
    } else if (address.col !== void 0) {
      this.col = address.col + offset;
      this.row = address.row + offset;
    } else {
      this.nativeCol = 0;
      this.nativeColOff = 0;
      this.nativeRow = 0;
      this.nativeRowOff = 0;
    }
  }
  static asInstance(model) {
    return model instanceof Anchor || model == null ? model : new Anchor(model);
  }
  get col() {
    return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
  }
  set col(v) {
    this.nativeCol = Math.floor(v);
    this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
  }
  get row() {
    return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
  }
  set row(v) {
    this.nativeRow = Math.floor(v);
    this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
  }
  get colWidth() {
    return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 1e4) : 64e4;
  }
  get rowHeight() {
    return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 1e4) : 18e4;
  }
  get model() {
    return {
      nativeCol: this.nativeCol,
      nativeColOff: this.nativeColOff,
      nativeRow: this.nativeRow,
      nativeRowOff: this.nativeRowOff
    };
  }
  set model(value) {
    this.nativeCol = value.nativeCol;
    this.nativeColOff = value.nativeColOff;
    this.nativeRow = value.nativeRow;
    this.nativeRowOff = value.nativeRowOff;
  }
};
var anchor = Anchor$1;
const colCache$f = colCache_1;
const Anchor2 = anchor;
let Image$1 = class Image {
  constructor(worksheet2, model) {
    this.worksheet = worksheet2;
    this.model = model;
  }
  get model() {
    switch (this.type) {
      case "background":
        return {
          type: this.type,
          imageId: this.imageId
        };
      case "image":
        return {
          type: this.type,
          imageId: this.imageId,
          hyperlinks: this.range.hyperlinks,
          range: {
            tl: this.range.tl.model,
            br: this.range.br && this.range.br.model,
            ext: this.range.ext,
            editAs: this.range.editAs
          }
        };
      default:
        throw new Error("Invalid Image Type");
    }
  }
  set model({ type, imageId, range: range2, hyperlinks }) {
    this.type = type;
    this.imageId = imageId;
    if (type === "image") {
      if (typeof range2 === "string") {
        const decoded = colCache$f.decode(range2);
        this.range = {
          tl: new Anchor2(this.worksheet, { col: decoded.left, row: decoded.top }, -1),
          br: new Anchor2(this.worksheet, { col: decoded.right, row: decoded.bottom }, 0),
          editAs: "oneCell"
        };
      } else {
        this.range = {
          tl: new Anchor2(this.worksheet, range2.tl, 0),
          br: range2.br && new Anchor2(this.worksheet, range2.br, 0),
          ext: range2.ext,
          editAs: range2.editAs,
          hyperlinks: hyperlinks || range2.hyperlinks
        };
      }
    }
  }
};
var image = Image$1;
const colCache$e = colCache_1;
let Column$3 = class Column2 {
  // wrapper around column model, allowing access and manipulation
  constructor(table2, column2, index2) {
    this.table = table2;
    this.column = column2;
    this.index = index2;
  }
  _set(name, value) {
    this.table.cacheState();
    this.column[name] = value;
  }
  /* eslint-disable lines-between-class-members */
  get name() {
    return this.column.name;
  }
  set name(value) {
    this._set("name", value);
  }
  get filterButton() {
    return this.column.filterButton;
  }
  set filterButton(value) {
    this.column.filterButton = value;
  }
  get style() {
    return this.column.style;
  }
  set style(value) {
    this.column.style = value;
  }
  get totalsRowLabel() {
    return this.column.totalsRowLabel;
  }
  set totalsRowLabel(value) {
    this._set("totalsRowLabel", value);
  }
  get totalsRowFunction() {
    return this.column.totalsRowFunction;
  }
  set totalsRowFunction(value) {
    this._set("totalsRowFunction", value);
  }
  get totalsRowResult() {
    return this.column.totalsRowResult;
  }
  set totalsRowResult(value) {
    this._set("totalsRowResult", value);
  }
  get totalsRowFormula() {
    return this.column.totalsRowFormula;
  }
  set totalsRowFormula(value) {
    this._set("totalsRowFormula", value);
  }
  /* eslint-enable lines-between-class-members */
};
let Table$1 = class Table {
  constructor(worksheet2, table2) {
    this.worksheet = worksheet2;
    if (table2) {
      this.table = table2;
      this.validate();
      this.store();
    }
  }
  getFormula(column2) {
    switch (column2.totalsRowFunction) {
      case "none":
        return null;
      case "average":
        return `SUBTOTAL(101,${this.table.name}[${column2.name}])`;
      case "countNums":
        return `SUBTOTAL(102,${this.table.name}[${column2.name}])`;
      case "count":
        return `SUBTOTAL(103,${this.table.name}[${column2.name}])`;
      case "max":
        return `SUBTOTAL(104,${this.table.name}[${column2.name}])`;
      case "min":
        return `SUBTOTAL(105,${this.table.name}[${column2.name}])`;
      case "stdDev":
        return `SUBTOTAL(106,${this.table.name}[${column2.name}])`;
      case "var":
        return `SUBTOTAL(107,${this.table.name}[${column2.name}])`;
      case "sum":
        return `SUBTOTAL(109,${this.table.name}[${column2.name}])`;
      case "custom":
        return column2.totalsRowFormula;
      default:
        throw new Error(`Invalid Totals Row Function: ${column2.totalsRowFunction}`);
    }
  }
  get width() {
    return this.table.columns.length;
  }
  get height() {
    return this.table.rows.length;
  }
  get filterHeight() {
    return this.height + (this.table.headerRow ? 1 : 0);
  }
  get tableHeight() {
    return this.filterHeight + (this.table.totalsRow ? 1 : 0);
  }
  validate() {
    const { table: table2 } = this;
    const assign2 = (o, name, dflt) => {
      if (o[name] === void 0) {
        o[name] = dflt;
      }
    };
    assign2(table2, "headerRow", true);
    assign2(table2, "totalsRow", false);
    assign2(table2, "style", {});
    assign2(table2.style, "theme", "TableStyleMedium2");
    assign2(table2.style, "showFirstColumn", false);
    assign2(table2.style, "showLastColumn", false);
    assign2(table2.style, "showRowStripes", false);
    assign2(table2.style, "showColumnStripes", false);
    const assert2 = (test, message) => {
      if (!test) {
        throw new Error(message);
      }
    };
    assert2(table2.ref, "Table must have ref");
    assert2(table2.columns, "Table must have column definitions");
    assert2(table2.rows, "Table must have row definitions");
    table2.tl = colCache$e.decodeAddress(table2.ref);
    const { row: row2, col } = table2.tl;
    assert2(row2 > 0, "Table must be on valid row");
    assert2(col > 0, "Table must be on valid col");
    const { width, filterHeight, tableHeight } = this;
    table2.autoFilterRef = colCache$e.encode(row2, col, row2 + filterHeight - 1, col + width - 1);
    table2.tableRef = colCache$e.encode(row2, col, row2 + tableHeight - 1, col + width - 1);
    table2.columns.forEach((column2, i) => {
      assert2(column2.name, `Column ${i} must have a name`);
      if (i === 0) {
        assign2(column2, "totalsRowLabel", "Total");
      } else {
        assign2(column2, "totalsRowFunction", "none");
        column2.totalsRowFormula = this.getFormula(column2);
      }
    });
  }
  store() {
    const assignStyle = (cell2, style) => {
      if (style) {
        Object.keys(style).forEach((key) => {
          cell2[key] = style[key];
        });
      }
    };
    const { worksheet: worksheet2, table: table2 } = this;
    const { row: row2, col } = table2.tl;
    let count = 0;
    if (table2.headerRow) {
      const r = worksheet2.getRow(row2 + count++);
      table2.columns.forEach((column2, j) => {
        const { style, name } = column2;
        const cell2 = r.getCell(col + j);
        cell2.value = name;
        assignStyle(cell2, style);
      });
    }
    table2.rows.forEach((data) => {
      const r = worksheet2.getRow(row2 + count++);
      data.forEach((value, j) => {
        const cell2 = r.getCell(col + j);
        cell2.value = value;
        assignStyle(cell2, table2.columns[j].style);
      });
    });
    if (table2.totalsRow) {
      const r = worksheet2.getRow(row2 + count++);
      table2.columns.forEach((column2, j) => {
        const cell2 = r.getCell(col + j);
        if (j === 0) {
          cell2.value = column2.totalsRowLabel;
        } else {
          const formula = this.getFormula(column2);
          if (formula) {
            cell2.value = {
              formula: column2.totalsRowFormula,
              result: column2.totalsRowResult
            };
          } else {
            cell2.value = null;
          }
        }
        assignStyle(cell2, column2.style);
      });
    }
  }
  load(worksheet2) {
    const { table: table2 } = this;
    const { row: row2, col } = table2.tl;
    let count = 0;
    if (table2.headerRow) {
      const r = worksheet2.getRow(row2 + count++);
      table2.columns.forEach((column2, j) => {
        const cell2 = r.getCell(col + j);
        cell2.value = column2.name;
      });
    }
    table2.rows.forEach((data) => {
      const r = worksheet2.getRow(row2 + count++);
      data.forEach((value, j) => {
        const cell2 = r.getCell(col + j);
        cell2.value = value;
      });
    });
    if (table2.totalsRow) {
      const r = worksheet2.getRow(row2 + count++);
      table2.columns.forEach((column2, j) => {
        const cell2 = r.getCell(col + j);
        if (j === 0) {
          cell2.value = column2.totalsRowLabel;
        } else {
          const formula = this.getFormula(column2);
          if (formula) {
            cell2.value = {
              formula: column2.totalsRowFormula,
              result: column2.totalsRowResult
            };
          }
        }
      });
    }
  }
  get model() {
    return this.table;
  }
  set model(value) {
    this.table = value;
  }
  // ================================================================
  // TODO: Mutating methods
  cacheState() {
    if (!this._cache) {
      this._cache = {
        ref: this.ref,
        width: this.width,
        tableHeight: this.tableHeight
      };
    }
  }
  commit() {
    if (!this._cache) {
      return;
    }
    this.validate();
    const ref = colCache$e.decodeAddress(this._cache.ref);
    if (this.ref !== this._cache.ref) {
      for (let i = 0; i < this._cache.tableHeight; i++) {
        const row2 = this.worksheet.getRow(ref.row + i);
        for (let j = 0; j < this._cache.width; j++) {
          const cell2 = row2.getCell(ref.col + j);
          cell2.value = null;
        }
      }
    } else {
      for (let i = this.tableHeight; i < this._cache.tableHeight; i++) {
        const row2 = this.worksheet.getRow(ref.row + i);
        for (let j = 0; j < this._cache.width; j++) {
          const cell2 = row2.getCell(ref.col + j);
          cell2.value = null;
        }
      }
      for (let i = 0; i < this.tableHeight; i++) {
        const row2 = this.worksheet.getRow(ref.row + i);
        for (let j = this.width; j < this._cache.width; j++) {
          const cell2 = row2.getCell(ref.col + j);
          cell2.value = null;
        }
      }
    }
    this.store();
  }
  addRow(values, rowNumber) {
    this.cacheState();
    if (rowNumber === void 0) {
      this.table.rows.push(values);
    } else {
      this.table.rows.splice(rowNumber, 0, values);
    }
  }
  removeRows(rowIndex, count = 1) {
    this.cacheState();
    this.table.rows.splice(rowIndex, count);
  }
  getColumn(colIndex) {
    const column2 = this.table.columns[colIndex];
    return new Column$3(this, column2, colIndex);
  }
  addColumn(column2, values, colIndex) {
    this.cacheState();
    if (colIndex === void 0) {
      this.table.columns.push(column2);
      this.table.rows.forEach((row2, i) => {
        row2.push(values[i]);
      });
    } else {
      this.table.columns.splice(colIndex, 0, column2);
      this.table.rows.forEach((row2, i) => {
        row2.splice(colIndex, 0, values[i]);
      });
    }
  }
  removeColumns(colIndex, count = 1) {
    this.cacheState();
    this.table.columns.splice(colIndex, count);
    this.table.rows.forEach((row2) => {
      row2.splice(colIndex, count);
    });
  }
  _assign(target, prop, value) {
    this.cacheState();
    target[prop] = value;
  }
  /* eslint-disable lines-between-class-members */
  get ref() {
    return this.table.ref;
  }
  set ref(value) {
    this._assign(this.table, "ref", value);
  }
  get name() {
    return this.table.name;
  }
  set name(value) {
    this.table.name = value;
  }
  get displayName() {
    return this.table.displyName || this.table.name;
  }
  set displayNamename(value) {
    this.table.displayName = value;
  }
  get headerRow() {
    return this.table.headerRow;
  }
  set headerRow(value) {
    this._assign(this.table, "headerRow", value);
  }
  get totalsRow() {
    return this.table.totalsRow;
  }
  set totalsRow(value) {
    this._assign(this.table, "totalsRow", value);
  }
  get theme() {
    return this.table.style.name;
  }
  set theme(value) {
    this.table.style.name = value;
  }
  get showFirstColumn() {
    return this.table.style.showFirstColumn;
  }
  set showFirstColumn(value) {
    this.table.style.showFirstColumn = value;
  }
  get showLastColumn() {
    return this.table.style.showLastColumn;
  }
  set showLastColumn(value) {
    this.table.style.showLastColumn = value;
  }
  get showRowStripes() {
    return this.table.style.showRowStripes;
  }
  set showRowStripes(value) {
    this.table.style.showRowStripes = value;
  }
  get showColumnStripes() {
    return this.table.style.showColumnStripes;
  }
  set showColumnStripes(value) {
    this.table.style.showColumnStripes = value;
  }
  /* eslint-enable lines-between-class-members */
};
var table$1 = Table$1;
let DataValidations$2 = class DataValidations {
  constructor(model) {
    this.model = model || {};
  }
  add(address, validation2) {
    return this.model[address] = validation2;
  }
  find(address) {
    return this.model[address];
  }
  remove(address) {
    this.model[address] = void 0;
  }
};
var dataValidations = DataValidations$2;
const crypto = crypto$1;
const Encryptor$2 = {
  /**
   * Calculate a hash of the concatenated buffers with the given algorithm.
   * @param {string} algorithm - The hash algorithm.
   * @returns {Buffer} The hash
   */
  hash(algorithm, ...buffers2) {
    const hash = crypto.createHash(algorithm);
    hash.update(Buffer.concat(buffers2));
    return hash.digest();
  },
  /**
   * Convert a password into an encryption key
   * @param {string} password - The password
   * @param {string} hashAlgorithm - The hash algoritm
   * @param {string} saltValue - The salt value
   * @param {number} spinCount - The spin count
   * @param {number} keyBits - The length of the key in bits
   * @param {Buffer} blockKey - The block key
   * @returns {Buffer} The encryption key
   */
  convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {
    hashAlgorithm = hashAlgorithm.toLowerCase();
    const hashes = crypto.getHashes();
    if (hashes.indexOf(hashAlgorithm) < 0) {
      throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);
    }
    const passwordBuffer = Buffer.from(password, "utf16le");
    let key = this.hash(hashAlgorithm, Buffer.from(saltValue, "base64"), passwordBuffer);
    for (let i = 0; i < spinCount; i++) {
      const iterator = Buffer.alloc(4);
      iterator.writeUInt32LE(i, 0);
      key = this.hash(hashAlgorithm, key, iterator);
    }
    return key.toString("base64");
  },
  /**
   * Generates cryptographically strong pseudo-random data.
   * @param size The size argument is a number indicating the number of bytes to generate.
   */
  randomBytes(size) {
    return crypto.randomBytes(size);
  }
};
var encryptor = Encryptor$2;
var copyStyle$2 = {};
const oneDepthCopy = (obj, nestKeys) => ({
  ...obj,
  ...nestKeys.reduce((memo, key) => {
    if (obj[key]) memo[key] = { ...obj[key] };
    return memo;
  }, {})
});
const setIfExists = (src2, dst, key, nestKeys = []) => {
  if (src2[key]) dst[key] = oneDepthCopy(src2[key], nestKeys);
};
const isEmptyObj = (obj) => Object.keys(obj).length === 0;
const copyStyle$1 = (style) => {
  if (!style) return style;
  if (isEmptyObj(style)) return {};
  const copied = { ...style };
  setIfExists(style, copied, "font", ["color"]);
  setIfExists(style, copied, "alignment");
  setIfExists(style, copied, "protection");
  if (style.border) {
    setIfExists(style, copied, "border");
    setIfExists(style.border, copied.border, "top", ["color"]);
    setIfExists(style.border, copied.border, "left", ["color"]);
    setIfExists(style.border, copied.border, "bottom", ["color"]);
    setIfExists(style.border, copied.border, "right", ["color"]);
    setIfExists(style.border, copied.border, "diagonal", ["color"]);
  }
  if (style.fill) {
    setIfExists(style, copied, "fill", ["fgColor", "bgColor", "center"]);
    if (style.fill.stops) {
      copied.fill.stops = style.fill.stops.map((s) => oneDepthCopy(s, ["color"]));
    }
  }
  return copied;
};
copyStyle$2.copyStyle = copyStyle$1;
const _$h = underDash;
const colCache$d = colCache_1;
const Range$5 = range$2;
const Row$2 = row;
const Column$2 = column$1;
const Enums$5 = enums;
const Image2 = image;
const Table2 = table$1;
const DataValidations$1 = dataValidations;
const Encryptor$1 = encryptor;
const { copyStyle } = copyStyle$2;
let Worksheet$1 = class Worksheet {
  constructor(options) {
    options = options || {};
    this._workbook = options.workbook;
    this.id = options.id;
    this.orderNo = options.orderNo;
    this.name = options.name;
    this.state = options.state || "visible";
    this._rows = [];
    this._columns = null;
    this._keys = {};
    this._merges = {};
    this.rowBreaks = [];
    this.properties = Object.assign(
      {},
      {
        defaultRowHeight: 15,
        dyDescent: 55,
        outlineLevelCol: 0,
        outlineLevelRow: 0
      },
      options.properties
    );
    this.pageSetup = Object.assign(
      {},
      {
        margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 },
        orientation: "portrait",
        horizontalDpi: 4294967295,
        verticalDpi: 4294967295,
        fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
        pageOrder: "downThenOver",
        blackAndWhite: false,
        draft: false,
        cellComments: "None",
        errors: "displayed",
        scale: 100,
        fitToWidth: 1,
        fitToHeight: 1,
        paperSize: void 0,
        showRowColHeaders: false,
        showGridLines: false,
        firstPageNumber: void 0,
        horizontalCentered: false,
        verticalCentered: false,
        rowBreaks: null,
        colBreaks: null
      },
      options.pageSetup
    );
    this.headerFooter = Object.assign(
      {},
      {
        differentFirst: false,
        differentOddEven: false,
        oddHeader: null,
        oddFooter: null,
        evenHeader: null,
        evenFooter: null,
        firstHeader: null,
        firstFooter: null
      },
      options.headerFooter
    );
    this.dataValidations = new DataValidations$1();
    this.views = options.views || [];
    this.autoFilter = options.autoFilter || null;
    this._media = [];
    this.sheetProtection = null;
    this.tables = {};
    this.conditionalFormattings = [];
  }
  get name() {
    return this._name;
  }
  set name(name) {
    if (name === void 0) {
      name = `sheet${this.id}`;
    }
    if (this._name === name) return;
    if (typeof name !== "string") {
      throw new Error("The name has to be a string.");
    }
    if (name === "") {
      throw new Error("The name can't be empty.");
    }
    if (name === "History") {
      throw new Error('The name "History" is protected. Please use a different name.');
    }
    if (/[*?:/\\[\]]/.test(name)) {
      throw new Error(`Worksheet name ${name} cannot include any of the following characters: * ? : \\ / [ ]`);
    }
    if (/(^')|('$)/.test(name)) {
      throw new Error(`The first or last character of worksheet name cannot be a single quotation mark: ${name}`);
    }
    if (name && name.length > 31) {
      console.warn(`Worksheet name ${name} exceeds 31 chars. This will be truncated`);
      name = name.substring(0, 31);
    }
    if (this._workbook._worksheets.find((ws) => ws && ws.name.toLowerCase() === name.toLowerCase())) {
      throw new Error(`Worksheet name already exists: ${name}`);
    }
    this._name = name;
  }
  get workbook() {
    return this._workbook;
  }
  // when you're done with this worksheet, call this to remove from workbook
  destroy() {
    this._workbook.removeWorksheetEx(this);
  }
  // Get the bounding range of the cells in this worksheet
  get dimensions() {
    const dimensions = new Range$5();
    this._rows.forEach((row2) => {
      if (row2) {
        const rowDims = row2.dimensions;
        if (rowDims) {
          dimensions.expand(row2.number, rowDims.min, row2.number, rowDims.max);
        }
      }
    });
    return dimensions;
  }
  // =========================================================================
  // Columns
  // get the current columns array.
  get columns() {
    return this._columns;
  }
  // set the columns from an array of column definitions.
  // Note: any headers defined will overwrite existing values.
  set columns(value) {
    this._headerRowCount = value.reduce((pv, cv) => {
      const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
      return Math.max(pv, headerCount);
    }, 0);
    let count = 1;
    const columns = this._columns = [];
    value.forEach((defn) => {
      const column2 = new Column$2(this, count++, false);
      columns.push(column2);
      column2.defn = defn;
    });
  }
  getColumnKey(key) {
    return this._keys[key];
  }
  setColumnKey(key, value) {
    this._keys[key] = value;
  }
  deleteColumnKey(key) {
    delete this._keys[key];
  }
  eachColumnKey(f) {
    _$h.each(this._keys, f);
  }
  // get a single column by col number. If it doesn't exist, create it and any gaps before it
  getColumn(c2) {
    if (typeof c2 === "string") {
      const col = this._keys[c2];
      if (col) return col;
      c2 = colCache$d.l2n(c2);
    }
    if (!this._columns) {
      this._columns = [];
    }
    if (c2 > this._columns.length) {
      let n = this._columns.length + 1;
      while (n <= c2) {
        this._columns.push(new Column$2(this, n++));
      }
    }
    return this._columns[c2 - 1];
  }
  spliceColumns(start, count, ...inserts) {
    const rows = this._rows;
    const nRows = rows.length;
    if (inserts.length > 0) {
      for (let i = 0; i < nRows; i++) {
        const rowArguments = [start, count];
        inserts.forEach((insert) => {
          rowArguments.push(insert[i] || null);
        });
        const row2 = this.getRow(i + 1);
        row2.splice.apply(row2, rowArguments);
      }
    } else {
      this._rows.forEach((r) => {
        if (r) {
          r.splice(start, count);
        }
      });
    }
    const nExpand = inserts.length - count;
    const nKeep = start + count;
    const nEnd = this._columns.length;
    if (nExpand < 0) {
      for (let i = start + inserts.length; i <= nEnd; i++) {
        this.getColumn(i).defn = this.getColumn(i - nExpand).defn;
      }
    } else if (nExpand > 0) {
      for (let i = nEnd; i >= nKeep; i--) {
        this.getColumn(i + nExpand).defn = this.getColumn(i).defn;
      }
    }
    for (let i = start; i < start + inserts.length; i++) {
      this.getColumn(i).defn = null;
    }
    this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);
  }
  get lastColumn() {
    return this.getColumn(this.columnCount);
  }
  get columnCount() {
    let maxCount = 0;
    this.eachRow((row2) => {
      maxCount = Math.max(maxCount, row2.cellCount);
    });
    return maxCount;
  }
  get actualColumnCount() {
    const counts = [];
    let count = 0;
    this.eachRow((row2) => {
      row2.eachCell(({ col }) => {
        if (!counts[col]) {
          counts[col] = true;
          count++;
        }
      });
    });
    return count;
  }
  // =========================================================================
  // Rows
  _commitRow() {
  }
  get _lastRowNumber() {
    const rows = this._rows;
    let n = rows.length;
    while (n > 0 && rows[n - 1] === void 0) {
      n--;
    }
    return n;
  }
  get _nextRow() {
    return this._lastRowNumber + 1;
  }
  get lastRow() {
    if (this._rows.length) {
      return this._rows[this._rows.length - 1];
    }
    return void 0;
  }
  // find a row (if exists) by row number
  findRow(r) {
    return this._rows[r - 1];
  }
  // find multiple rows (if exists) by row number
  findRows(start, length) {
    return this._rows.slice(start - 1, start - 1 + length);
  }
  get rowCount() {
    return this._lastRowNumber;
  }
  get actualRowCount() {
    let count = 0;
    this.eachRow(() => {
      count++;
    });
    return count;
  }
  // get a row by row number.
  getRow(r) {
    let row2 = this._rows[r - 1];
    if (!row2) {
      row2 = this._rows[r - 1] = new Row$2(this, r);
    }
    return row2;
  }
  // get multiple rows by row number.
  getRows(start, length) {
    if (length < 1) return void 0;
    const rows = [];
    for (let i = start; i < start + length; i++) {
      rows.push(this.getRow(i));
    }
    return rows;
  }
  addRow(value, style = "n") {
    const rowNo = this._nextRow;
    const row2 = this.getRow(rowNo);
    row2.values = value;
    this._setStyleOption(rowNo, style[0] === "i" ? style : "n");
    return row2;
  }
  addRows(value, style = "n") {
    const rows = [];
    value.forEach((row2) => {
      rows.push(this.addRow(row2, style));
    });
    return rows;
  }
  insertRow(pos, value, style = "n") {
    this.spliceRows(pos, 0, value);
    this._setStyleOption(pos, style);
    return this.getRow(pos);
  }
  insertRows(pos, values, style = "n") {
    this.spliceRows(pos, 0, ...values);
    if (style !== "n") {
      for (let i = 0; i < values.length; i++) {
        if (style[0] === "o" && this.findRow(values.length + pos + i) !== void 0) {
          this._copyStyle(values.length + pos + i, pos + i, style[1] === "+");
        } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
          this._copyStyle(pos - 1, pos + i, style[1] === "+");
        }
      }
    }
    return this.getRows(pos, values.length);
  }
  // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')
  _setStyleOption(pos, style = "n") {
    if (style[0] === "o" && this.findRow(pos + 1) !== void 0) {
      this._copyStyle(pos + 1, pos, style[1] === "+");
    } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
      this._copyStyle(pos - 1, pos, style[1] === "+");
    }
  }
  _copyStyle(src2, dest, styleEmpty = false) {
    const rSrc = this.getRow(src2);
    const rDst = this.getRow(dest);
    rDst.style = copyStyle(rSrc.style);
    rSrc.eachCell({ includeEmpty: styleEmpty }, (cell2, colNumber) => {
      rDst.getCell(colNumber).style = copyStyle(cell2.style);
    });
    rDst.height = rSrc.height;
  }
  duplicateRow(rowNum, count, insert = false) {
    const rSrc = this._rows[rowNum - 1];
    const inserts = new Array(count).fill(rSrc.values);
    this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);
    for (let i = 0; i < count; i++) {
      const rDst = this._rows[rowNum + i];
      rDst.style = rSrc.style;
      rDst.height = rSrc.height;
      rSrc.eachCell({ includeEmpty: true }, (cell2, colNumber) => {
        rDst.getCell(colNumber).style = cell2.style;
      });
    }
  }
  spliceRows(start, count, ...inserts) {
    const nKeep = start + count;
    const nInserts = inserts.length;
    const nExpand = nInserts - count;
    const nEnd = this._rows.length;
    let i;
    let rSrc;
    if (nExpand < 0) {
      if (start === nEnd) {
        this._rows[nEnd - 1] = void 0;
      }
      for (i = nKeep; i <= nEnd; i++) {
        rSrc = this._rows[i - 1];
        if (rSrc) {
          const rDst = this.getRow(i + nExpand);
          rDst.values = rSrc.values;
          rDst.style = rSrc.style;
          rDst.height = rSrc.height;
          rSrc.eachCell({ includeEmpty: true }, (cell2, colNumber) => {
            rDst.getCell(colNumber).style = cell2.style;
          });
          this._rows[i - 1] = void 0;
        } else {
          this._rows[i + nExpand - 1] = void 0;
        }
      }
    } else if (nExpand > 0) {
      for (i = nEnd; i >= nKeep; i--) {
        rSrc = this._rows[i - 1];
        if (rSrc) {
          const rDst = this.getRow(i + nExpand);
          rDst.values = rSrc.values;
          rDst.style = rSrc.style;
          rDst.height = rSrc.height;
          rSrc.eachCell({ includeEmpty: true }, (cell2, colNumber) => {
            rDst.getCell(colNumber).style = cell2.style;
            if (cell2._value.constructor.name === "MergeValue") {
              const cellToBeMerged = this.getRow(cell2._row._number + nInserts).getCell(colNumber);
              const prevMaster = cell2._value._master;
              const newMaster = this.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);
              cellToBeMerged.merge(newMaster);
            }
          });
        } else {
          this._rows[i + nExpand - 1] = void 0;
        }
      }
    }
    for (i = 0; i < nInserts; i++) {
      const rDst = this.getRow(start + i);
      rDst.style = {};
      rDst.values = inserts[i];
    }
    this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);
  }
  // iterate over every row in the worksheet, including maybe empty rows
  eachRow(options, iteratee) {
    if (!iteratee) {
      iteratee = options;
      options = void 0;
    }
    if (options && options.includeEmpty) {
      const n = this._rows.length;
      for (let i = 1; i <= n; i++) {
        iteratee(this.getRow(i), i);
      }
    } else {
      this._rows.forEach((row2) => {
        if (row2 && row2.hasValues) {
          iteratee(row2, row2.number);
        }
      });
    }
  }
  // return all rows as sparse array
  getSheetValues() {
    const rows = [];
    this._rows.forEach((row2) => {
      if (row2) {
        rows[row2.number] = row2.values;
      }
    });
    return rows;
  }
  // =========================================================================
  // Cells
  // returns the cell at [r,c] or address given by r. If not found, return undefined
  findCell(r, c2) {
    const address = colCache$d.getAddress(r, c2);
    const row2 = this._rows[address.row - 1];
    return row2 ? row2.findCell(address.col) : void 0;
  }
  // return the cell at [r,c] or address given by r. If not found, create a new one.
  getCell(r, c2) {
    const address = colCache$d.getAddress(r, c2);
    const row2 = this.getRow(address.row);
    return row2.getCellEx(address);
  }
  // =========================================================================
  // Merge
  // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell
  mergeCells(...cells) {
    const dimensions = new Range$5(cells);
    this._mergeCellsInternal(dimensions);
  }
  mergeCellsWithoutStyle(...cells) {
    const dimensions = new Range$5(cells);
    this._mergeCellsInternal(dimensions, true);
  }
  _mergeCellsInternal(dimensions, ignoreStyle) {
    _$h.each(this._merges, (merge) => {
      if (merge.intersects(dimensions)) {
        throw new Error("Cannot merge already merged cells");
      }
    });
    const master = this.getCell(dimensions.top, dimensions.left);
    for (let i = dimensions.top; i <= dimensions.bottom; i++) {
      for (let j = dimensions.left; j <= dimensions.right; j++) {
        if (i > dimensions.top || j > dimensions.left) {
          this.getCell(i, j).merge(master, ignoreStyle);
        }
      }
    }
    this._merges[master.address] = dimensions;
  }
  _unMergeMaster(master) {
    const merge = this._merges[master.address];
    if (merge) {
      for (let i = merge.top; i <= merge.bottom; i++) {
        for (let j = merge.left; j <= merge.right; j++) {
          this.getCell(i, j).unmerge();
        }
      }
      delete this._merges[master.address];
    }
  }
  get hasMerges() {
    return _$h.some(this._merges, Boolean);
  }
  // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,
  // un-merge the group. Note this function can affect multiple merges and merge-blocks are
  // atomic - either they're all merged or all un-merged.
  unMergeCells(...cells) {
    const dimensions = new Range$5(cells);
    for (let i = dimensions.top; i <= dimensions.bottom; i++) {
      for (let j = dimensions.left; j <= dimensions.right; j++) {
        const cell2 = this.findCell(i, j);
        if (cell2) {
          if (cell2.type === Enums$5.ValueType.Merge) {
            this._unMergeMaster(cell2.master);
          } else if (this._merges[cell2.address]) {
            this._unMergeMaster(cell2);
          }
        }
      }
    }
  }
  // ===========================================================================
  // Shared/Array Formula
  fillFormula(range2, formula, results, shareType = "shared") {
    const decoded = colCache$d.decode(range2);
    const { top, left, bottom, right } = decoded;
    const width = right - left + 1;
    const masterAddress = colCache$d.encodeAddress(top, left);
    const isShared = shareType === "shared";
    let getResult;
    if (typeof results === "function") {
      getResult = results;
    } else if (Array.isArray(results)) {
      if (Array.isArray(results[0])) {
        getResult = (row2, col) => results[row2 - top][col - left];
      } else {
        getResult = (row2, col) => results[(row2 - top) * width + (col - left)];
      }
    } else {
      getResult = () => void 0;
    }
    let first = true;
    for (let r = top; r <= bottom; r++) {
      for (let c2 = left; c2 <= right; c2++) {
        if (first) {
          this.getCell(r, c2).value = {
            shareType,
            formula,
            ref: range2,
            result: getResult(r, c2)
          };
          first = false;
        } else {
          this.getCell(r, c2).value = isShared ? {
            sharedFormula: masterAddress,
            result: getResult(r, c2)
          } : getResult(r, c2);
        }
      }
    }
  }
  // =========================================================================
  // Images
  addImage(imageId, range2) {
    const model = {
      type: "image",
      imageId,
      range: range2
    };
    this._media.push(new Image2(this, model));
  }
  getImages() {
    return this._media.filter((m) => m.type === "image");
  }
  addBackgroundImage(imageId) {
    const model = {
      type: "background",
      imageId
    };
    this._media.push(new Image2(this, model));
  }
  getBackgroundImageId() {
    const image2 = this._media.find((m) => m.type === "background");
    return image2 && image2.imageId;
  }
  // =========================================================================
  // Worksheet Protection
  protect(password, options) {
    return new Promise((resolve2) => {
      this.sheetProtection = {
        sheet: true
      };
      if (options && "spinCount" in options) {
        options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
      }
      if (password) {
        this.sheetProtection.algorithmName = "SHA-512";
        this.sheetProtection.saltValue = Encryptor$1.randomBytes(16).toString("base64");
        this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
        this.sheetProtection.hashValue = Encryptor$1.convertPasswordToHash(
          password,
          "SHA512",
          this.sheetProtection.saltValue,
          this.sheetProtection.spinCount
        );
      }
      if (options) {
        this.sheetProtection = Object.assign(this.sheetProtection, options);
        if (!password && "spinCount" in options) {
          delete this.sheetProtection.spinCount;
        }
      }
      resolve2();
    });
  }
  unprotect() {
    this.sheetProtection = null;
  }
  // =========================================================================
  // Tables
  addTable(model) {
    const table2 = new Table2(this, model);
    this.tables[model.name] = table2;
    return table2;
  }
  getTable(name) {
    return this.tables[name];
  }
  removeTable(name) {
    delete this.tables[name];
  }
  getTables() {
    return Object.values(this.tables);
  }
  // ===========================================================================
  // Conditional Formatting
  addConditionalFormatting(cf) {
    this.conditionalFormattings.push(cf);
  }
  removeConditionalFormatting(filter2) {
    if (typeof filter2 === "number") {
      this.conditionalFormattings.splice(filter2, 1);
    } else if (filter2 instanceof Function) {
      this.conditionalFormattings = this.conditionalFormattings.filter(filter2);
    } else {
      this.conditionalFormattings = [];
    }
  }
  // ===========================================================================
  // Deprecated
  get tabColor() {
    console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
    return this.properties.tabColor;
  }
  set tabColor(value) {
    console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
    this.properties.tabColor = value;
  }
  // ===========================================================================
  // Model
  get model() {
    const model = {
      id: this.id,
      name: this.name,
      dataValidations: this.dataValidations.model,
      properties: this.properties,
      state: this.state,
      pageSetup: this.pageSetup,
      headerFooter: this.headerFooter,
      rowBreaks: this.rowBreaks,
      views: this.views,
      autoFilter: this.autoFilter,
      media: this._media.map((medium) => medium.model),
      sheetProtection: this.sheetProtection,
      tables: Object.values(this.tables).map((table2) => table2.model),
      conditionalFormattings: this.conditionalFormattings
    };
    model.cols = Column$2.toModel(this.columns);
    const rows = model.rows = [];
    const dimensions = model.dimensions = new Range$5();
    this._rows.forEach((row2) => {
      const rowModel = row2 && row2.model;
      if (rowModel) {
        dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);
        rows.push(rowModel);
      }
    });
    model.merges = [];
    _$h.each(this._merges, (merge) => {
      model.merges.push(merge.range);
    });
    return model;
  }
  _parseRows(model) {
    this._rows = [];
    model.rows.forEach((rowModel) => {
      const row2 = new Row$2(this, rowModel.number);
      this._rows[row2.number - 1] = row2;
      row2.model = rowModel;
    });
  }
  _parseMergeCells(model) {
    _$h.each(model.mergeCells, (merge) => {
      this.mergeCellsWithoutStyle(merge);
    });
  }
  set model(value) {
    this.name = value.name;
    this._columns = Column$2.fromModel(this, value.cols);
    this._parseRows(value);
    this._parseMergeCells(value);
    this.dataValidations = new DataValidations$1(value.dataValidations);
    this.properties = value.properties;
    this.pageSetup = value.pageSetup;
    this.headerFooter = value.headerFooter;
    this.views = value.views;
    this.autoFilter = value.autoFilter;
    this._media = value.media.map((medium) => new Image2(this, medium));
    this.sheetProtection = value.sheetProtection;
    this.tables = value.tables.reduce((tables, table2) => {
      const t = new Table2();
      t.model = table2;
      tables[table2.name] = t;
      return tables;
    }, {});
    this.conditionalFormattings = value.conditionalFormattings;
  }
};
var worksheet = Worksheet$1;
const _$g = underDash;
const colCache$c = colCache_1;
let CellMatrix$1 = class CellMatrix {
  constructor(template) {
    this.template = template;
    this.sheets = {};
  }
  addCell(addressStr) {
    this.addCellEx(colCache$c.decodeEx(addressStr));
  }
  getCell(addressStr) {
    return this.findCellEx(colCache$c.decodeEx(addressStr), true);
  }
  findCell(addressStr) {
    return this.findCellEx(colCache$c.decodeEx(addressStr), false);
  }
  findCellAt(sheetName, rowNumber, colNumber) {
    const sheet = this.sheets[sheetName];
    const row2 = sheet && sheet[rowNumber];
    return row2 && row2[colNumber];
  }
  addCellEx(address) {
    if (address.top) {
      for (let row2 = address.top; row2 <= address.bottom; row2++) {
        for (let col = address.left; col <= address.right; col++) {
          this.getCellAt(address.sheetName, row2, col);
        }
      }
    } else {
      this.findCellEx(address, true);
    }
  }
  getCellEx(address) {
    return this.findCellEx(address, true);
  }
  findCellEx(address, create) {
    const sheet = this.findSheet(address, create);
    const row2 = this.findSheetRow(sheet, address, create);
    return this.findRowCell(row2, address, create);
  }
  getCellAt(sheetName, rowNumber, colNumber) {
    const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);
    const row2 = sheet[rowNumber] || (sheet[rowNumber] = []);
    const cell2 = row2[colNumber] || (row2[colNumber] = {
      sheetName,
      address: colCache$c.n2l(colNumber) + rowNumber,
      row: rowNumber,
      col: colNumber
    });
    return cell2;
  }
  removeCellEx(address) {
    const sheet = this.findSheet(address);
    if (!sheet) {
      return;
    }
    const row2 = this.findSheetRow(sheet, address);
    if (!row2) {
      return;
    }
    delete row2[address.col];
  }
  forEachInSheet(sheetName, callback) {
    const sheet = this.sheets[sheetName];
    if (sheet) {
      sheet.forEach((row2, rowNumber) => {
        if (row2) {
          row2.forEach((cell2, colNumber) => {
            if (cell2) {
              callback(cell2, rowNumber, colNumber);
            }
          });
        }
      });
    }
  }
  forEach(callback) {
    _$g.each(this.sheets, (sheet, sheetName) => {
      this.forEachInSheet(sheetName, callback);
    });
  }
  map(callback) {
    const results = [];
    this.forEach((cell2) => {
      results.push(callback(cell2));
    });
    return results;
  }
  findSheet(address, create) {
    const name = address.sheetName;
    if (this.sheets[name]) {
      return this.sheets[name];
    }
    if (create) {
      return this.sheets[name] = [];
    }
    return void 0;
  }
  findSheetRow(sheet, address, create) {
    const { row: row2 } = address;
    if (sheet && sheet[row2]) {
      return sheet[row2];
    }
    if (create) {
      return sheet[row2] = [];
    }
    return void 0;
  }
  findRowCell(row2, address, create) {
    const { col } = address;
    if (row2 && row2[col]) {
      return row2[col];
    }
    if (create) {
      return row2[col] = this.template ? Object.assign(address, JSON.parse(JSON.stringify(this.template))) : address;
    }
    return void 0;
  }
  spliceRows(sheetName, start, numDelete, numInsert) {
    const sheet = this.sheets[sheetName];
    if (sheet) {
      const inserts = [];
      for (let i = 0; i < numInsert; i++) {
        inserts.push([]);
      }
      sheet.splice(start, numDelete, ...inserts);
    }
  }
  spliceColumns(sheetName, start, numDelete, numInsert) {
    const sheet = this.sheets[sheetName];
    if (sheet) {
      const inserts = [];
      for (let i = 0; i < numInsert; i++) {
        inserts.push(null);
      }
      _$g.each(sheet, (row2) => {
        row2.splice(start, numDelete, ...inserts);
      });
    }
  }
};
var cellMatrix = CellMatrix$1;
const _$f = underDash;
const colCache$b = colCache_1;
const CellMatrix2 = cellMatrix;
const Range$4 = range$2;
const rangeRegexp = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;
let DefinedNames$2 = class DefinedNames {
  constructor() {
    this.matrixMap = {};
  }
  getMatrix(name) {
    const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix2());
    return matrix;
  }
  // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
  add(locStr, name) {
    const location = colCache$b.decodeEx(locStr);
    this.addEx(location, name);
  }
  addEx(location, name) {
    const matrix = this.getMatrix(name);
    if (location.top) {
      for (let col = location.left; col <= location.right; col++) {
        for (let row2 = location.top; row2 <= location.bottom; row2++) {
          const address = {
            sheetName: location.sheetName,
            address: colCache$b.n2l(col) + row2,
            row: row2,
            col
          };
          matrix.addCellEx(address);
        }
      }
    } else {
      matrix.addCellEx(location);
    }
  }
  remove(locStr, name) {
    const location = colCache$b.decodeEx(locStr);
    this.removeEx(location, name);
  }
  removeEx(location, name) {
    const matrix = this.getMatrix(name);
    matrix.removeCellEx(location);
  }
  removeAllNames(location) {
    _$f.each(this.matrixMap, (matrix) => {
      matrix.removeCellEx(location);
    });
  }
  forEach(callback) {
    _$f.each(this.matrixMap, (matrix, name) => {
      matrix.forEach((cell2) => {
        callback(name, cell2);
      });
    });
  }
  // get all the names of a cell
  getNames(addressStr) {
    return this.getNamesEx(colCache$b.decodeEx(addressStr));
  }
  getNamesEx(address) {
    return _$f.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(
      Boolean
    );
  }
  _explore(matrix, cell2) {
    cell2.mark = false;
    const { sheetName } = cell2;
    const range2 = new Range$4(cell2.row, cell2.col, cell2.row, cell2.col, sheetName);
    let x;
    let y;
    function vGrow(yy, edge) {
      const c2 = matrix.findCellAt(sheetName, yy, cell2.col);
      if (!c2 || !c2.mark) {
        return false;
      }
      range2[edge] = yy;
      c2.mark = false;
      return true;
    }
    for (y = cell2.row - 1; vGrow(y, "top"); y--) ;
    for (y = cell2.row + 1; vGrow(y, "bottom"); y++) ;
    function hGrow(xx, edge) {
      const cells = [];
      for (y = range2.top; y <= range2.bottom; y++) {
        const c2 = matrix.findCellAt(sheetName, y, xx);
        if (c2 && c2.mark) {
          cells.push(c2);
        } else {
          return false;
        }
      }
      range2[edge] = xx;
      for (let i = 0; i < cells.length; i++) {
        cells[i].mark = false;
      }
      return true;
    }
    for (x = cell2.col - 1; hGrow(x, "left"); x--) ;
    for (x = cell2.col + 1; hGrow(x, "right"); x++) ;
    return range2;
  }
  getRanges(name, matrix) {
    matrix = matrix || this.matrixMap[name];
    if (!matrix) {
      return { name, ranges: [] };
    }
    matrix.forEach((cell2) => {
      cell2.mark = true;
    });
    const ranges = matrix.map((cell2) => cell2.mark && this._explore(matrix, cell2)).filter(Boolean).map((range2) => range2.$shortRange);
    return {
      name,
      ranges
    };
  }
  normaliseMatrix(matrix, sheetName) {
    matrix.forEachInSheet(sheetName, (cell2, row2, col) => {
      if (cell2) {
        if (cell2.row !== row2 || cell2.col !== col) {
          cell2.row = row2;
          cell2.col = col;
          cell2.address = colCache$b.n2l(col) + row2;
        }
      }
    });
  }
  spliceRows(sheetName, start, numDelete, numInsert) {
    _$f.each(this.matrixMap, (matrix) => {
      matrix.spliceRows(sheetName, start, numDelete, numInsert);
      this.normaliseMatrix(matrix, sheetName);
    });
  }
  spliceColumns(sheetName, start, numDelete, numInsert) {
    _$f.each(this.matrixMap, (matrix) => {
      matrix.spliceColumns(sheetName, start, numDelete, numInsert);
      this.normaliseMatrix(matrix, sheetName);
    });
  }
  get model() {
    return _$f.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(
      (definedName) => definedName.ranges.length
    );
  }
  set model(value) {
    const matrixMap = this.matrixMap = {};
    value.forEach((definedName) => {
      const matrix = matrixMap[definedName.name] = new CellMatrix2();
      definedName.ranges.forEach((rangeStr) => {
        if (rangeRegexp.test(rangeStr.split("!").pop() || "")) {
          matrix.addCell(rangeStr);
        }
      });
    });
  }
};
var definedNames = DefinedNames$2;
var utf8$5 = {};
var utils$H = {};
var support$4 = {};
var readable$5 = { exports: {} };
var processNextickArgs = { exports: {} };
var hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1;
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    processNextickArgs.exports = { nextTick: nextTick2 };
  } else {
    processNextickArgs.exports = process;
  }
  function nextTick2(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var toString3 = {}.toString;
  isarray = Array.isArray || function(arr) {
    return toString3.call(arr) == "[object Array]";
  };
  return isarray;
}
var stream$7;
var hasRequiredStream$5;
function requireStream$5() {
  if (hasRequiredStream$5) return stream$7;
  hasRequiredStream$5 = 1;
  stream$7 = require$$0$1;
  return stream$7;
}
var safeBuffer$5 = { exports: {} };
var hasRequiredSafeBuffer$5;
function requireSafeBuffer$5() {
  if (hasRequiredSafeBuffer$5) return safeBuffer$5.exports;
  hasRequiredSafeBuffer$5 = 1;
  (function(module, exports) {
    var buffer = require$$0$3;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$5, safeBuffer$5.exports);
  return safeBuffer$5.exports;
}
var util$h = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$h;
  hasRequiredUtil$1 = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString2(arg) === "[object Array]";
  }
  util$h.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$h.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util$h.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$h.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  util$h.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  util$h.isString = isString;
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  util$h.isSymbol = isSymbol2;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$h.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString2(re) === "[object RegExp]";
  }
  util$h.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$h.isObject = isObject2;
  function isDate(d) {
    return objectToString2(d) === "[object Date]";
  }
  util$h.isDate = isDate;
  function isError(e) {
    return objectToString2(e) === "[object Error]" || e instanceof Error;
  }
  util$h.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$h.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$h.isPrimitive = isPrimitive;
  util$h.isBuffer = Buffer.isBuffer;
  function objectToString2(o) {
    return Object.prototype.toString.call(o);
  }
  return util$h;
}
var inherits$a = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits$a.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits !== "function") throw "";
    inherits$a.exports = util2.inherits;
  } catch (e) {
    inherits$a.exports = requireInherits_browser();
  }
  return inherits$a.exports;
}
var BufferList$6 = { exports: {} };
var hasRequiredBufferList$4;
function requireBufferList$4() {
  if (hasRequiredBufferList$4) return BufferList$6.exports;
  hasRequiredBufferList$4 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$5().Buffer;
    var util2 = require$$0$4;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$6);
  return BufferList$6.exports;
}
var destroy_1$5;
var hasRequiredDestroy$5;
function requireDestroy$5() {
  if (hasRequiredDestroy$5) return destroy_1$5;
  hasRequiredDestroy$5 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err2, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err2);
      } else if (err2) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err2);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err2);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err2 || null, function(err3) {
      if (!cb && err3) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err3);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err3);
        }
      } else if (cb) {
        cb(err3);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err2) {
    self2.emit("error", err2);
  }
  destroy_1$5 = {
    destroy,
    undestroy
  };
  return destroy_1$5;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  node = require$$0$4.deprecate;
  return node;
}
var _stream_writable$5;
var hasRequired_stream_writable$5;
function require_stream_writable$5() {
  if (hasRequired_stream_writable$5) return _stream_writable$5;
  hasRequired_stream_writable$5 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$5 = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream$5();
  var Buffer2 = requireSafeBuffer$5().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$5();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$5();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable2) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex$5();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
      return new Writable2(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync3) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err2) {
      state2.pendingcb--;
      if (err2) {
        stream2.emit("error", err2);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err2) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err2, cb) {
    this.end();
    cb(err2);
  };
  return _stream_writable$5;
}
var _stream_duplex$5;
var hasRequired_stream_duplex$5;
function require_stream_duplex$5() {
  if (hasRequired_stream_duplex$5) return _stream_duplex$5;
  hasRequired_stream_duplex$5 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$5 = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$5();
  var Writable2 = require_stream_writable$5();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable2.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err2, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err2);
  };
  return _stream_duplex$5;
}
var string_decoder$5 = {};
var hasRequiredString_decoder$5;
function requireString_decoder$5() {
  if (hasRequiredString_decoder$5) return string_decoder$5;
  hasRequiredString_decoder$5 = 1;
  var Buffer2 = requireSafeBuffer$5().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$5.StringDecoder = StringDecoder2;
  function StringDecoder2(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder2.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder2.prototype.end = utf8End;
  StringDecoder2.prototype.text = utf8Text;
  StringDecoder2.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$5;
}
var _stream_readable$5;
var hasRequired_stream_readable$5;
function require_stream_readable$5() {
  if (hasRequired_stream_readable$5) return _stream_readable$5;
  hasRequired_stream_readable$5 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$5 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = requireStream$5();
  var Buffer2 = requireSafeBuffer$5().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$4;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList$4();
  var destroyImpl = requireDestroy$5();
  var StringDecoder2;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$5();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2) StringDecoder2 = requireString_decoder$5().StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$5();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err2, cb) {
    this.push(null);
    cb(err2);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder2) StringDecoder2 = requireString_decoder$5().StringDecoder;
    this._readableState.decoder = new StringDecoder2(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug2("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c2 = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c2 = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$5;
}
var _stream_transform$5;
var hasRequired_stream_transform$5;
function require_stream_transform$5() {
  if (hasRequired_stream_transform$5) return _stream_transform$5;
  hasRequired_stream_transform$5 = 1;
  _stream_transform$5 = Transform2;
  var Duplex = require_stream_duplex$5();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err2, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err2, function(err22) {
      cb(err22);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$5;
}
var _stream_passthrough$5;
var hasRequired_stream_passthrough$5;
function require_stream_passthrough$5() {
  if (hasRequired_stream_passthrough$5) return _stream_passthrough$5;
  hasRequired_stream_passthrough$5 = 1;
  _stream_passthrough$5 = PassThrough2;
  var Transform2 = require_stream_transform$5();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$5;
}
var hasRequiredReadable$1;
function requireReadable$1() {
  if (hasRequiredReadable$1) return readable$5.exports;
  hasRequiredReadable$1 = 1;
  (function(module, exports) {
    var Stream2 = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream2) {
      module.exports = Stream2;
      exports = module.exports = Stream2.Readable;
      exports.Readable = Stream2.Readable;
      exports.Writable = Stream2.Writable;
      exports.Duplex = Stream2.Duplex;
      exports.Transform = Stream2.Transform;
      exports.PassThrough = Stream2.PassThrough;
      exports.Stream = Stream2;
    } else {
      exports = module.exports = require_stream_readable$5();
      exports.Stream = Stream2 || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable$5();
      exports.Duplex = require_stream_duplex$5();
      exports.Transform = require_stream_transform$5();
      exports.PassThrough = require_stream_passthrough$5();
    }
  })(readable$5, readable$5.exports);
  return readable$5.exports;
}
var nodestream;
var blob;
support$4.base64 = true;
support$4.array = true;
support$4.string = true;
support$4.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
support$4.nodebuffer = typeof Buffer !== "undefined";
support$4.uint8array = typeof Uint8Array !== "undefined";
if (typeof ArrayBuffer === "undefined") {
  blob = support$4.blob = false;
} else {
  var buffer = new ArrayBuffer(0);
  try {
    blob = support$4.blob = new Blob([buffer], {
      type: "application/zip"
    }).size === 0;
  } catch (e) {
    try {
      var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
      var builder = new Builder();
      builder.append(buffer);
      blob = support$4.blob = builder.getBlob("application/zip").size === 0;
    } catch (e2) {
      blob = support$4.blob = false;
    }
  }
}
try {
  nodestream = support$4.nodestream = !!requireReadable$1().Readable;
} catch (e) {
  nodestream = support$4.nodestream = false;
}
var base64$1 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64$1;
  hasRequiredBase64 = 1;
  var utils2 = requireUtils();
  var support2 = support$4;
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  base64$1.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;
    var isArray2 = utils2.getTypeOf(input) !== "string";
    while (i < input.length) {
      remainingBytes = len - i;
      if (!isArray2) {
        chr1 = input.charCodeAt(i++);
        chr2 = i < len ? input.charCodeAt(i++) : 0;
        chr3 = i < len ? input.charCodeAt(i++) : 0;
      } else {
        chr1 = input[i++];
        chr2 = i < len ? input[i++] : 0;
        chr3 = i < len ? input[i++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  base64$1.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support2.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
  return base64$1;
}
var nodejsUtils$2 = {
  /**
   * True if this is running in Nodejs, will be undefined in a browser.
   * In a browser, browserify won't include this file and the whole module
   * will be resolved an empty object.
   */
  isNode: typeof Buffer !== "undefined",
  /**
   * Create a new nodejs Buffer from an existing content.
   * @param {Object} data the data to pass to the constructor.
   * @param {String} encoding the encoding to use.
   * @return {Buffer} a new Buffer.
   */
  newBufferFrom: function(data, encoding) {
    if (Buffer.from && Buffer.from !== Uint8Array.from) {
      return Buffer.from(data, encoding);
    } else {
      if (typeof data === "number") {
        throw new Error('The "data" argument must not be a number');
      }
      return new Buffer(data, encoding);
    }
  },
  /**
   * Create a new nodejs Buffer with the specified size.
   * @param {Integer} size the size of the buffer.
   * @return {Buffer} a new Buffer.
   */
  allocBuffer: function(size) {
    if (Buffer.alloc) {
      return Buffer.alloc(size);
    } else {
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
  },
  /**
   * Find out if an object is a Buffer.
   * @param {Object} b the object to test.
   * @return {Boolean} true if the object is a Buffer, false otherwise.
   */
  isBuffer: function(b) {
    return Buffer.isBuffer(b);
  },
  isStream: function(obj) {
    return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
  }
};
var lib$3;
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$3;
  hasRequiredLib$1 = 1;
  var Mutation = commonjsGlobal.MutationObserver || commonjsGlobal.WebKitMutationObserver;
  var scheduleDrain;
  if (process.browser) {
    if (Mutation) {
      var called = 0;
      var observer = new Mutation(nextTick2);
      var element = commonjsGlobal.document.createTextNode("");
      observer.observe(element, {
        characterData: true
      });
      scheduleDrain = function() {
        element.data = called = ++called % 2;
      };
    } else if (!commonjsGlobal.setImmediate && typeof commonjsGlobal.MessageChannel !== "undefined") {
      var channel = new commonjsGlobal.MessageChannel();
      channel.port1.onmessage = nextTick2;
      scheduleDrain = function() {
        channel.port2.postMessage(0);
      };
    } else if ("document" in commonjsGlobal && "onreadystatechange" in commonjsGlobal.document.createElement("script")) {
      scheduleDrain = function() {
        var scriptEl = commonjsGlobal.document.createElement("script");
        scriptEl.onreadystatechange = function() {
          nextTick2();
          scriptEl.onreadystatechange = null;
          scriptEl.parentNode.removeChild(scriptEl);
          scriptEl = null;
        };
        commonjsGlobal.document.documentElement.appendChild(scriptEl);
      };
    } else {
      scheduleDrain = function() {
        setTimeout(nextTick2, 0);
      };
    }
  } else {
    scheduleDrain = function() {
      process.nextTick(nextTick2);
    };
  }
  var draining;
  var queue2 = [];
  function nextTick2() {
    draining = true;
    var i, oldQueue;
    var len = queue2.length;
    while (len) {
      oldQueue = queue2;
      queue2 = [];
      i = -1;
      while (++i < len) {
        oldQueue[i]();
      }
      len = queue2.length;
    }
    draining = false;
  }
  lib$3 = immediate;
  function immediate(task) {
    if (queue2.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }
  return lib$3;
}
var lib$2;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$2;
  hasRequiredLib = 1;
  var immediate = requireLib$1();
  function INTERNAL() {
  }
  var handlers = {};
  var REJECTED = ["REJECTED"];
  var FULFILLED = ["FULFILLED"];
  var PENDING = ["PENDING"];
  if (!process.browser) {
    var UNHANDLED = ["UNHANDLED"];
  }
  lib$2 = Promise2;
  function Promise2(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function");
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = void 0;
    if (!process.browser) {
      this.handled = UNHANDLED;
    }
    if (resolver !== INTERNAL) {
      safelyResolveThenable(this, resolver);
    }
  }
  Promise2.prototype.finally = function(callback) {
    if (typeof callback !== "function") {
      return this;
    }
    var p = this.constructor;
    return this.then(resolve3, reject3);
    function resolve3(value) {
      function yes() {
        return value;
      }
      return p.resolve(callback()).then(yes);
    }
    function reject3(reason) {
      function no() {
        throw reason;
      }
      return p.resolve(callback()).then(no);
    }
  };
  Promise2.prototype.catch = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
      return this;
    }
    var promise2 = new this.constructor(INTERNAL);
    if (!process.browser) {
      if (this.handled === UNHANDLED) {
        this.handled = null;
      }
    }
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise2, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise2, onFulfilled, onRejected));
    }
    return promise2;
  };
  function QueueItem(promise2, onFulfilled, onRejected) {
    this.promise = promise2;
    if (typeof onFulfilled === "function") {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === "function") {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function(value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function(value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function(value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function(value) {
    unwrap(this.promise, this.onRejected, value);
  };
  function unwrap(promise2, func, value) {
    immediate(function() {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e) {
        return handlers.reject(promise2, e);
      }
      if (returnValue === promise2) {
        handlers.reject(promise2, new TypeError("Cannot resolve promise with itself"));
      } else {
        handlers.resolve(promise2, returnValue);
      }
    });
  }
  handlers.resolve = function(self2, value) {
    var result = tryCatch(getThen, value);
    if (result.status === "error") {
      return handlers.reject(self2, result.value);
    }
    var thenable = result.value;
    if (thenable) {
      safelyResolveThenable(self2, thenable);
    } else {
      self2.state = FULFILLED;
      self2.outcome = value;
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callFulfilled(value);
      }
    }
    return self2;
  };
  handlers.reject = function(self2, error2) {
    self2.state = REJECTED;
    self2.outcome = error2;
    if (!process.browser) {
      if (self2.handled === UNHANDLED) {
        immediate(function() {
          if (self2.handled === UNHANDLED) {
            process.emit("unhandledRejection", error2, self2);
          }
        });
      }
    }
    var i = -1;
    var len = self2.queue.length;
    while (++i < len) {
      self2.queue[i].callRejected(error2);
    }
    return self2;
  };
  function getThen(obj) {
    var then = obj && obj.then;
    if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }
  function safelyResolveThenable(self2, thenable) {
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self2, value);
    }
    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self2, value);
    }
    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }
    var result = tryCatch(tryToUnwrap);
    if (result.status === "error") {
      onError(result.value);
    }
  }
  function tryCatch(func, value) {
    var out2 = {};
    try {
      out2.value = func(value);
      out2.status = "success";
    } catch (e) {
      out2.status = "error";
      out2.value = e;
    }
    return out2;
  }
  Promise2.resolve = resolve2;
  function resolve2(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL), value);
  }
  Promise2.reject = reject2;
  function reject2(reason) {
    var promise2 = new this(INTERNAL);
    return handlers.reject(promise2, reason);
  }
  Promise2.all = all;
  function all(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var values = new Array(len);
    var resolved = 0;
    var i = -1;
    var promise2 = new this(INTERNAL);
    while (++i < len) {
      allResolver(iterable[i], i);
    }
    return promise2;
    function allResolver(value, i2) {
      self2.resolve(value).then(resolveFromAll, function(error2) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error2);
        }
      });
      function resolveFromAll(outValue) {
        values[i2] = outValue;
        if (++resolved === len && !called) {
          called = true;
          handlers.resolve(promise2, values);
        }
      }
    }
  }
  Promise2.race = race2;
  function race2(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var i = -1;
    var promise2 = new this(INTERNAL);
    while (++i < len) {
      resolver(iterable[i]);
    }
    return promise2;
    function resolver(value) {
      self2.resolve(value).then(function(response) {
        if (!called) {
          called = true;
          handlers.resolve(promise2, response);
        }
      }, function(error2) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error2);
        }
      });
    }
  }
  return lib$2;
}
var ES6Promise = null;
if (typeof Promise !== "undefined") {
  ES6Promise = Promise;
} else {
  ES6Promise = requireLib();
}
var external$3 = {
  Promise: ES6Promise
};
(function(global2, undefined$1) {
  if (global2.setImmediate) {
    return;
  }
  var nextHandle = 1;
  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global2.document;
  var registerImmediate;
  function setImmediate2(callback) {
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    }
    var args = new Array(arguments.length - 1);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    }
    var task = { callback, args };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }
  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }
  function run(task) {
    var callback = task.callback;
    var args = task.args;
    switch (args.length) {
      case 0:
        callback();
        break;
      case 1:
        callback(args[0]);
        break;
      case 2:
        callback(args[0], args[1]);
        break;
      case 3:
        callback(args[0], args[1], args[2]);
        break;
      default:
        callback.apply(undefined$1, args);
        break;
    }
  }
  function runIfPresent(handle) {
    if (currentlyRunningATask) {
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];
      if (task) {
        currentlyRunningATask = true;
        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }
  function installNextTickImplementation() {
    registerImmediate = function(handle) {
      process.nextTick(function() {
        runIfPresent(handle);
      });
    };
  }
  function canUsePostMessage() {
    if (global2.postMessage && !global2.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global2.onmessage;
      global2.onmessage = function() {
        postMessageIsAsynchronous = false;
      };
      global2.postMessage("", "*");
      global2.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }
  function installPostMessageImplementation() {
    var messagePrefix = "setImmediate$" + Math.random() + "$";
    var onGlobalMessage = function(event) {
      if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };
    if (global2.addEventListener) {
      global2.addEventListener("message", onGlobalMessage, false);
    } else {
      global2.attachEvent("onmessage", onGlobalMessage);
    }
    registerImmediate = function(handle) {
      global2.postMessage(messagePrefix + handle, "*");
    };
  }
  function installMessageChannelImplementation() {
    var channel = new MessageChannel();
    channel.port1.onmessage = function(event) {
      var handle = event.data;
      runIfPresent(handle);
    };
    registerImmediate = function(handle) {
      channel.port2.postMessage(handle);
    };
  }
  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;
    registerImmediate = function(handle) {
      var script = doc.createElement("script");
      script.onreadystatechange = function() {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };
      html.appendChild(script);
    };
  }
  function installSetTimeoutImplementation() {
    registerImmediate = function(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  }
  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
  if ({}.toString.call(global2.process) === "[object process]") {
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    installPostMessageImplementation();
  } else if (global2.MessageChannel) {
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    installReadyStateChangeImplementation();
  } else {
    installSetTimeoutImplementation();
  }
  attachTo.setImmediate = setImmediate2;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof commonjsGlobal === "undefined" ? commonjsGlobal : commonjsGlobal : self);
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$H;
  hasRequiredUtils = 1;
  (function(exports) {
    var support2 = support$4;
    var base642 = requireBase64();
    var nodejsUtils2 = nodejsUtils$2;
    var external2 = external$3;
    function string2binary(str) {
      var result = null;
      if (support2.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports.newBlob = function(part, type) {
      exports.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support2.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support2.nodebuffer && String.fromCharCode.apply(null, nodejsUtils2.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform2 = {};
    transform2["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform2["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils2.allocBuffer(input.length));
      }
    };
    transform2["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(input);
      }
    };
    transform2["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(new Uint8Array(input));
      }
    };
    transform2["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(input);
      }
    };
    transform2["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform2["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports.checkSupport(outputType);
      var inputType = exports.getTypeOf(input);
      var result = transform2[inputType][outputType](input);
      return result;
    };
    exports.resolve = function(path2) {
      var parts = path2.split("/");
      var result = [];
      for (var index2 = 0; index2 < parts.length; index2++) {
        var part = parts[index2];
        if (part === "." || part === "" && index2 !== 0 && index2 !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result.pop();
        } else {
          result.push(part);
        }
      }
      return result.join("/");
    };
    exports.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support2.nodebuffer && nodejsUtils2.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support2.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support2.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports.checkSupport = function(type) {
      var supported = support2[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports.MAX_VALUE_16BITS = 65535;
    exports.MAX_VALUE_32BITS = -1;
    exports.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports.inherits = function(ctor, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise2 = external2.Promise.resolve(inputData).then(function(data) {
        var isBlob = support2.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external2.Promise(function(resolve2, reject2) {
            var reader2 = new FileReader();
            reader2.onload = function(e) {
              resolve2(e.target.result);
            };
            reader2.onerror = function(e) {
              reject2(e.target.error);
            };
            reader2.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise2.then(function(data) {
        var dataType = exports.getTypeOf(data);
        if (!dataType) {
          return external2.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base642.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  })(utils$H);
  return utils$H;
}
function GenericWorker$b(name) {
  this.name = name || "default";
  this.streamInfo = {};
  this.generatedError = null;
  this.extraStreamInfo = {};
  this.isPaused = true;
  this.isFinished = false;
  this.isLocked = false;
  this._listeners = {
    "data": [],
    "end": [],
    "error": []
  };
  this.previous = null;
}
GenericWorker$b.prototype = {
  /**
   * Push a chunk to the next workers.
   * @param {Object} chunk the chunk to push
   */
  push: function(chunk) {
    this.emit("data", chunk);
  },
  /**
   * End the stream.
   * @return {Boolean} true if this call ended the worker, false otherwise.
   */
  end: function() {
    if (this.isFinished) {
      return false;
    }
    this.flush();
    try {
      this.emit("end");
      this.cleanUp();
      this.isFinished = true;
    } catch (e) {
      this.emit("error", e);
    }
    return true;
  },
  /**
   * End the stream with an error.
   * @param {Error} e the error which caused the premature end.
   * @return {Boolean} true if this call ended the worker with an error, false otherwise.
   */
  error: function(e) {
    if (this.isFinished) {
      return false;
    }
    if (this.isPaused) {
      this.generatedError = e;
    } else {
      this.isFinished = true;
      this.emit("error", e);
      if (this.previous) {
        this.previous.error(e);
      }
      this.cleanUp();
    }
    return true;
  },
  /**
   * Add a callback on an event.
   * @param {String} name the name of the event (data, end, error)
   * @param {Function} listener the function to call when the event is triggered
   * @return {GenericWorker} the current object for chainability
   */
  on: function(name, listener) {
    this._listeners[name].push(listener);
    return this;
  },
  /**
   * Clean any references when a worker is ending.
   */
  cleanUp: function() {
    this.streamInfo = this.generatedError = this.extraStreamInfo = null;
    this._listeners = [];
  },
  /**
   * Trigger an event. This will call registered callback with the provided arg.
   * @param {String} name the name of the event (data, end, error)
   * @param {Object} arg the argument to call the callback with.
   */
  emit: function(name, arg) {
    if (this._listeners[name]) {
      for (var i = 0; i < this._listeners[name].length; i++) {
        this._listeners[name][i].call(this, arg);
      }
    }
  },
  /**
   * Chain a worker with an other.
   * @param {Worker} next the worker receiving events from the current one.
   * @return {worker} the next worker for chainability
   */
  pipe: function(next) {
    return next.registerPrevious(this);
  },
  /**
   * Same as `pipe` in the other direction.
   * Using an API with `pipe(next)` is very easy.
   * Implementing the API with the point of view of the next one registering
   * a source is easier, see the ZipFileWorker.
   * @param {Worker} previous the previous worker, sending events to this one
   * @return {Worker} the current worker for chainability
   */
  registerPrevious: function(previous) {
    if (this.isLocked) {
      throw new Error("The stream '" + this + "' has already been used.");
    }
    this.streamInfo = previous.streamInfo;
    this.mergeStreamInfo();
    this.previous = previous;
    var self2 = this;
    previous.on("data", function(chunk) {
      self2.processChunk(chunk);
    });
    previous.on("end", function() {
      self2.end();
    });
    previous.on("error", function(e) {
      self2.error(e);
    });
    return this;
  },
  /**
   * Pause the stream so it doesn't send events anymore.
   * @return {Boolean} true if this call paused the worker, false otherwise.
   */
  pause: function() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    this.isPaused = true;
    if (this.previous) {
      this.previous.pause();
    }
    return true;
  },
  /**
   * Resume a paused stream.
   * @return {Boolean} true if this call resumed the worker, false otherwise.
   */
  resume: function() {
    if (!this.isPaused || this.isFinished) {
      return false;
    }
    this.isPaused = false;
    var withError = false;
    if (this.generatedError) {
      this.error(this.generatedError);
      withError = true;
    }
    if (this.previous) {
      this.previous.resume();
    }
    return !withError;
  },
  /**
   * Flush any remaining bytes as the stream is ending.
   */
  flush: function() {
  },
  /**
   * Process a chunk. This is usually the method overridden.
   * @param {Object} chunk the chunk to process.
   */
  processChunk: function(chunk) {
    this.push(chunk);
  },
  /**
   * Add a key/value to be added in the workers chain streamInfo once activated.
   * @param {String} key the key to use
   * @param {Object} value the associated value
   * @return {Worker} the current worker for chainability
   */
  withStreamInfo: function(key, value) {
    this.extraStreamInfo[key] = value;
    this.mergeStreamInfo();
    return this;
  },
  /**
   * Merge this worker's streamInfo into the chain's streamInfo.
   */
  mergeStreamInfo: function() {
    for (var key in this.extraStreamInfo) {
      if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
        continue;
      }
      this.streamInfo[key] = this.extraStreamInfo[key];
    }
  },
  /**
   * Lock the stream to prevent further updates on the workers chain.
   * After calling this method, all calls to pipe will fail.
   */
  lock: function() {
    if (this.isLocked) {
      throw new Error("The stream '" + this + "' has already been used.");
    }
    this.isLocked = true;
    if (this.previous) {
      this.previous.lock();
    }
  },
  /**
   *
   * Pretty print the workers chain.
   */
  toString: function() {
    var me = "Worker " + this.name;
    if (this.previous) {
      return this.previous + " -> " + me;
    } else {
      return me;
    }
  }
};
var GenericWorker_1 = GenericWorker$b;
(function(exports) {
  var utils2 = requireUtils();
  var support2 = support$4;
  var nodejsUtils2 = nodejsUtils$2;
  var GenericWorker2 = GenericWorker_1;
  var _utf8len2 = new Array(256);
  for (var i = 0; i < 256; i++) {
    _utf8len2[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
  }
  _utf8len2[254] = _utf8len2[254] = 1;
  var string2buf = function(str) {
    var buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    if (support2.uint8array) {
      buf = new Uint8Array(buf_len);
    } else {
      buf = new Array(buf_len);
    }
    for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i2++] = c2;
      } else if (c2 < 2048) {
        buf[i2++] = 192 | c2 >>> 6;
        buf[i2++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i2++] = 224 | c2 >>> 12;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      } else {
        buf[i2++] = 240 | c2 >>> 18;
        buf[i2++] = 128 | c2 >>> 12 & 63;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  var utf8border = function(buf, max) {
    var pos;
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len2[buf[pos]] > max ? pos : max;
  };
  var buf2string = function(buf) {
    var i2, out2, c2, c_len;
    var len = buf.length;
    var utf16buf = new Array(len * 2);
    for (out2 = 0, i2 = 0; i2 < len; ) {
      c2 = buf[i2++];
      if (c2 < 128) {
        utf16buf[out2++] = c2;
        continue;
      }
      c_len = _utf8len2[c2];
      if (c_len > 4) {
        utf16buf[out2++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c2 = c2 << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out2++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out2++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out2++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out2++] = 56320 | c2 & 1023;
      }
    }
    if (utf16buf.length !== out2) {
      if (utf16buf.subarray) {
        utf16buf = utf16buf.subarray(0, out2);
      } else {
        utf16buf.length = out2;
      }
    }
    return utils2.applyFromCharCode(utf16buf);
  };
  exports.utf8encode = function utf8encode(str) {
    if (support2.nodebuffer) {
      return nodejsUtils2.newBufferFrom(str, "utf-8");
    }
    return string2buf(str);
  };
  exports.utf8decode = function utf8decode(buf) {
    if (support2.nodebuffer) {
      return utils2.transformTo("nodebuffer", buf).toString("utf-8");
    }
    buf = utils2.transformTo(support2.uint8array ? "uint8array" : "array", buf);
    return buf2string(buf);
  };
  function Utf8DecodeWorker() {
    GenericWorker2.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  utils2.inherits(Utf8DecodeWorker, GenericWorker2);
  Utf8DecodeWorker.prototype.processChunk = function(chunk) {
    var data = utils2.transformTo(support2.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support2.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support2.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: exports.utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker.prototype.flush = function() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: exports.utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  exports.Utf8DecodeWorker = Utf8DecodeWorker;
  function Utf8EncodeWorker() {
    GenericWorker2.call(this, "utf-8 encode");
  }
  utils2.inherits(Utf8EncodeWorker, GenericWorker2);
  Utf8EncodeWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: exports.utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  exports.Utf8EncodeWorker = Utf8EncodeWorker;
})(utf8$5);
var GenericWorker$a = GenericWorker_1;
var utils$G = requireUtils();
function ConvertWorker$1(destType) {
  GenericWorker$a.call(this, "ConvertWorker to " + destType);
  this.destType = destType;
}
utils$G.inherits(ConvertWorker$1, GenericWorker$a);
ConvertWorker$1.prototype.processChunk = function(chunk) {
  this.push({
    data: utils$G.transformTo(this.destType, chunk.data),
    meta: chunk.meta
  });
};
var ConvertWorker_1 = ConvertWorker$1;
var NodejsStreamOutputAdapter_1;
var hasRequiredNodejsStreamOutputAdapter;
function requireNodejsStreamOutputAdapter() {
  if (hasRequiredNodejsStreamOutputAdapter) return NodejsStreamOutputAdapter_1;
  hasRequiredNodejsStreamOutputAdapter = 1;
  var Readable2 = requireReadable$1().Readable;
  var utils2 = requireUtils();
  utils2.inherits(NodejsStreamOutputAdapter2, Readable2);
  function NodejsStreamOutputAdapter2(helper, options, updateCb) {
    Readable2.call(this, options);
    this._helper = helper;
    var self2 = this;
    helper.on("data", function(data, meta) {
      if (!self2.push(data)) {
        self2._helper.pause();
      }
      if (updateCb) {
        updateCb(meta);
      }
    }).on("error", function(e) {
      self2.emit("error", e);
    }).on("end", function() {
      self2.push(null);
    });
  }
  NodejsStreamOutputAdapter2.prototype._read = function() {
    this._helper.resume();
  };
  NodejsStreamOutputAdapter_1 = NodejsStreamOutputAdapter2;
  return NodejsStreamOutputAdapter_1;
}
var utils$F = requireUtils();
var ConvertWorker = ConvertWorker_1;
var GenericWorker$9 = GenericWorker_1;
var base64 = requireBase64();
var support$3 = support$4;
var external$2 = external$3;
var NodejsStreamOutputAdapter = null;
if (support$3.nodestream) {
  try {
    NodejsStreamOutputAdapter = requireNodejsStreamOutputAdapter();
  } catch (e) {
  }
}
function transformZipOutput(type, content, mimeType) {
  switch (type) {
    case "blob":
      return utils$F.newBlob(utils$F.transformTo("arraybuffer", content), mimeType);
    case "base64":
      return base64.encode(content);
    default:
      return utils$F.transformTo(type, content);
  }
}
function concat$2(type, dataArray) {
  var i, index2 = 0, res = null, totalLength = 0;
  for (i = 0; i < dataArray.length; i++) {
    totalLength += dataArray[i].length;
  }
  switch (type) {
    case "string":
      return dataArray.join("");
    case "array":
      return Array.prototype.concat.apply([], dataArray);
    case "uint8array":
      res = new Uint8Array(totalLength);
      for (i = 0; i < dataArray.length; i++) {
        res.set(dataArray[i], index2);
        index2 += dataArray[i].length;
      }
      return res;
    case "nodebuffer":
      return Buffer.concat(dataArray);
    default:
      throw new Error("concat : unsupported type '" + type + "'");
  }
}
function accumulate(helper, updateCallback) {
  return new external$2.Promise(function(resolve2, reject2) {
    var dataArray = [];
    var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
    helper.on("data", function(data, meta) {
      dataArray.push(data);
      if (updateCallback) {
        updateCallback(meta);
      }
    }).on("error", function(err2) {
      dataArray = [];
      reject2(err2);
    }).on("end", function() {
      try {
        var result = transformZipOutput(resultType, concat$2(chunkType, dataArray), mimeType);
        resolve2(result);
      } catch (e) {
        reject2(e);
      }
      dataArray = [];
    }).resume();
  });
}
function StreamHelper$2(worker, outputType, mimeType) {
  var internalType = outputType;
  switch (outputType) {
    case "blob":
    case "arraybuffer":
      internalType = "uint8array";
      break;
    case "base64":
      internalType = "string";
      break;
  }
  try {
    this._internalType = internalType;
    this._outputType = outputType;
    this._mimeType = mimeType;
    utils$F.checkSupport(internalType);
    this._worker = worker.pipe(new ConvertWorker(internalType));
    worker.lock();
  } catch (e) {
    this._worker = new GenericWorker$9("error");
    this._worker.error(e);
  }
}
StreamHelper$2.prototype = {
  /**
   * Listen a StreamHelper, accumulate its content and concatenate it into a
   * complete block.
   * @param {Function} updateCb the update callback.
   * @return Promise the promise for the accumulation.
   */
  accumulate: function(updateCb) {
    return accumulate(this, updateCb);
  },
  /**
   * Add a listener on an event triggered on a stream.
   * @param {String} evt the name of the event
   * @param {Function} fn the listener
   * @return {StreamHelper} the current helper.
   */
  on: function(evt, fn) {
    var self2 = this;
    if (evt === "data") {
      this._worker.on(evt, function(chunk) {
        fn.call(self2, chunk.data, chunk.meta);
      });
    } else {
      this._worker.on(evt, function() {
        utils$F.delay(fn, arguments, self2);
      });
    }
    return this;
  },
  /**
   * Resume the flow of chunks.
   * @return {StreamHelper} the current helper.
   */
  resume: function() {
    utils$F.delay(this._worker.resume, [], this._worker);
    return this;
  },
  /**
   * Pause the flow of chunks.
   * @return {StreamHelper} the current helper.
   */
  pause: function() {
    this._worker.pause();
    return this;
  },
  /**
   * Return a nodejs stream for this helper.
   * @param {Function} updateCb the update callback.
   * @return {NodejsStreamOutputAdapter} the nodejs stream.
   */
  toNodejsStream: function(updateCb) {
    utils$F.checkSupport("nodestream");
    if (this._outputType !== "nodebuffer") {
      throw new Error(this._outputType + " is not supported by this method");
    }
    return new NodejsStreamOutputAdapter(this, {
      objectMode: this._outputType !== "nodebuffer"
    }, updateCb);
  }
};
var StreamHelper_1 = StreamHelper$2;
var defaults$5 = {};
defaults$5.base64 = false;
defaults$5.binary = false;
defaults$5.dir = false;
defaults$5.createFolders = true;
defaults$5.date = null;
defaults$5.compression = null;
defaults$5.compressionOptions = null;
defaults$5.comment = null;
defaults$5.unixPermissions = null;
defaults$5.dosPermissions = null;
var utils$E = requireUtils();
var GenericWorker$8 = GenericWorker_1;
var DEFAULT_BLOCK_SIZE = 16 * 1024;
function DataWorker$2(dataP) {
  GenericWorker$8.call(this, "DataWorker");
  var self2 = this;
  this.dataIsReady = false;
  this.index = 0;
  this.max = 0;
  this.data = null;
  this.type = "";
  this._tickScheduled = false;
  dataP.then(function(data) {
    self2.dataIsReady = true;
    self2.data = data;
    self2.max = data && data.length || 0;
    self2.type = utils$E.getTypeOf(data);
    if (!self2.isPaused) {
      self2._tickAndRepeat();
    }
  }, function(e) {
    self2.error(e);
  });
}
utils$E.inherits(DataWorker$2, GenericWorker$8);
DataWorker$2.prototype.cleanUp = function() {
  GenericWorker$8.prototype.cleanUp.call(this);
  this.data = null;
};
DataWorker$2.prototype.resume = function() {
  if (!GenericWorker$8.prototype.resume.call(this)) {
    return false;
  }
  if (!this._tickScheduled && this.dataIsReady) {
    this._tickScheduled = true;
    utils$E.delay(this._tickAndRepeat, [], this);
  }
  return true;
};
DataWorker$2.prototype._tickAndRepeat = function() {
  this._tickScheduled = false;
  if (this.isPaused || this.isFinished) {
    return;
  }
  this._tick();
  if (!this.isFinished) {
    utils$E.delay(this._tickAndRepeat, [], this);
    this._tickScheduled = true;
  }
};
DataWorker$2.prototype._tick = function() {
  if (this.isPaused || this.isFinished) {
    return false;
  }
  var size = DEFAULT_BLOCK_SIZE;
  var data = null, nextIndex = Math.min(this.max, this.index + size);
  if (this.index >= this.max) {
    return this.end();
  } else {
    switch (this.type) {
      case "string":
        data = this.data.substring(this.index, nextIndex);
        break;
      case "uint8array":
        data = this.data.subarray(this.index, nextIndex);
        break;
      case "array":
      case "nodebuffer":
        data = this.data.slice(this.index, nextIndex);
        break;
    }
    this.index = nextIndex;
    return this.push({
      data,
      meta: {
        percent: this.max ? this.index / this.max * 100 : 0
      }
    });
  }
};
var DataWorker_1 = DataWorker$2;
var utils$D = requireUtils();
function makeTable$1() {
  var c2, table2 = [];
  for (var n = 0; n < 256; n++) {
    c2 = n;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table2[n] = c2;
  }
  return table2;
}
var crcTable$1 = makeTable$1();
function crc32$b(crc2, buf, len, pos) {
  var t = crcTable$1, end2 = pos + len;
  crc2 = crc2 ^ -1;
  for (var i = pos; i < end2; i++) {
    crc2 = crc2 >>> 8 ^ t[(crc2 ^ buf[i]) & 255];
  }
  return crc2 ^ -1;
}
function crc32str(crc2, str, len, pos) {
  var t = crcTable$1, end2 = pos + len;
  crc2 = crc2 ^ -1;
  for (var i = pos; i < end2; i++) {
    crc2 = crc2 >>> 8 ^ t[(crc2 ^ str.charCodeAt(i)) & 255];
  }
  return crc2 ^ -1;
}
var crc32_1$1 = function crc32wrapper(input, crc2) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }
  var isArray2 = utils$D.getTypeOf(input) !== "string";
  if (isArray2) {
    return crc32$b(crc2 | 0, input, input.length, 0);
  } else {
    return crc32str(crc2 | 0, input, input.length, 0);
  }
};
var GenericWorker$7 = GenericWorker_1;
var crc32$a = crc32_1$1;
var utils$C = requireUtils();
function Crc32Probe$2() {
  GenericWorker$7.call(this, "Crc32Probe");
  this.withStreamInfo("crc32", 0);
}
utils$C.inherits(Crc32Probe$2, GenericWorker$7);
Crc32Probe$2.prototype.processChunk = function(chunk) {
  this.streamInfo.crc32 = crc32$a(chunk.data, this.streamInfo.crc32 || 0);
  this.push(chunk);
};
var Crc32Probe_1 = Crc32Probe$2;
var utils$B = requireUtils();
var GenericWorker$6 = GenericWorker_1;
function DataLengthProbe$1(propName) {
  GenericWorker$6.call(this, "DataLengthProbe for " + propName);
  this.propName = propName;
  this.withStreamInfo(propName, 0);
}
utils$B.inherits(DataLengthProbe$1, GenericWorker$6);
DataLengthProbe$1.prototype.processChunk = function(chunk) {
  if (chunk) {
    var length = this.streamInfo[this.propName] || 0;
    this.streamInfo[this.propName] = length + chunk.data.length;
  }
  GenericWorker$6.prototype.processChunk.call(this, chunk);
};
var DataLengthProbe_1 = DataLengthProbe$1;
var external$1 = external$3;
var DataWorker$1 = DataWorker_1;
var Crc32Probe$1 = Crc32Probe_1;
var DataLengthProbe = DataLengthProbe_1;
function CompressedObject$3(compressedSize, uncompressedSize, crc322, compression, data) {
  this.compressedSize = compressedSize;
  this.uncompressedSize = uncompressedSize;
  this.crc32 = crc322;
  this.compression = compression;
  this.compressedContent = data;
}
CompressedObject$3.prototype = {
  /**
   * Create a worker to get the uncompressed content.
   * @return {GenericWorker} the worker.
   */
  getContentWorker: function() {
    var worker = new DataWorker$1(external$1.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
    var that = this;
    worker.on("end", function() {
      if (this.streamInfo["data_length"] !== that.uncompressedSize) {
        throw new Error("Bug : uncompressed data size mismatch");
      }
    });
    return worker;
  },
  /**
   * Create a worker to get the compressed content.
   * @return {GenericWorker} the worker.
   */
  getCompressedWorker: function() {
    return new DataWorker$1(external$1.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
  }
};
CompressedObject$3.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
  return uncompressedWorker.pipe(new Crc32Probe$1()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
};
var compressedObject = CompressedObject$3;
var StreamHelper$1 = StreamHelper_1;
var DataWorker = DataWorker_1;
var utf8$4 = utf8$5;
var CompressedObject$2 = compressedObject;
var GenericWorker$5 = GenericWorker_1;
var ZipObject$1 = function(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this._dataBinary = options.binary;
  this.options = {
    compression: options.compression,
    compressionOptions: options.compressionOptions
  };
};
ZipObject$1.prototype = {
  /**
   * Create an internal stream for the content of this object.
   * @param {String} type the type of each chunk.
   * @return StreamHelper the stream.
   */
  internalStream: function(type) {
    var result = null, outputType = "string";
    try {
      if (!type) {
        throw new Error("No output type specified.");
      }
      outputType = type.toLowerCase();
      var askUnicodeString = outputType === "string" || outputType === "text";
      if (outputType === "binarystring" || outputType === "text") {
        outputType = "string";
      }
      result = this._decompressWorker();
      var isUnicodeString = !this._dataBinary;
      if (isUnicodeString && !askUnicodeString) {
        result = result.pipe(new utf8$4.Utf8EncodeWorker());
      }
      if (!isUnicodeString && askUnicodeString) {
        result = result.pipe(new utf8$4.Utf8DecodeWorker());
      }
    } catch (e) {
      result = new GenericWorker$5("error");
      result.error(e);
    }
    return new StreamHelper$1(result, outputType, "");
  },
  /**
   * Prepare the content in the asked type.
   * @param {String} type the type of the result.
   * @param {Function} onUpdate a function to call on each internal update.
   * @return Promise the promise of the result.
   */
  async: function(type, onUpdate) {
    return this.internalStream(type).accumulate(onUpdate);
  },
  /**
   * Prepare the content as a nodejs stream.
   * @param {String} type the type of each chunk.
   * @param {Function} onUpdate a function to call on each internal update.
   * @return Stream the stream.
   */
  nodeStream: function(type, onUpdate) {
    return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
  },
  /**
   * Return a worker for the compressed content.
   * @private
   * @param {Object} compression the compression object to use.
   * @param {Object} compressionOptions the options to use when compressing.
   * @return Worker the worker.
   */
  _compressWorker: function(compression, compressionOptions) {
    if (this._data instanceof CompressedObject$2 && this._data.compression.magic === compression.magic) {
      return this._data.getCompressedWorker();
    } else {
      var result = this._decompressWorker();
      if (!this._dataBinary) {
        result = result.pipe(new utf8$4.Utf8EncodeWorker());
      }
      return CompressedObject$2.createWorkerFrom(result, compression, compressionOptions);
    }
  },
  /**
   * Return a worker for the decompressed content.
   * @private
   * @return Worker the worker.
   */
  _decompressWorker: function() {
    if (this._data instanceof CompressedObject$2) {
      return this._data.getContentWorker();
    } else if (this._data instanceof GenericWorker$5) {
      return this._data;
    } else {
      return new DataWorker(this._data);
    }
  }
};
var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function() {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
for (var i = 0; i < removedMethods.length; i++) {
  ZipObject$1.prototype[removedMethods[i]] = removedFn;
}
var zipObject = ZipObject$1;
var generate$1 = {};
var compressions$2 = {};
var flate = {};
var common$1 = {};
(function(exports) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src2, src_offs, len, dest_offs) {
      if (src2.subarray && dest.subarray) {
        dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      var i, l, len, pos, chunk, result;
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src2, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src2[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
})(common$1);
var deflate$4 = {};
var deflate$3 = {};
var trees$1 = {};
var utils$A = common$1;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code(s, c2, tree) {
  send_bits(
    s,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n, m;
  var bits;
  var xbits;
  var f;
  var overflow2 = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow2++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow2 === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow2 -= 2;
  } while (overflow2 > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s) {
  var n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block(s, buf, len, header) {
  bi_windup(s);
  {
    put_short(s, len);
    put_short(s, ~len);
  }
  utils$A.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
function smaller$1(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
function pqdownheap(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller$1(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller$1(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  var max_code = -1;
  var node2;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node2 = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node2 * 2] = 1;
    s.depth[node2] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node2 * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node2 = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node2 * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node2] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node2;
    s.heap[
      1
      /*SMALLEST*/
    ] = node2++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}
function scan_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s) {
  var max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type(s) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}
function _tr_stored_block(s, buf, stored_len, last) {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  copy_block(s, buf, stored_len);
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
function _tr_flush_block(s, buf, stored_len, last) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
}
function _tr_tally(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c2, table2 = [];
  for (var n = 0; n < 256; n++) {
    c2 = n;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table2[n] = c2;
  }
  return table2;
}
var crcTable = makeTable();
function crc32$9(crc2, buf, len, pos) {
  var t = crcTable, end2 = pos + len;
  crc2 ^= -1;
  for (var i = pos; i < end2; i++) {
    crc2 = crc2 >>> 8 ^ t[(crc2 ^ buf[i]) & 255];
  }
  return crc2 ^ -1;
}
var crc32_1 = crc32$9;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$z = common$1;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$8 = crc32_1;
var msg$2 = messages;
var Z_NO_FLUSH$1 = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$2 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$2 = 0;
var Z_STREAM_END$2 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION$1 = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY$1 = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$2 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg$2[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s = strm.state;
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$z.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}
function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
function putShortMSB(s, b) {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
}
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$z.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$8(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match2;
  var len;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match2 = cur_match;
    if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match2++;
    do {
    } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$z.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
}
function deflate_stored(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$1) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$2) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s) {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$z.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$z.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$z.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$z.Buf16(MAX_BITS + 1);
  this.heap = new utils$z.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$z.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$1;
  trees._tr_init(s);
  return Z_OK$2;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$2) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$2;
}
function deflateInit2(strm, level, method2, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method2 !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils$z.Buf8(s.w_size * 2);
  s.head = new utils$z.Buf16(s.hash_size);
  s.prev = new utils$z.Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils$z.Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method2;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
}
function deflate$2(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH$2) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32$8(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$8(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$8(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$8(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$8(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32$8(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32$8(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$2;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$2) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$2;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$2;
      }
    }
  }
  if (flush !== Z_FINISH$2) {
    return Z_OK$2;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$2;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$2 : Z_STREAM_END$2;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$2;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap2;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s = strm.state;
  wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap2 === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = new utils$z.Buf8(s.w_size);
    utils$z.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK$2;
}
deflate$3.deflateInit = deflateInit;
deflate$3.deflateInit2 = deflateInit2;
deflate$3.deflateReset = deflateReset;
deflate$3.deflateResetKeep = deflateResetKeep;
deflate$3.deflateSetHeader = deflateSetHeader;
deflate$3.deflate = deflate$2;
deflate$3.deflateEnd = deflateEnd;
deflate$3.deflateSetDictionary = deflateSetDictionary;
deflate$3.deflateInfo = "pako deflate (from Nodeca project)";
var strings$2 = {};
var utils$y = common$1;
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (__) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new utils$y.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
strings$2.string2buf = function(str) {
  var buf, c2, c22, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new utils$y.Buf8(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i++] = c2;
    } else if (c2 < 2048) {
      buf[i++] = 192 | c2 >>> 6;
      buf[i++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i++] = 224 | c2 >>> 12;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    } else {
      buf[i++] = 240 | c2 >>> 18;
      buf[i++] = 128 | c2 >>> 12 & 63;
      buf[i++] = 128 | c2 >>> 6 & 63;
      buf[i++] = 128 | c2 & 63;
    }
  }
  return buf;
};
function buf2binstring(buf, len) {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
      return String.fromCharCode.apply(null, utils$y.shrinkBuf(buf, len));
    }
  }
  var result = "";
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
strings$2.buf2binstring = function(buf) {
  return buf2binstring(buf, buf.length);
};
strings$2.binstring2buf = function(str) {
  var buf = new utils$y.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};
strings$2.buf2string = function(buf, max) {
  var i, out2, c2, c_len;
  var len = max || buf.length;
  var utf16buf = new Array(len * 2);
  for (out2 = 0, i = 0; i < len; ) {
    c2 = buf[i++];
    if (c2 < 128) {
      utf16buf[out2++] = c2;
      continue;
    }
    c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out2++] = 65533;
      i += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c2 = c2 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out2++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out2++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out2++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out2++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out2);
};
strings$2.utf8border = function(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
function ZStream$2() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream$2;
var zlib_deflate = deflate$3;
var utils$x = common$1;
var strings$1 = strings$2;
var msg$1 = messages;
var ZStream$1 = zstream;
var toString$2 = Object.prototype.toString;
var Z_NO_FLUSH = 0;
var Z_FINISH$1 = 4;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_SYNC_FLUSH = 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_DEFAULT_STRATEGY = 0;
var Z_DEFLATED$1 = 8;
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);
  this.options = utils$x.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ""
  }, options || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream$1();
  this.strm.avail_out = 0;
  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$1) {
    throw new Error(msg$1[status]);
  }
  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$1.string2buf(opt.dictionary);
    } else if (toString$2.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = zlib_deflate.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$1) {
      throw new Error(msg$1[status]);
    }
    this._dict_set = true;
  }
}
Deflate.prototype.push = function(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH$1 : Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = strings$1.string2buf(data);
  } else if (toString$2.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$x.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);
    if (status !== Z_STREAM_END$1 && status !== Z_OK$1) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH$1 || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === "string") {
        this.onData(strings$1.buf2binstring(utils$x.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils$x.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END$1);
  if (_mode === Z_FINISH$1) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK$1;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK$1);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function(status) {
  if (status === Z_OK$1) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$x.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  var deflator = new Deflate(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg$1[deflator.err];
  }
  return deflator.result;
}
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
deflate$4.Deflate = Deflate;
deflate$4.deflate = deflate$1;
deflate$4.deflateRaw = deflateRaw;
deflate$4.gzip = gzip;
var inflate$4 = {};
var inflate$3 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start) {
  var state2;
  var _in;
  var last;
  var _out;
  var beg;
  var end2;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end2 = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state2.sane) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state2.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state2.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end2);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end2 ? 257 + (end2 - _out) : 257 - (_out - end2);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
var utils$w = common$1;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table(type, lens, lens_index, codes, table2, table_index, work, opts) {
  var bits = opts.bits;
  var len = 0;
  var sym = 0;
  var min = 0, max = 0;
  var root2 = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end2;
  var count = new utils$w.Buf16(MAXBITS + 1);
  var offs = new utils$w.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end2 = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end2 = 256;
  } else {
    base = dbase;
    extra = dext;
    end2 = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end2) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end2) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root2 << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var utils$v = common$1;
var adler32 = adler32_1;
var crc32$7 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils$v.Buf16(320);
  this.work = new utils$v.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new utils$v.Buf32(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new utils$v.Buf32(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap2;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap2;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix, distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = new utils$v.Buf32(512);
    distfix = new utils$v.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table2(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, { bits: 5 });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
function updatewindow(strm, src2, end2, copy3) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new utils$v.Buf8(state2.wsize);
  }
  if (copy3 >= state2.wsize) {
    utils$v.arraySet(state2.window, src2, end2 - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy3) {
      dist = copy3;
    }
    utils$v.arraySet(state2.window, src2, end2 - copy3, dist, state2.wnext);
    copy3 -= dist;
    if (copy3) {
      utils$v.arraySet(state2.window, src2, end2 - copy3, copy3, 0);
      state2.wnext = copy3;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
function inflate$2(strm, flush) {
  var state2;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy3;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils$v.Buf8(4);
  var opts;
  var n;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32$7(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32$7(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32$7(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32$7(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32$7(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        case EXTRA:
          if (state2.flags & 1024) {
            copy3 = state2.length;
            if (copy3 > have) {
              copy3 = have;
            }
            if (copy3) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                utils$v.arraySet(
                  state2.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy3,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32$7(state2.check, input, copy3, next);
              }
              have -= copy3;
              next += copy3;
              state2.length -= copy3;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy3 = 0;
            do {
              len = input[next + copy3++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy3 < have);
            if (state2.flags & 512) {
              state2.check = crc32$7(state2.check, input, copy3, next);
            }
            have -= copy3;
            next += copy3;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy3 = 0;
            do {
              len = input[next + copy3++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy3 < have);
            if (state2.flags & 512) {
              state2.check = crc32$7(state2.check, input, copy3, next);
            }
            have -= copy3;
            next += copy3;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state2.mode = COPY;
        case COPY:
          copy3 = state2.length;
          if (copy3) {
            if (copy3 > have) {
              copy3 = have;
            }
            if (copy3 > left) {
              copy3 = left;
            }
            if (copy3 === 0) {
              break inf_leave;
            }
            utils$v.arraySet(output, input, next, copy3, put);
            have -= copy3;
            next += copy3;
            left -= copy3;
            put += copy3;
            state2.length -= copy3;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts = { bits: state2.lenbits };
          ret = inflate_table2(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy3 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy3 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy3 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy3 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy3--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts = { bits: state2.lenbits };
          ret = inflate_table2(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts = { bits: state2.distbits };
          ret = inflate_table2(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
          state2.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state2.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        case LENEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        case DISTEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy3 = _out - left;
          if (state2.offset > copy3) {
            copy3 = state2.offset - copy3;
            if (copy3 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy3 > state2.wnext) {
              copy3 -= state2.wnext;
              from = state2.wsize - copy3;
            } else {
              from = state2.wnext - copy3;
            }
            if (copy3 > state2.length) {
              copy3 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from = put - state2.offset;
            copy3 = state2.length;
          }
          if (copy3 > left) {
            copy3 = left;
          }
          left -= copy3;
          state2.length -= copy3;
          do {
            output[put++] = from_source[from++];
          } while (--copy3);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32$7(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32$7(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state2.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK;
}
inflate$3.inflateReset = inflateReset;
inflate$3.inflateReset2 = inflateReset2;
inflate$3.inflateResetKeep = inflateResetKeep;
inflate$3.inflateInit = inflateInit;
inflate$3.inflateInit2 = inflateInit2;
inflate$3.inflate = inflate$2;
inflate$3.inflateEnd = inflateEnd;
inflate$3.inflateGetHeader = inflateGetHeader;
inflate$3.inflateSetDictionary = inflateSetDictionary;
inflate$3.inflateInfo = "pako inflate (from Nodeca project)";
var constants$6 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function GZheader$1() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader$1;
var zlib_inflate = inflate$3;
var utils$u = common$1;
var strings = strings$2;
var c = constants$6;
var msg = messages;
var ZStream = zstream;
var GZheader = gzheader;
var toString$1 = Object.prototype.toString;
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);
  this.options = utils$u.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }
  this.header = new GZheader();
  zlib_inflate.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}
Inflate.prototype.push = function(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = strings.binstring2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = new utils$u.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }
    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }
    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            utils$u.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(utils$u.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function(status) {
  if (status === c.Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = utils$u.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  var inflator = new Inflate(options);
  inflator.push(input, true);
  if (inflator.err) {
    throw inflator.msg || msg[inflator.err];
  }
  return inflator.result;
}
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
inflate$4.Inflate = Inflate;
inflate$4.inflate = inflate$1;
inflate$4.inflateRaw = inflateRaw;
inflate$4.ungzip = inflate$1;
var assign$1 = common$1.assign;
var deflate = deflate$4;
var inflate = inflate$4;
var constants$5 = constants$6;
var pako$1 = {};
assign$1(pako$1, deflate, inflate, constants$5);
var pako_1 = pako$1;
var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
var pako = pako_1;
var utils$t = requireUtils();
var GenericWorker$4 = GenericWorker_1;
var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
flate.magic = "\b\0";
function FlateWorker(action, options) {
  GenericWorker$4.call(this, "FlateWorker/" + action);
  this._pako = null;
  this._pakoAction = action;
  this._pakoOptions = options;
  this.meta = {};
}
utils$t.inherits(FlateWorker, GenericWorker$4);
FlateWorker.prototype.processChunk = function(chunk) {
  this.meta = chunk.meta;
  if (this._pako === null) {
    this._createPako();
  }
  this._pako.push(utils$t.transformTo(ARRAY_TYPE, chunk.data), false);
};
FlateWorker.prototype.flush = function() {
  GenericWorker$4.prototype.flush.call(this);
  if (this._pako === null) {
    this._createPako();
  }
  this._pako.push([], true);
};
FlateWorker.prototype.cleanUp = function() {
  GenericWorker$4.prototype.cleanUp.call(this);
  this._pako = null;
};
FlateWorker.prototype._createPako = function() {
  this._pako = new pako[this._pakoAction]({
    raw: true,
    level: this._pakoOptions.level || -1
    // default compression
  });
  var self2 = this;
  this._pako.onData = function(data) {
    self2.push({
      data,
      meta: self2.meta
    });
  };
};
flate.compressWorker = function(compressionOptions) {
  return new FlateWorker("Deflate", compressionOptions);
};
flate.uncompressWorker = function() {
  return new FlateWorker("Inflate", {});
};
var GenericWorker$3 = GenericWorker_1;
compressions$2.STORE = {
  magic: "\0\0",
  compressWorker: function() {
    return new GenericWorker$3("STORE compression");
  },
  uncompressWorker: function() {
    return new GenericWorker$3("STORE decompression");
  }
};
compressions$2.DEFLATE = flate;
var signature$2 = {};
signature$2.LOCAL_FILE_HEADER = "PK";
signature$2.CENTRAL_FILE_HEADER = "PK";
signature$2.CENTRAL_DIRECTORY_END = "PK";
signature$2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
signature$2.ZIP64_CENTRAL_DIRECTORY_END = "PK";
signature$2.DATA_DESCRIPTOR = "PK\x07\b";
var utils$s = requireUtils();
var GenericWorker$2 = GenericWorker_1;
var utf8$3 = utf8$5;
var crc32$6 = crc32_1$1;
var signature$1 = signature$2;
var decToHex = function(dec, bytes) {
  var hex = "", i;
  for (i = 0; i < bytes; i++) {
    hex += String.fromCharCode(dec & 255);
    dec = dec >>> 8;
  }
  return hex;
};
var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
  var result = unixPermissions;
  if (!unixPermissions) {
    result = isDir ? 16893 : 33204;
  }
  return (result & 65535) << 16;
};
var generateDosExternalFileAttr = function(dosPermissions) {
  return (dosPermissions || 0) & 63;
};
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform2, encodeFileName) {
  var file2 = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8$3.utf8encode, encodedFileName = utils$s.transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = utils$s.transformTo("string", utf8$3.utf8encode(file2.name)), comment = file2.comment, encodedComment = utils$s.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils$s.transformTo("string", utf8$3.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir2 = file2.dir, date = file2.date;
  var dataInfo = {
    crc32: 0,
    compressedSize: 0,
    uncompressedSize: 0
  };
  if (!streamedContent || streamingEnded) {
    dataInfo.crc32 = streamInfo["crc32"];
    dataInfo.compressedSize = streamInfo["compressedSize"];
    dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
  }
  var bitflag = 0;
  if (streamedContent) {
    bitflag |= 8;
  }
  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
    bitflag |= 2048;
  }
  var extFileAttr = 0;
  var versionMadeBy = 0;
  if (dir2) {
    extFileAttr |= 16;
  }
  if (platform2 === "UNIX") {
    versionMadeBy = 798;
    extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir2);
  } else {
    versionMadeBy = 20;
    extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions);
  }
  dosTime = date.getUTCHours();
  dosTime = dosTime << 6;
  dosTime = dosTime | date.getUTCMinutes();
  dosTime = dosTime << 5;
  dosTime = dosTime | date.getUTCSeconds() / 2;
  dosDate = date.getUTCFullYear() - 1980;
  dosDate = dosDate << 4;
  dosDate = dosDate | date.getUTCMonth() + 1;
  dosDate = dosDate << 5;
  dosDate = dosDate | date.getUTCDate();
  if (useUTF8ForFileName) {
    unicodePathExtraField = // Version
    decToHex(1, 1) + // NameCRC32
    decToHex(crc32$6(encodedFileName), 4) + // UnicodeName
    utfEncodedFileName;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "up" + // size
    decToHex(unicodePathExtraField.length, 2) + // content
    unicodePathExtraField;
  }
  if (useUTF8ForComment) {
    unicodeCommentExtraField = // Version
    decToHex(1, 1) + // CommentCRC32
    decToHex(crc32$6(encodedComment), 4) + // UnicodeName
    utfEncodedComment;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "uc" + // size
    decToHex(unicodeCommentExtraField.length, 2) + // content
    unicodeCommentExtraField;
  }
  var header = "";
  header += "\n\0";
  header += decToHex(bitflag, 2);
  header += compression.magic;
  header += decToHex(dosTime, 2);
  header += decToHex(dosDate, 2);
  header += decToHex(dataInfo.crc32, 4);
  header += decToHex(dataInfo.compressedSize, 4);
  header += decToHex(dataInfo.uncompressedSize, 4);
  header += decToHex(encodedFileName.length, 2);
  header += decToHex(extraFields.length, 2);
  var fileRecord = signature$1.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = signature$1.CENTRAL_FILE_HEADER + // version made by (00: DOS)
  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
  header + // file comment length
  decToHex(encodedComment.length, 2) + // disk number start
  "\0\0\0\0" + // external file attributes
  decToHex(extFileAttr, 4) + // relative offset of local header
  decToHex(offset, 4) + // file name
  encodedFileName + // extra field
  extraFields + // file comment
  encodedComment;
  return {
    fileRecord,
    dirRecord
  };
};
var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
  var dirEnd = "";
  var encodedComment = utils$s.transformTo("string", encodeFileName(comment));
  dirEnd = signature$1.CENTRAL_DIRECTORY_END + // number of this disk
  "\0\0\0\0" + // total number of entries in the central directory on this disk
  decToHex(entriesCount, 2) + // total number of entries in the central directory
  decToHex(entriesCount, 2) + // size of the central directory   4 bytes
  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
  decToHex(localDirLength, 4) + // .ZIP file comment length
  decToHex(encodedComment.length, 2) + // .ZIP file comment
  encodedComment;
  return dirEnd;
};
var generateDataDescriptors = function(streamInfo) {
  var descriptor = "";
  descriptor = signature$1.DATA_DESCRIPTOR + // crc-32                          4 bytes
  decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
  decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
  decToHex(streamInfo["uncompressedSize"], 4);
  return descriptor;
};
function ZipFileWorker$1(streamFiles, comment, platform2, encodeFileName) {
  GenericWorker$2.call(this, "ZipFileWorker");
  this.bytesWritten = 0;
  this.zipComment = comment;
  this.zipPlatform = platform2;
  this.encodeFileName = encodeFileName;
  this.streamFiles = streamFiles;
  this.accumulate = false;
  this.contentBuffer = [];
  this.dirRecords = [];
  this.currentSourceOffset = 0;
  this.entriesCount = 0;
  this.currentFile = null;
  this._sources = [];
}
utils$s.inherits(ZipFileWorker$1, GenericWorker$2);
ZipFileWorker$1.prototype.push = function(chunk) {
  var currentFilePercent = chunk.meta.percent || 0;
  var entriesCount = this.entriesCount;
  var remainingFiles = this._sources.length;
  if (this.accumulate) {
    this.contentBuffer.push(chunk);
  } else {
    this.bytesWritten += chunk.data.length;
    GenericWorker$2.prototype.push.call(this, {
      data: chunk.data,
      meta: {
        currentFile: this.currentFile,
        percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
      }
    });
  }
};
ZipFileWorker$1.prototype.openedSource = function(streamInfo) {
  this.currentSourceOffset = this.bytesWritten;
  this.currentFile = streamInfo["file"].name;
  var streamedContent = this.streamFiles && !streamInfo["file"].dir;
  if (streamedContent) {
    var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.push({
      data: record.fileRecord,
      meta: { percent: 0 }
    });
  } else {
    this.accumulate = true;
  }
};
ZipFileWorker$1.prototype.closedSource = function(streamInfo) {
  this.accumulate = false;
  var streamedContent = this.streamFiles && !streamInfo["file"].dir;
  var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
  this.dirRecords.push(record.dirRecord);
  if (streamedContent) {
    this.push({
      data: generateDataDescriptors(streamInfo),
      meta: { percent: 100 }
    });
  } else {
    this.push({
      data: record.fileRecord,
      meta: { percent: 0 }
    });
    while (this.contentBuffer.length) {
      this.push(this.contentBuffer.shift());
    }
  }
  this.currentFile = null;
};
ZipFileWorker$1.prototype.flush = function() {
  var localDirLength = this.bytesWritten;
  for (var i = 0; i < this.dirRecords.length; i++) {
    this.push({
      data: this.dirRecords[i],
      meta: { percent: 100 }
    });
  }
  var centralDirLength = this.bytesWritten - localDirLength;
  var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
  this.push({
    data: dirEnd,
    meta: { percent: 100 }
  });
};
ZipFileWorker$1.prototype.prepareNextSource = function() {
  this.previous = this._sources.shift();
  this.openedSource(this.previous.streamInfo);
  if (this.isPaused) {
    this.previous.pause();
  } else {
    this.previous.resume();
  }
};
ZipFileWorker$1.prototype.registerPrevious = function(previous) {
  this._sources.push(previous);
  var self2 = this;
  previous.on("data", function(chunk) {
    self2.processChunk(chunk);
  });
  previous.on("end", function() {
    self2.closedSource(self2.previous.streamInfo);
    if (self2._sources.length) {
      self2.prepareNextSource();
    } else {
      self2.end();
    }
  });
  previous.on("error", function(e) {
    self2.error(e);
  });
  return this;
};
ZipFileWorker$1.prototype.resume = function() {
  if (!GenericWorker$2.prototype.resume.call(this)) {
    return false;
  }
  if (!this.previous && this._sources.length) {
    this.prepareNextSource();
    return true;
  }
  if (!this.previous && !this._sources.length && !this.generatedError) {
    this.end();
    return true;
  }
};
ZipFileWorker$1.prototype.error = function(e) {
  var sources = this._sources;
  if (!GenericWorker$2.prototype.error.call(this, e)) {
    return false;
  }
  for (var i = 0; i < sources.length; i++) {
    try {
      sources[i].error(e);
    } catch (e2) {
    }
  }
  return true;
};
ZipFileWorker$1.prototype.lock = function() {
  GenericWorker$2.prototype.lock.call(this);
  var sources = this._sources;
  for (var i = 0; i < sources.length; i++) {
    sources[i].lock();
  }
};
var ZipFileWorker_1 = ZipFileWorker$1;
var compressions$1 = compressions$2;
var ZipFileWorker = ZipFileWorker_1;
var getCompression = function(fileCompression, zipCompression) {
  var compressionName = fileCompression || zipCompression;
  var compression = compressions$1[compressionName];
  if (!compression) {
    throw new Error(compressionName + " is not a valid compression method !");
  }
  return compression;
};
generate$1.generateWorker = function(zip2, options, comment) {
  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
  var entriesCount = 0;
  try {
    zip2.forEach(function(relativePath, file2) {
      entriesCount++;
      var compression = getCompression(file2.options.compression, options.compression);
      var compressionOptions = file2.options.compressionOptions || options.compressionOptions || {};
      var dir2 = file2.dir, date = file2.date;
      file2._compressWorker(compression, compressionOptions).withStreamInfo("file", {
        name: relativePath,
        dir: dir2,
        date,
        comment: file2.comment || "",
        unixPermissions: file2.unixPermissions,
        dosPermissions: file2.dosPermissions
      }).pipe(zipFileWorker);
    });
    zipFileWorker.entriesCount = entriesCount;
  } catch (e) {
    zipFileWorker.error(e);
  }
  return zipFileWorker;
};
var utils$r = requireUtils();
var GenericWorker$1 = GenericWorker_1;
function NodejsStreamInputAdapter$1(filename, stream2) {
  GenericWorker$1.call(this, "Nodejs stream input adapter for " + filename);
  this._upstreamEnded = false;
  this._bindStream(stream2);
}
utils$r.inherits(NodejsStreamInputAdapter$1, GenericWorker$1);
NodejsStreamInputAdapter$1.prototype._bindStream = function(stream2) {
  var self2 = this;
  this._stream = stream2;
  stream2.pause();
  stream2.on("data", function(chunk) {
    self2.push({
      data: chunk,
      meta: {
        percent: 0
      }
    });
  }).on("error", function(e) {
    if (self2.isPaused) {
      this.generatedError = e;
    } else {
      self2.error(e);
    }
  }).on("end", function() {
    if (self2.isPaused) {
      self2._upstreamEnded = true;
    } else {
      self2.end();
    }
  });
};
NodejsStreamInputAdapter$1.prototype.pause = function() {
  if (!GenericWorker$1.prototype.pause.call(this)) {
    return false;
  }
  this._stream.pause();
  return true;
};
NodejsStreamInputAdapter$1.prototype.resume = function() {
  if (!GenericWorker$1.prototype.resume.call(this)) {
    return false;
  }
  if (this._upstreamEnded) {
    this.end();
  } else {
    this._stream.resume();
  }
  return true;
};
var NodejsStreamInputAdapter_1 = NodejsStreamInputAdapter$1;
var utf8$2 = utf8$5;
var utils$q = requireUtils();
var GenericWorker = GenericWorker_1;
var StreamHelper = StreamHelper_1;
var defaults$4 = defaults$5;
var CompressedObject$1 = compressedObject;
var ZipObject = zipObject;
var generate = generate$1;
var nodejsUtils$1 = nodejsUtils$2;
var NodejsStreamInputAdapter = NodejsStreamInputAdapter_1;
var fileAdd = function(name, data, originalOptions) {
  var dataType = utils$q.getTypeOf(data), parent2;
  var o = utils$q.extend(originalOptions || {}, defaults$4);
  o.date = o.date || /* @__PURE__ */ new Date();
  if (o.compression !== null) {
    o.compression = o.compression.toUpperCase();
  }
  if (typeof o.unixPermissions === "string") {
    o.unixPermissions = parseInt(o.unixPermissions, 8);
  }
  if (o.unixPermissions && o.unixPermissions & 16384) {
    o.dir = true;
  }
  if (o.dosPermissions && o.dosPermissions & 16) {
    o.dir = true;
  }
  if (o.dir) {
    name = forceTrailingSlash(name);
  }
  if (o.createFolders && (parent2 = parentFolder(name))) {
    folderAdd.call(this, parent2, true);
  }
  var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
  if (!originalOptions || typeof originalOptions.binary === "undefined") {
    o.binary = !isUnicodeString;
  }
  var isCompressedEmpty = data instanceof CompressedObject$1 && data.uncompressedSize === 0;
  if (isCompressedEmpty || o.dir || !data || data.length === 0) {
    o.base64 = false;
    o.binary = true;
    data = "";
    o.compression = "STORE";
    dataType = "string";
  }
  var zipObjectContent = null;
  if (data instanceof CompressedObject$1 || data instanceof GenericWorker) {
    zipObjectContent = data;
  } else if (nodejsUtils$1.isNode && nodejsUtils$1.isStream(data)) {
    zipObjectContent = new NodejsStreamInputAdapter(name, data);
  } else {
    zipObjectContent = utils$q.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
  }
  var object2 = new ZipObject(name, zipObjectContent, o);
  this.files[name] = object2;
};
var parentFolder = function(path2) {
  if (path2.slice(-1) === "/") {
    path2 = path2.substring(0, path2.length - 1);
  }
  var lastSlash = path2.lastIndexOf("/");
  return lastSlash > 0 ? path2.substring(0, lastSlash) : "";
};
var forceTrailingSlash = function(path2) {
  if (path2.slice(-1) !== "/") {
    path2 += "/";
  }
  return path2;
};
var folderAdd = function(name, createFolders) {
  createFolders = typeof createFolders !== "undefined" ? createFolders : defaults$4.createFolders;
  name = forceTrailingSlash(name);
  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders
    });
  }
  return this.files[name];
};
function isRegExp(object2) {
  return Object.prototype.toString.call(object2) === "[object RegExp]";
}
var out = {
  /**
   * @see loadAsync
   */
  load: function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  },
  /**
   * Call a callback function for each entry at this folder level.
   * @param {Function} cb the callback function:
   * function (relativePath, file) {...}
   * It takes 2 arguments : the relative path and the file.
   */
  forEach: function(cb) {
    var filename, relativePath, file2;
    for (filename in this.files) {
      file2 = this.files[filename];
      relativePath = filename.slice(this.root.length, filename.length);
      if (relativePath && filename.slice(0, this.root.length) === this.root) {
        cb(relativePath, file2);
      }
    }
  },
  /**
   * Filter nested files/folders with the specified function.
   * @param {Function} search the predicate to use :
   * function (relativePath, file) {...}
   * It takes 2 arguments : the relative path and the file.
   * @return {Array} An array of matching elements.
   */
  filter: function(search) {
    var result = [];
    this.forEach(function(relativePath, entry) {
      if (search(relativePath, entry)) {
        result.push(entry);
      }
    });
    return result;
  },
  /**
   * Add a file to the zip file, or search a file.
   * @param   {string|RegExp} name The name of the file to add (if data is defined),
   * the name of the file to find (if no data) or a regex to match files.
   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
   * @param   {Object} o     File options
   * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
   * a file (when searching by string) or an array of files (when searching by regex).
   */
  file: function(name, data, o) {
    if (arguments.length === 1) {
      if (isRegExp(name)) {
        var regexp = name;
        return this.filter(function(relativePath, file2) {
          return !file2.dir && regexp.test(relativePath);
        });
      } else {
        var obj = this.files[this.root + name];
        if (obj && !obj.dir) {
          return obj;
        } else {
          return null;
        }
      }
    } else {
      name = this.root + name;
      fileAdd.call(this, name, data, o);
    }
    return this;
  },
  /**
   * Add a directory to the zip file, or search.
   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
   * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
   */
  folder: function(arg) {
    if (!arg) {
      return this;
    }
    if (isRegExp(arg)) {
      return this.filter(function(relativePath, file2) {
        return file2.dir && arg.test(relativePath);
      });
    }
    var name = this.root + arg;
    var newFolder = folderAdd.call(this, name);
    var ret = this.clone();
    ret.root = newFolder.name;
    return ret;
  },
  /**
   * Delete a file, or a directory and all sub-files, from the zip
   * @param {string} name the name of the file to delete
   * @return {JSZip} this JSZip object
   */
  remove: function(name) {
    name = this.root + name;
    var file2 = this.files[name];
    if (!file2) {
      if (name.slice(-1) !== "/") {
        name += "/";
      }
      file2 = this.files[name];
    }
    if (file2 && !file2.dir) {
      delete this.files[name];
    } else {
      var kids = this.filter(function(relativePath, file3) {
        return file3.name.slice(0, name.length) === name;
      });
      for (var i = 0; i < kids.length; i++) {
        delete this.files[kids[i].name];
      }
    }
    return this;
  },
  /**
   * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
   */
  generate: function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  },
  /**
   * Generate the complete zip file as an internal stream.
   * @param {Object} options the options to generate the zip file :
   * - compression, "STORE" by default.
   * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
   * @return {StreamHelper} the streamed zip file.
   */
  generateInternalStream: function(options) {
    var worker, opts = {};
    try {
      opts = utils$q.extend(options || {}, {
        streamFiles: false,
        compression: "STORE",
        compressionOptions: null,
        type: "",
        platform: "DOS",
        comment: null,
        mimeType: "application/zip",
        encodeFileName: utf8$2.utf8encode
      });
      opts.type = opts.type.toLowerCase();
      opts.compression = opts.compression.toUpperCase();
      if (opts.type === "binarystring") {
        opts.type = "string";
      }
      if (!opts.type) {
        throw new Error("No output type specified.");
      }
      utils$q.checkSupport(opts.type);
      if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
        opts.platform = "UNIX";
      }
      if (opts.platform === "win32") {
        opts.platform = "DOS";
      }
      var comment = opts.comment || this.comment || "";
      worker = generate.generateWorker(this, opts, comment);
    } catch (e) {
      worker = new GenericWorker("error");
      worker.error(e);
    }
    return new StreamHelper(worker, opts.type || "string", opts.mimeType);
  },
  /**
   * Generate the complete zip file asynchronously.
   * @see generateInternalStream
   */
  generateAsync: function(options, onUpdate) {
    return this.generateInternalStream(options).accumulate(onUpdate);
  },
  /**
   * Generate the complete zip file asynchronously.
   * @see generateInternalStream
   */
  generateNodeStream: function(options, onUpdate) {
    options = options || {};
    if (!options.type) {
      options.type = "nodebuffer";
    }
    return this.generateInternalStream(options).toNodejsStream(onUpdate);
  }
};
var object = out;
var utils$p = requireUtils();
function DataReader$2(data) {
  this.data = data;
  this.length = data.length;
  this.index = 0;
  this.zero = 0;
}
DataReader$2.prototype = {
  /**
   * Check that the offset will not go too far.
   * @param {string} offset the additional offset to check.
   * @throws {Error} an Error if the offset is out of bounds.
   */
  checkOffset: function(offset) {
    this.checkIndex(this.index + offset);
  },
  /**
   * Check that the specified index will not be too far.
   * @param {string} newIndex the index to check.
   * @throws {Error} an Error if the index is out of bounds.
   */
  checkIndex: function(newIndex) {
    if (this.length < this.zero + newIndex || newIndex < 0) {
      throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
    }
  },
  /**
   * Change the index.
   * @param {number} newIndex The new index.
   * @throws {Error} if the new index is out of the data.
   */
  setIndex: function(newIndex) {
    this.checkIndex(newIndex);
    this.index = newIndex;
  },
  /**
   * Skip the next n bytes.
   * @param {number} n the number of bytes to skip.
   * @throws {Error} if the new index is out of the data.
   */
  skip: function(n) {
    this.setIndex(this.index + n);
  },
  /**
   * Get the byte at the specified index.
   * @param {number} i the index to use.
   * @return {number} a byte.
   */
  byteAt: function() {
  },
  /**
   * Get the next number with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {number} the corresponding number.
   */
  readInt: function(size) {
    var result = 0, i;
    this.checkOffset(size);
    for (i = this.index + size - 1; i >= this.index; i--) {
      result = (result << 8) + this.byteAt(i);
    }
    this.index += size;
    return result;
  },
  /**
   * Get the next string with a given byte size.
   * @param {number} size the number of bytes to read.
   * @return {string} the corresponding string.
   */
  readString: function(size) {
    return utils$p.transformTo("string", this.readData(size));
  },
  /**
   * Get raw data without conversion, <size> bytes.
   * @param {number} size the number of bytes to read.
   * @return {Object} the raw data, implementation specific.
   */
  readData: function() {
  },
  /**
   * Find the last occurrence of a zip signature (4 bytes).
   * @param {string} sig the signature to find.
   * @return {number} the index of the last occurrence, -1 if not found.
   */
  lastIndexOfSignature: function() {
  },
  /**
   * Read the signature (4 bytes) at the current position and compare it with sig.
   * @param {string} sig the expected signature
   * @return {boolean} true if the signature matches, false otherwise.
   */
  readAndCheckSignature: function() {
  },
  /**
   * Get the next date.
   * @return {Date} the date.
   */
  readDate: function() {
    var dostime = this.readInt(4);
    return new Date(Date.UTC(
      (dostime >> 25 & 127) + 1980,
      // year
      (dostime >> 21 & 15) - 1,
      // month
      dostime >> 16 & 31,
      // day
      dostime >> 11 & 31,
      // hour
      dostime >> 5 & 63,
      // minute
      (dostime & 31) << 1
    ));
  }
};
var DataReader_1 = DataReader$2;
var DataReader$1 = DataReader_1;
var utils$o = requireUtils();
function ArrayReader$2(data) {
  DataReader$1.call(this, data);
  for (var i = 0; i < this.data.length; i++) {
    data[i] = data[i] & 255;
  }
}
utils$o.inherits(ArrayReader$2, DataReader$1);
ArrayReader$2.prototype.byteAt = function(i) {
  return this.data[this.zero + i];
};
ArrayReader$2.prototype.lastIndexOfSignature = function(sig2) {
  var sig0 = sig2.charCodeAt(0), sig1 = sig2.charCodeAt(1), sig22 = sig2.charCodeAt(2), sig3 = sig2.charCodeAt(3);
  for (var i = this.length - 4; i >= 0; --i) {
    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig22 && this.data[i + 3] === sig3) {
      return i - this.zero;
    }
  }
  return -1;
};
ArrayReader$2.prototype.readAndCheckSignature = function(sig2) {
  var sig0 = sig2.charCodeAt(0), sig1 = sig2.charCodeAt(1), sig22 = sig2.charCodeAt(2), sig3 = sig2.charCodeAt(3), data = this.readData(4);
  return sig0 === data[0] && sig1 === data[1] && sig22 === data[2] && sig3 === data[3];
};
ArrayReader$2.prototype.readData = function(size) {
  this.checkOffset(size);
  if (size === 0) {
    return [];
  }
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
var ArrayReader_1 = ArrayReader$2;
var DataReader = DataReader_1;
var utils$n = requireUtils();
function StringReader$1(data) {
  DataReader.call(this, data);
}
utils$n.inherits(StringReader$1, DataReader);
StringReader$1.prototype.byteAt = function(i) {
  return this.data.charCodeAt(this.zero + i);
};
StringReader$1.prototype.lastIndexOfSignature = function(sig2) {
  return this.data.lastIndexOf(sig2) - this.zero;
};
StringReader$1.prototype.readAndCheckSignature = function(sig2) {
  var data = this.readData(4);
  return sig2 === data;
};
StringReader$1.prototype.readData = function(size) {
  this.checkOffset(size);
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
var StringReader_1 = StringReader$1;
var ArrayReader$1 = ArrayReader_1;
var utils$m = requireUtils();
function Uint8ArrayReader$2(data) {
  ArrayReader$1.call(this, data);
}
utils$m.inherits(Uint8ArrayReader$2, ArrayReader$1);
Uint8ArrayReader$2.prototype.readData = function(size) {
  this.checkOffset(size);
  if (size === 0) {
    return new Uint8Array(0);
  }
  var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
var Uint8ArrayReader_1 = Uint8ArrayReader$2;
var Uint8ArrayReader$1 = Uint8ArrayReader_1;
var utils$l = requireUtils();
function NodeBufferReader$1(data) {
  Uint8ArrayReader$1.call(this, data);
}
utils$l.inherits(NodeBufferReader$1, Uint8ArrayReader$1);
NodeBufferReader$1.prototype.readData = function(size) {
  this.checkOffset(size);
  var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
  this.index += size;
  return result;
};
var NodeBufferReader_1 = NodeBufferReader$1;
var utils$k = requireUtils();
var support$2 = support$4;
var ArrayReader = ArrayReader_1;
var StringReader = StringReader_1;
var NodeBufferReader = NodeBufferReader_1;
var Uint8ArrayReader = Uint8ArrayReader_1;
var readerFor$2 = function(data) {
  var type = utils$k.getTypeOf(data);
  utils$k.checkSupport(type);
  if (type === "string" && !support$2.uint8array) {
    return new StringReader(data);
  }
  if (type === "nodebuffer") {
    return new NodeBufferReader(data);
  }
  if (support$2.uint8array) {
    return new Uint8ArrayReader(utils$k.transformTo("uint8array", data));
  }
  return new ArrayReader(utils$k.transformTo("array", data));
};
var readerFor$1 = readerFor$2;
var utils$j = requireUtils();
var CompressedObject = compressedObject;
var crc32fn = crc32_1$1;
var utf8$1 = utf8$5;
var compressions = compressions$2;
var support$1 = support$4;
var MADE_BY_DOS = 0;
var MADE_BY_UNIX = 3;
var findCompression = function(compressionMethod) {
  for (var method2 in compressions) {
    if (!Object.prototype.hasOwnProperty.call(compressions, method2)) {
      continue;
    }
    if (compressions[method2].magic === compressionMethod) {
      return compressions[method2];
    }
  }
  return null;
};
function ZipEntry$1(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
}
ZipEntry$1.prototype = {
  /**
   * say if the file is encrypted.
   * @return {boolean} true if the file is encrypted, false otherwise.
   */
  isEncrypted: function() {
    return (this.bitFlag & 1) === 1;
  },
  /**
   * say if the file has utf-8 filename/comment.
   * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
   */
  useUTF8: function() {
    return (this.bitFlag & 2048) === 2048;
  },
  /**
   * Read the local part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readLocalPart: function(reader2) {
    var compression, localExtraFieldsLength;
    reader2.skip(22);
    this.fileNameLength = reader2.readInt(2);
    localExtraFieldsLength = reader2.readInt(2);
    this.fileName = reader2.readData(this.fileNameLength);
    reader2.skip(localExtraFieldsLength);
    if (this.compressedSize === -1 || this.uncompressedSize === -1) {
      throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
    }
    compression = findCompression(this.compressionMethod);
    if (compression === null) {
      throw new Error("Corrupted zip : compression " + utils$j.pretty(this.compressionMethod) + " unknown (inner file : " + utils$j.transformTo("string", this.fileName) + ")");
    }
    this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader2.readData(this.compressedSize));
  },
  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readCentralPart: function(reader2) {
    this.versionMadeBy = reader2.readInt(2);
    reader2.skip(2);
    this.bitFlag = reader2.readInt(2);
    this.compressionMethod = reader2.readString(2);
    this.date = reader2.readDate();
    this.crc32 = reader2.readInt(4);
    this.compressedSize = reader2.readInt(4);
    this.uncompressedSize = reader2.readInt(4);
    var fileNameLength = reader2.readInt(2);
    this.extraFieldsLength = reader2.readInt(2);
    this.fileCommentLength = reader2.readInt(2);
    this.diskNumberStart = reader2.readInt(2);
    this.internalFileAttributes = reader2.readInt(2);
    this.externalFileAttributes = reader2.readInt(4);
    this.localHeaderOffset = reader2.readInt(4);
    if (this.isEncrypted()) {
      throw new Error("Encrypted zip are not supported");
    }
    reader2.skip(fileNameLength);
    this.readExtraFields(reader2);
    this.parseZIP64ExtraField(reader2);
    this.fileComment = reader2.readData(this.fileCommentLength);
  },
  /**
   * Parse the external file attributes and get the unix/dos permissions.
   */
  processAttributes: function() {
    this.unixPermissions = null;
    this.dosPermissions = null;
    var madeBy = this.versionMadeBy >> 8;
    this.dir = this.externalFileAttributes & 16 ? true : false;
    if (madeBy === MADE_BY_DOS) {
      this.dosPermissions = this.externalFileAttributes & 63;
    }
    if (madeBy === MADE_BY_UNIX) {
      this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
    }
    if (!this.dir && this.fileNameStr.slice(-1) === "/") {
      this.dir = true;
    }
  },
  /**
   * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
   * @param {DataReader} reader the reader to use.
   */
  parseZIP64ExtraField: function() {
    if (!this.extraFields[1]) {
      return;
    }
    var extraReader = readerFor$1(this.extraFields[1].value);
    if (this.uncompressedSize === utils$j.MAX_VALUE_32BITS) {
      this.uncompressedSize = extraReader.readInt(8);
    }
    if (this.compressedSize === utils$j.MAX_VALUE_32BITS) {
      this.compressedSize = extraReader.readInt(8);
    }
    if (this.localHeaderOffset === utils$j.MAX_VALUE_32BITS) {
      this.localHeaderOffset = extraReader.readInt(8);
    }
    if (this.diskNumberStart === utils$j.MAX_VALUE_32BITS) {
      this.diskNumberStart = extraReader.readInt(4);
    }
  },
  /**
   * Read the central part of a zip file and add the info in this object.
   * @param {DataReader} reader the reader to use.
   */
  readExtraFields: function(reader2) {
    var end2 = reader2.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
    if (!this.extraFields) {
      this.extraFields = {};
    }
    while (reader2.index + 4 < end2) {
      extraFieldId = reader2.readInt(2);
      extraFieldLength = reader2.readInt(2);
      extraFieldValue = reader2.readData(extraFieldLength);
      this.extraFields[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
    reader2.setIndex(end2);
  },
  /**
   * Apply an UTF8 transformation if needed.
   */
  handleUTF8: function() {
    var decodeParamType = support$1.uint8array ? "uint8array" : "array";
    if (this.useUTF8()) {
      this.fileNameStr = utf8$1.utf8decode(this.fileName);
      this.fileCommentStr = utf8$1.utf8decode(this.fileComment);
    } else {
      var upath = this.findExtraFieldUnicodePath();
      if (upath !== null) {
        this.fileNameStr = upath;
      } else {
        var fileNameByteArray = utils$j.transformTo(decodeParamType, this.fileName);
        this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
      }
      var ucomment = this.findExtraFieldUnicodeComment();
      if (ucomment !== null) {
        this.fileCommentStr = ucomment;
      } else {
        var commentByteArray = utils$j.transformTo(decodeParamType, this.fileComment);
        this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
      }
    }
  },
  /**
   * Find the unicode path declared in the extra field, if any.
   * @return {String} the unicode path, null otherwise.
   */
  findExtraFieldUnicodePath: function() {
    var upathField = this.extraFields[28789];
    if (upathField) {
      var extraReader = readerFor$1(upathField.value);
      if (extraReader.readInt(1) !== 1) {
        return null;
      }
      if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
        return null;
      }
      return utf8$1.utf8decode(extraReader.readData(upathField.length - 5));
    }
    return null;
  },
  /**
   * Find the unicode comment declared in the extra field, if any.
   * @return {String} the unicode comment, null otherwise.
   */
  findExtraFieldUnicodeComment: function() {
    var ucommentField = this.extraFields[25461];
    if (ucommentField) {
      var extraReader = readerFor$1(ucommentField.value);
      if (extraReader.readInt(1) !== 1) {
        return null;
      }
      if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
        return null;
      }
      return utf8$1.utf8decode(extraReader.readData(ucommentField.length - 5));
    }
    return null;
  }
};
var zipEntry = ZipEntry$1;
var readerFor = readerFor$2;
var utils$i = requireUtils();
var sig = signature$2;
var ZipEntry = zipEntry;
var support = support$4;
function ZipEntries$1(loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
}
ZipEntries$1.prototype = {
  /**
   * Check that the reader is on the specified signature.
   * @param {string} expectedSignature the expected signature.
   * @throws {Error} if it is an other signature.
   */
  checkSignature: function(expectedSignature) {
    if (!this.reader.readAndCheckSignature(expectedSignature)) {
      this.reader.index -= 4;
      var signature2 = this.reader.readString(4);
      throw new Error("Corrupted zip or bug: unexpected signature (" + utils$i.pretty(signature2) + ", expected " + utils$i.pretty(expectedSignature) + ")");
    }
  },
  /**
   * Check if the given signature is at the given index.
   * @param {number} askedIndex the index to check.
   * @param {string} expectedSignature the signature to expect.
   * @return {boolean} true if the signature is here, false otherwise.
   */
  isSignature: function(askedIndex, expectedSignature) {
    var currentIndex = this.reader.index;
    this.reader.setIndex(askedIndex);
    var signature2 = this.reader.readString(4);
    var result = signature2 === expectedSignature;
    this.reader.setIndex(currentIndex);
    return result;
  },
  /**
   * Read the end of the central directory.
   */
  readBlockEndOfCentral: function() {
    this.diskNumber = this.reader.readInt(2);
    this.diskWithCentralDirStart = this.reader.readInt(2);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
    this.centralDirRecords = this.reader.readInt(2);
    this.centralDirSize = this.reader.readInt(4);
    this.centralDirOffset = this.reader.readInt(4);
    this.zipCommentLength = this.reader.readInt(2);
    var zipComment = this.reader.readData(this.zipCommentLength);
    var decodeParamType = support.uint8array ? "uint8array" : "array";
    var decodeContent = utils$i.transformTo(decodeParamType, zipComment);
    this.zipComment = this.loadOptions.decodeFileName(decodeContent);
  },
  /**
   * Read the end of the Zip 64 central directory.
   * Not merged with the method readEndOfCentral :
   * The end of central can coexist with its Zip64 brother,
   * I don't want to read the wrong number of bytes !
   */
  readBlockZip64EndOfCentral: function() {
    this.zip64EndOfCentralSize = this.reader.readInt(8);
    this.reader.skip(4);
    this.diskNumber = this.reader.readInt(4);
    this.diskWithCentralDirStart = this.reader.readInt(4);
    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
    this.centralDirRecords = this.reader.readInt(8);
    this.centralDirSize = this.reader.readInt(8);
    this.centralDirOffset = this.reader.readInt(8);
    this.zip64ExtensibleData = {};
    var extraDataSize = this.zip64EndOfCentralSize - 44, index2 = 0, extraFieldId, extraFieldLength, extraFieldValue;
    while (index2 < extraDataSize) {
      extraFieldId = this.reader.readInt(2);
      extraFieldLength = this.reader.readInt(4);
      extraFieldValue = this.reader.readData(extraFieldLength);
      this.zip64ExtensibleData[extraFieldId] = {
        id: extraFieldId,
        length: extraFieldLength,
        value: extraFieldValue
      };
    }
  },
  /**
   * Read the end of the Zip 64 central directory locator.
   */
  readBlockZip64EndOfCentralLocator: function() {
    this.diskWithZip64CentralDirStart = this.reader.readInt(4);
    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
    this.disksCount = this.reader.readInt(4);
    if (this.disksCount > 1) {
      throw new Error("Multi-volumes zip are not supported");
    }
  },
  /**
   * Read the local files, based on the offset read in the central part.
   */
  readLocalFiles: function() {
    var i, file2;
    for (i = 0; i < this.files.length; i++) {
      file2 = this.files[i];
      this.reader.setIndex(file2.localHeaderOffset);
      this.checkSignature(sig.LOCAL_FILE_HEADER);
      file2.readLocalPart(this.reader);
      file2.handleUTF8();
      file2.processAttributes();
    }
  },
  /**
   * Read the central directory.
   */
  readCentralDir: function() {
    var file2;
    this.reader.setIndex(this.centralDirOffset);
    while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
      file2 = new ZipEntry({
        zip64: this.zip64
      }, this.loadOptions);
      file2.readCentralPart(this.reader);
      this.files.push(file2);
    }
    if (this.centralDirRecords !== this.files.length) {
      if (this.centralDirRecords !== 0 && this.files.length === 0) {
        throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }
    }
  },
  /**
   * Read the end of central directory.
   */
  readEndOfCentral: function() {
    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
    if (offset < 0) {
      var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
      if (isGarbage) {
        throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
      } else {
        throw new Error("Corrupted zip: can't find end of central directory");
      }
    }
    this.reader.setIndex(offset);
    var endOfCentralDirOffset = offset;
    this.checkSignature(sig.CENTRAL_DIRECTORY_END);
    this.readBlockEndOfCentral();
    if (this.diskNumber === utils$i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils$i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils$i.MAX_VALUE_16BITS || this.centralDirRecords === utils$i.MAX_VALUE_16BITS || this.centralDirSize === utils$i.MAX_VALUE_32BITS || this.centralDirOffset === utils$i.MAX_VALUE_32BITS) {
      this.zip64 = true;
      offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
      if (offset < 0) {
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
      }
      this.reader.setIndex(offset);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
      this.readBlockZip64EndOfCentralLocator();
      if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
        this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        if (this.relativeOffsetEndOfZip64CentralDir < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
        }
      }
      this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
      this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
      this.readBlockZip64EndOfCentral();
    }
    var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
    if (this.zip64) {
      expectedEndOfCentralDirOffset += 20;
      expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
    }
    var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
    if (extraBytes > 0) {
      if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) ;
      else {
        this.reader.zero = extraBytes;
      }
    } else if (extraBytes < 0) {
      throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
    }
  },
  prepareReader: function(data) {
    this.reader = readerFor(data);
  },
  /**
   * Read a zip file and create ZipEntries.
   * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
   */
  load: function(data) {
    this.prepareReader(data);
    this.readEndOfCentral();
    this.readCentralDir();
    this.readLocalFiles();
  }
};
var zipEntries = ZipEntries$1;
var utils$h = requireUtils();
var external = external$3;
var utf8 = utf8$5;
var ZipEntries = zipEntries;
var Crc32Probe = Crc32Probe_1;
var nodejsUtils = nodejsUtils$2;
function checkEntryCRC32(zipEntry2) {
  return new external.Promise(function(resolve2, reject2) {
    var worker = zipEntry2.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function(e) {
      reject2(e);
    }).on("end", function() {
      if (worker.streamInfo.crc32 !== zipEntry2.decompressed.crc32) {
        reject2(new Error("Corrupted zip : CRC32 mismatch"));
      } else {
        resolve2();
      }
    }).resume();
  });
}
var load = function(data, options) {
  var zip2 = this;
  options = utils$h.extend(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8.utf8decode
  });
  if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
    return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
  }
  return utils$h.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
    var zipEntries2 = new ZipEntries(options);
    zipEntries2.load(data2);
    return zipEntries2;
  }).then(function checkCRC32(zipEntries2) {
    var promises = [external.Promise.resolve(zipEntries2)];
    var files = zipEntries2.files;
    if (options.checkCRC32) {
      for (var i = 0; i < files.length; i++) {
        promises.push(checkEntryCRC32(files[i]));
      }
    }
    return external.Promise.all(promises);
  }).then(function addFiles(results) {
    var zipEntries2 = results.shift();
    var files = zipEntries2.files;
    for (var i = 0; i < files.length; i++) {
      var input = files[i];
      var unsafeName = input.fileNameStr;
      var safeName = utils$h.resolve(input.fileNameStr);
      zip2.file(safeName, input.decompressed, {
        binary: true,
        optimizedBinaryString: true,
        date: input.date,
        dir: input.dir,
        comment: input.fileCommentStr.length ? input.fileCommentStr : null,
        unixPermissions: input.unixPermissions,
        dosPermissions: input.dosPermissions,
        createFolders: options.createFolders
      });
      if (!input.dir) {
        zip2.file(safeName).unsafeOriginalName = unsafeName;
      }
    }
    if (zipEntries2.zipComment.length) {
      zip2.comment = zipEntries2.zipComment;
    }
    return zip2;
  });
};
function JSZip$2() {
  if (!(this instanceof JSZip$2)) {
    return new JSZip$2();
  }
  if (arguments.length) {
    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
  }
  this.files = /* @__PURE__ */ Object.create(null);
  this.comment = null;
  this.root = "";
  this.clone = function() {
    var newObj = new JSZip$2();
    for (var i in this) {
      if (typeof this[i] !== "function") {
        newObj[i] = this[i];
      }
    }
    return newObj;
  };
}
JSZip$2.prototype = object;
JSZip$2.prototype.loadAsync = load;
JSZip$2.support = support$4;
JSZip$2.defaults = defaults$5;
JSZip$2.version = "3.10.1";
JSZip$2.loadAsync = function(content, options) {
  return new JSZip$2().loadAsync(content, options);
};
JSZip$2.external = external$3;
var lib$1 = JSZip$2;
var readable$4 = { exports: {} };
var stream$6;
var hasRequiredStream$4;
function requireStream$4() {
  if (hasRequiredStream$4) return stream$6;
  hasRequiredStream$4 = 1;
  stream$6 = require$$0$1;
  return stream$6;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = require$$0$3, Buffer2 = _require.Buffer;
  var _require2 = require$$0$4, inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList2, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume2(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c2 = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c2 = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
var destroy_1$4;
var hasRequiredDestroy$4;
function requireDestroy$4() {
  if (hasRequiredDestroy$4) return destroy_1$4;
  hasRequiredDestroy$4 = 1;
  function destroy(err2, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err2);
      } else if (err2) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err2);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err2);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err2 || null, function(err3) {
      if (!cb && err3) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err3);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err3);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err3);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err2) {
    emitErrorNT(self2, err2);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err2) {
    self2.emit("error", err2);
  }
  function errorOrDestroy(stream2, err2) {
    var rState = stream2._readableState;
    var wState = stream2._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err2);
    else stream2.emit("error", err2);
  }
  destroy_1$4 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1$4;
}
var errors$1 = {};
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg2;
    if (endsWith(name, " argument")) {
      msg2 = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg2 = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg2 += `. Received type ${typeof actual}`;
    return msg2;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errors$1.codes = codes;
  return errors$1;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrors$1().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var _stream_writable$4;
var hasRequired_stream_writable$4;
function require_stream_writable$4() {
  if (hasRequired_stream_writable$4) return _stream_writable$4;
  hasRequired_stream_writable$4 = 1;
  _stream_writable$4 = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable2.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream$4();
  var Buffer2 = require$$0$3.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$4();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors$1().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits()(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex$4();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function value(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable2) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object2) {
      return object2 instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex$4();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable2, this)) return new Writable2(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream2, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream2, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync3) {
        process.nextTick(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable2.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err2) {
      state2.pendingcb--;
      if (err2) {
        errorOrDestroy(stream2, err2);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) process.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err2) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set2(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err2, cb) {
    cb(err2);
  };
  return _stream_writable$4;
}
var _stream_duplex$4;
var hasRequired_stream_duplex$4;
function require_stream_duplex$4() {
  if (hasRequired_stream_duplex$4) return _stream_duplex$4;
  hasRequired_stream_duplex$4 = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) keys2.push(key);
    return keys2;
  };
  _stream_duplex$4 = Duplex;
  var Readable2 = require_stream_readable$4();
  var Writable2 = require_stream_writable$4();
  requireInherits()(Duplex, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable2.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set2(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex$4;
}
var string_decoder$4 = {};
var safeBuffer$4 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$4;
function requireSafeBuffer$4() {
  if (hasRequiredSafeBuffer$4) return safeBuffer$4.exports;
  hasRequiredSafeBuffer$4 = 1;
  (function(module, exports) {
    var buffer = require$$0$3;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$4, safeBuffer$4.exports);
  return safeBuffer$4.exports;
}
var hasRequiredString_decoder$4;
function requireString_decoder$4() {
  if (hasRequiredString_decoder$4) return string_decoder$4;
  hasRequiredString_decoder$4 = 1;
  var Buffer2 = requireSafeBuffer$4().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$4.StringDecoder = StringDecoder2;
  function StringDecoder2(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder2.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder2.prototype.end = utf8End;
  StringDecoder2.prototype.text = utf8Text;
  StringDecoder2.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$4;
}
var endOfStream$1;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream$1;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrors$1().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function eos2(stream2, opts, callback) {
    if (typeof opts === "function") return eos2(stream2, null, opts);
    if (!opts) opts = {};
    callback = once2(callback || noop2);
    var readable2 = opts.readable || opts.readable !== false && stream2.readable;
    var writable = opts.writable || opts.writable !== false && stream2.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream2.writable) onfinish();
    };
    var writableEnded = stream2._writableState && stream2._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable2) callback.call(stream2);
    };
    var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
    var onend = function onend2() {
      readable2 = false;
      readableEnded = true;
      if (!writable) callback.call(stream2);
    };
    var onerror = function onerror2(err2) {
      callback.call(stream2, err2);
    };
    var onclose = function onclose2() {
      var err2;
      if (readable2 && !readableEnded) {
        if (!stream2._readableState || !stream2._readableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err2);
      }
      if (writable && !writableEnded) {
        if (!stream2._writableState || !stream2._writableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err2);
      }
    };
    var onrequest = function onrequest2() {
      stream2.req.on("finish", onfinish);
    };
    if (isRequest2(stream2)) {
      stream2.on("complete", onfinish);
      stream2.on("abort", onclose);
      if (stream2.req) onrequest();
      else stream2.on("request", onrequest);
    } else if (writable && !stream2._writableState) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (opts.error !== false) stream2.on("error", onerror);
    stream2.on("close", onclose);
    return function() {
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req) stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    };
  }
  endOfStream$1 = eos2;
  return endOfStream$1;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve2(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve2, reject2) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve2, reject2);
      }, reject2);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error2 = this[kError];
      if (error2 !== null) {
        return Promise.reject(error2);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve2, reject2) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject2(_this[kError]);
            } else {
              resolve2(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve2, reject2) {
      _this2[kStream].destroy(null, function(err2) {
        if (err2) {
          reject2(err2);
          return;
        }
        resolve2(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve2, reject2) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve2;
          iterator[kLastReject] = reject2;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err2) {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject2 = iterator[kLastReject];
        if (reject2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject2(err2);
        }
        iterator[kError] = err2;
        return;
      }
      var resolve2 = iterator[kLastResolve];
      if (resolve2 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve2(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var from_1;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from_1;
  hasRequiredFrom = 1;
  function asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error2) {
      reject2(error2);
      return;
    }
    if (info.done) {
      resolve2(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve2, reject2) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "next", value);
        }
        function _throw(err2) {
          asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "throw", err2);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ERR_INVALID_ARG_TYPE = requireErrors$1().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable2, iterable, opts) {
    var iterator;
    if (iterable && typeof iterable.next === "function") {
      iterator = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable2 = new Readable2(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable2._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable2.push(null);
          } else if (readable2.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err2) {
          readable2.destroy(err2);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable2;
  }
  from_1 = from;
  return from_1;
}
var _stream_readable$4;
var hasRequired_stream_readable$4;
function require_stream_readable$4() {
  if (hasRequired_stream_readable$4) return _stream_readable$4;
  hasRequired_stream_readable$4 = 1;
  _stream_readable$4 = Readable2;
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = requireStream$4();
  var Buffer2 = require$$0$3.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$0$4;
  var debug2;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function debug3() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = requireDestroy$4();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors$1().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder2;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits()(Readable2, Stream2);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex$4();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2) StringDecoder2 = requireString_decoder$4().StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$4();
    if (!(this instanceof Readable2)) return new Readable2(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set2(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err2, cb) {
    cb(err2);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug2("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream2, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream2, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder2) StringDecoder2 = requireString_decoder$4().StringDecoder;
    var decoder = new StringDecoder2(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug2("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      var ret = dest.write(chunk);
      debug2("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug2("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream2.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    debug2("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) ;
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function methodWrap(method2) {
          return function methodWrapReturnFunction() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.flowing;
    },
    set: function set2(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get3() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug2("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    debug2("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state2.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFrom();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$4;
}
var _stream_transform$4;
var hasRequired_stream_transform$4;
function require_stream_transform$4() {
  if (hasRequired_stream_transform$4) return _stream_transform$4;
  hasRequired_stream_transform$4 = 1;
  _stream_transform$4 = Transform2;
  var _require$codes = requireErrors$1().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex$4();
  requireInherits()(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err2, cb) {
    Duplex.prototype._destroy.call(this, err2, function(err22) {
      cb(err22);
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream2.push(null);
  }
  return _stream_transform$4;
}
var _stream_passthrough$4;
var hasRequired_stream_passthrough$4;
function require_stream_passthrough$4() {
  if (hasRequired_stream_passthrough$4) return _stream_passthrough$4;
  hasRequired_stream_passthrough$4 = 1;
  _stream_passthrough$4 = PassThrough2;
  var Transform2 = require_stream_transform$4();
  requireInherits()(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$4;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos2;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrors$1().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err2) {
    if (err2) throw err2;
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function destroyer(stream2, reading, writing, callback) {
    callback = once2(callback);
    var closed = false;
    stream2.on("close", function() {
      closed = true;
    });
    if (eos2 === void 0) eos2 = requireEndOfStream();
    eos2(stream2, {
      readable: reading,
      writable: writing
    }, function(err2) {
      if (err2) return callback(err2);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err2) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest2(stream2)) return stream2.abort();
      if (typeof stream2.destroy === "function") return stream2.destroy();
      callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error2;
    var destroys = streams.map(function(stream2, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream2, reading, writing, function(err2) {
        if (!error2) error2 = err2;
        if (err2) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error2);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
(function(module, exports) {
  var Stream2 = require$$0$1;
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module.exports = Stream2.Readable;
    Object.assign(module.exports, Stream2);
    module.exports.Stream = Stream2;
  } else {
    exports = module.exports = require_stream_readable$4();
    exports.Stream = Stream2 || exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable$4();
    exports.Duplex = require_stream_duplex$4();
    exports.Transform = require_stream_transform$4();
    exports.PassThrough = require_stream_passthrough$4();
    exports.finished = requireEndOfStream();
    exports.pipeline = requirePipeline();
  }
})(readable$4, readable$4.exports);
var readableExports$3 = readable$4.exports;
const fs$h = require$$0$2;
const inherits$9 = function(cls, superCtor, statics, prototype) {
  cls.super_ = superCtor;
  if (!prototype) {
    prototype = statics;
    statics = null;
  }
  if (statics) {
    Object.keys(statics).forEach((i) => {
      Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));
    });
  }
  const properties = {
    constructor: {
      value: cls,
      enumerable: false,
      writable: false,
      configurable: true
    }
  };
  if (prototype) {
    Object.keys(prototype).forEach((i) => {
      properties[i] = Object.getOwnPropertyDescriptor(prototype, i);
    });
  }
  cls.prototype = Object.create(superCtor.prototype, properties);
};
const xmlDecodeRegex = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/;
const utils$g = {
  nop() {
  },
  promiseImmediate(value) {
    return new Promise((resolve2) => {
      if (commonjsGlobal.setImmediate) {
        setImmediate(() => {
          resolve2(value);
        });
      } else {
        setTimeout(() => {
          resolve2(value);
        }, 1);
      }
    });
  },
  inherits: inherits$9,
  dateToExcel(d, date1904) {
    return 25569 + d.getTime() / (24 * 3600 * 1e3) - (date1904 ? 1462 : 0);
  },
  excelToDate(v, date1904) {
    const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1e3);
    return new Date(millisecondSinceEpoch);
  },
  parsePath(filepath) {
    const last = filepath.lastIndexOf("/");
    return {
      path: filepath.substring(0, last),
      name: filepath.substring(last + 1)
    };
  },
  getRelsPath(filepath) {
    const path2 = utils$g.parsePath(filepath);
    return `${path2.path}/_rels/${path2.name}.rels`;
  },
  xmlEncode(text) {
    const regexResult = xmlDecodeRegex.exec(text);
    if (!regexResult) return text;
    let result = "";
    let escape = "";
    let lastIndex = 0;
    let i = regexResult.index;
    for (; i < text.length; i++) {
      const charCode = text.charCodeAt(i);
      switch (charCode) {
        case 34:
          escape = "&quot;";
          break;
        case 38:
          escape = "&amp;";
          break;
        case 39:
          escape = "&apos;";
          break;
        case 60:
          escape = "&lt;";
          break;
        case 62:
          escape = "&gt;";
          break;
        case 127:
          escape = "";
          break;
        default: {
          if (charCode <= 31 && (charCode <= 8 || charCode >= 11 && charCode !== 13)) {
            escape = "";
            break;
          }
          continue;
        }
      }
      if (lastIndex !== i) result += text.substring(lastIndex, i);
      lastIndex = i + 1;
      if (escape) result += escape;
    }
    if (lastIndex !== i) return result + text.substring(lastIndex, i);
    return result;
  },
  xmlDecode(text) {
    return text.replace(/&([a-z]*);/g, (c2) => {
      switch (c2) {
        case "&lt;":
          return "<";
        case "&gt;":
          return ">";
        case "&amp;":
          return "&";
        case "&apos;":
          return "'";
        case "&quot;":
          return '"';
        default:
          return c2;
      }
    });
  },
  validInt(value) {
    const i = parseInt(value, 10);
    return !Number.isNaN(i) ? i : 0;
  },
  isDateFmt(fmt) {
    if (!fmt) {
      return false;
    }
    fmt = fmt.replace(/\[[^\]]*]/g, "");
    fmt = fmt.replace(/"[^"]*"/g, "");
    const result = fmt.match(/[ymdhMsb]+/) !== null;
    return result;
  },
  fs: {
    exists(path2) {
      return new Promise((resolve2) => {
        fs$h.access(path2, fs$h.constants.F_OK, (err2) => {
          resolve2(!err2);
        });
      });
    }
  },
  toIsoDateString(dt) {
    return dt.toIsoString().subsstr(0, 10);
  },
  parseBoolean(value) {
    return value === true || value === "true" || value === 1 || value === "1";
  }
};
var utils_1 = utils$g;
let StringBuf$2 = class StringBuf {
  constructor(options) {
    this._buf = Buffer.alloc(options && options.size || 16384);
    this._encoding = options && options.encoding || "utf8";
    this._inPos = 0;
    this._buffer = void 0;
  }
  get length() {
    return this._inPos;
  }
  get capacity() {
    return this._buf.length;
  }
  get buffer() {
    return this._buf;
  }
  toBuffer() {
    if (!this._buffer) {
      this._buffer = Buffer.alloc(this.length);
      this._buf.copy(this._buffer, 0, 0, this.length);
    }
    return this._buffer;
  }
  reset(position) {
    position = position || 0;
    this._buffer = void 0;
    this._inPos = position;
  }
  _grow(min) {
    let size = this._buf.length * 2;
    while (size < min) {
      size *= 2;
    }
    const buf = Buffer.alloc(size);
    this._buf.copy(buf, 0);
    this._buf = buf;
  }
  addText(text) {
    this._buffer = void 0;
    let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
    while (inPos >= this._buf.length - 4) {
      this._grow(this._inPos + text.length);
      inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
    }
    this._inPos = inPos;
  }
  addStringBuf(inBuf) {
    if (inBuf.length) {
      this._buffer = void 0;
      if (this.length + inBuf.length > this.capacity) {
        this._grow(this.length + inBuf.length);
      }
      inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);
      this._inPos += inBuf.length;
    }
  }
};
var stringBuf = StringBuf$2;
const Stream$d = readableExports$3;
const utils$f = utils_1;
const StringBuf$1 = stringBuf;
class StringChunk {
  constructor(data, encoding) {
    this._data = data;
    this._encoding = encoding;
  }
  get length() {
    return this.toBuffer().length;
  }
  // copy to target buffer
  copy(target, targetOffset, offset, length) {
    return this.toBuffer().copy(target, targetOffset, offset, length);
  }
  toBuffer() {
    if (!this._buffer) {
      this._buffer = Buffer.from(this._data, this._encoding);
    }
    return this._buffer;
  }
}
class StringBufChunk {
  constructor(data) {
    this._data = data;
  }
  get length() {
    return this._data.length;
  }
  // copy to target buffer
  copy(target, targetOffset, offset, length) {
    return this._data._buf.copy(target, targetOffset, offset, length);
  }
  toBuffer() {
    return this._data.toBuffer();
  }
}
class BufferChunk {
  constructor(data) {
    this._data = data;
  }
  get length() {
    return this._data.length;
  }
  // copy to target buffer
  copy(target, targetOffset, offset, length) {
    this._data.copy(target, targetOffset, offset, length);
  }
  toBuffer() {
    return this._data;
  }
}
class ReadWriteBuf {
  constructor(size) {
    this.size = size;
    this.buffer = Buffer.alloc(size);
    this.iRead = 0;
    this.iWrite = 0;
  }
  toBuffer() {
    if (this.iRead === 0 && this.iWrite === this.size) {
      return this.buffer;
    }
    const buf = Buffer.alloc(this.iWrite - this.iRead);
    this.buffer.copy(buf, 0, this.iRead, this.iWrite);
    return buf;
  }
  get length() {
    return this.iWrite - this.iRead;
  }
  get eod() {
    return this.iRead === this.iWrite;
  }
  get full() {
    return this.iWrite === this.size;
  }
  read(size) {
    let buf;
    if (size === 0) {
      return null;
    }
    if (size === void 0 || size >= this.length) {
      buf = this.toBuffer();
      this.iRead = this.iWrite;
      return buf;
    }
    buf = Buffer.alloc(size);
    this.buffer.copy(buf, 0, this.iRead, size);
    this.iRead += size;
    return buf;
  }
  write(chunk, offset, length) {
    const size = Math.min(length, this.size - this.iWrite);
    chunk.copy(this.buffer, this.iWrite, offset, offset + size);
    this.iWrite += size;
    return size;
  }
}
const StreamBuf$4 = function(options) {
  options = options || {};
  this.bufSize = options.bufSize || 1024 * 1024;
  this.buffers = [];
  this.batch = options.batch || false;
  this.corked = false;
  this.inPos = 0;
  this.outPos = 0;
  this.pipes = [];
  this.paused = false;
  this.encoding = null;
};
utils$f.inherits(StreamBuf$4, Stream$d.Duplex, {
  toBuffer() {
    switch (this.buffers.length) {
      case 0:
        return null;
      case 1:
        return this.buffers[0].toBuffer();
      default:
        return Buffer.concat(this.buffers.map((rwBuf) => rwBuf.toBuffer()));
    }
  },
  // writable
  // event drain - if write returns false (which it won't), indicates when safe to write again.
  // finish - end() has been called
  // pipe(src) - pipe() has been called on readable
  // unpipe(src) - unpipe() has been called on readable
  // error - duh
  _getWritableBuffer() {
    if (this.buffers.length) {
      const last = this.buffers[this.buffers.length - 1];
      if (!last.full) {
        return last;
      }
    }
    const buf = new ReadWriteBuf(this.bufSize);
    this.buffers.push(buf);
    return buf;
  },
  async _pipe(chunk) {
    const write = function(pipe) {
      return new Promise((resolve2) => {
        pipe.write(chunk.toBuffer(), () => {
          resolve2();
        });
      });
    };
    await Promise.all(this.pipes.map(write));
  },
  _writeToBuffers(chunk) {
    let inPos = 0;
    const inLen = chunk.length;
    while (inPos < inLen) {
      const buffer = this._getWritableBuffer();
      inPos += buffer.write(chunk, inPos, inLen - inPos);
    }
  },
  async write(data, encoding, callback) {
    if (encoding instanceof Function) {
      callback = encoding;
      encoding = "utf8";
    }
    callback = callback || utils$f.nop;
    let chunk;
    if (data instanceof StringBuf$1) {
      chunk = new StringBufChunk(data);
    } else if (data instanceof Buffer) {
      chunk = new BufferChunk(data);
    } else if (typeof data === "string" || data instanceof String || data instanceof ArrayBuffer) {
      chunk = new StringChunk(data, encoding);
    } else {
      throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
    }
    if (this.pipes.length) {
      if (this.batch) {
        this._writeToBuffers(chunk);
        while (!this.corked && this.buffers.length > 1) {
          this._pipe(this.buffers.shift());
        }
      } else if (!this.corked) {
        await this._pipe(chunk);
        callback();
      } else {
        this._writeToBuffers(chunk);
        process.nextTick(callback);
      }
    } else {
      if (!this.paused) {
        this.emit("data", chunk.toBuffer());
      }
      this._writeToBuffers(chunk);
      this.emit("readable");
    }
    return true;
  },
  cork() {
    this.corked = true;
  },
  _flush() {
    if (this.pipes.length) {
      while (this.buffers.length) {
        this._pipe(this.buffers.shift());
      }
    }
  },
  uncork() {
    this.corked = false;
    this._flush();
  },
  end(chunk, encoding, callback) {
    const writeComplete = (error2) => {
      if (error2) {
        callback(error2);
      } else {
        this._flush();
        this.pipes.forEach((pipe) => {
          pipe.end();
        });
        this.emit("finish");
      }
    };
    if (chunk) {
      this.write(chunk, encoding, writeComplete);
    } else {
      writeComplete();
    }
  },
  // readable
  // event readable - some data is now available
  // event data - switch to flowing mode - feeds chunks to handler
  // event end - no more data
  // event close - optional, indicates upstream close
  // event error - duh
  read(size) {
    let buffers2;
    if (size) {
      buffers2 = [];
      while (size && this.buffers.length && !this.buffers[0].eod) {
        const first = this.buffers[0];
        const buffer = first.read(size);
        size -= buffer.length;
        buffers2.push(buffer);
        if (first.eod && first.full) {
          this.buffers.shift();
        }
      }
      return Buffer.concat(buffers2);
    }
    buffers2 = this.buffers.map((buf) => buf.toBuffer()).filter(Boolean);
    this.buffers = [];
    return Buffer.concat(buffers2);
  },
  setEncoding(encoding) {
    this.encoding = encoding;
  },
  pause() {
    this.paused = true;
  },
  resume() {
    this.paused = false;
  },
  isPaused() {
    return !!this.paused;
  },
  pipe(destination) {
    this.pipes.push(destination);
    if (!this.paused && this.buffers.length) {
      this.end();
    }
  },
  unpipe(destination) {
    this.pipes = this.pipes.filter((pipe) => pipe !== destination);
  },
  unshift() {
    throw new Error("Not Implemented");
  },
  wrap() {
    throw new Error("Not Implemented");
  }
});
var streamBuf = StreamBuf$4;
var browserBufferEncode = {};
const textEncoder = typeof TextEncoder === "undefined" ? null : new TextEncoder("utf-8");
const { Buffer: Buffer$9 } = require$$0$3;
function stringToBuffer$1(str) {
  if (typeof str !== "string") {
    return str;
  }
  if (textEncoder) {
    return Buffer$9.from(textEncoder.encode(str).buffer);
  }
  return Buffer$9.from(str);
}
browserBufferEncode.stringToBuffer = stringToBuffer$1;
const events = require$$2$1;
const JSZip$1 = lib$1;
const StreamBuf$3 = streamBuf;
const { stringToBuffer } = browserBufferEncode;
class ZipWriter extends events.EventEmitter {
  constructor(options) {
    super();
    this.options = Object.assign(
      {
        type: "nodebuffer",
        compression: "DEFLATE"
      },
      options
    );
    this.zip = new JSZip$1();
    this.stream = new StreamBuf$3();
  }
  append(data, options) {
    if (options.hasOwnProperty("base64") && options.base64) {
      this.zip.file(options.name, data, { base64: true });
    } else {
      if (process.browser && typeof data === "string") {
        data = stringToBuffer(data);
      }
      this.zip.file(options.name, data);
    }
  }
  async finalize() {
    const content = await this.zip.generateAsync(this.options);
    this.stream.end(content);
    this.emit("finish");
  }
  // ==========================================================================
  // Stream.Readable interface
  read(size) {
    return this.stream.read(size);
  }
  setEncoding(encoding) {
    return this.stream.setEncoding(encoding);
  }
  pause() {
    return this.stream.pause();
  }
  resume() {
    return this.stream.resume();
  }
  isPaused() {
    return this.stream.isPaused();
  }
  pipe(destination, options) {
    return this.stream.pipe(destination, options);
  }
  unpipe(destination) {
    return this.stream.unpipe(destination);
  }
  unshift(chunk) {
    return this.stream.unshift(chunk);
  }
  wrap(stream2) {
    return this.stream.wrap(stream2);
  }
}
var zipStream$1 = {
  ZipWriter
};
const _$e = underDash;
const utils$e = utils_1;
const OPEN_ANGLE = "<";
const CLOSE_ANGLE = ">";
const OPEN_ANGLE_SLASH = "</";
const CLOSE_SLASH_ANGLE = "/>";
function pushAttribute(xml, name, value) {
  xml.push(` ${name}="${utils$e.xmlEncode(value.toString())}"`);
}
function pushAttributes(xml, attributes) {
  if (attributes) {
    const tmp2 = [];
    _$e.each(attributes, (value, name) => {
      if (value !== void 0) {
        pushAttribute(tmp2, name, value);
      }
    });
    xml.push(tmp2.join(""));
  }
}
let XmlStream$g = class XmlStream {
  constructor() {
    this._xml = [];
    this._stack = [];
    this._rollbacks = [];
  }
  get tos() {
    return this._stack.length ? this._stack[this._stack.length - 1] : void 0;
  }
  get cursor() {
    return this._xml.length;
  }
  openXml(docAttributes) {
    const xml = this._xml;
    xml.push("<?xml");
    pushAttributes(xml, docAttributes);
    xml.push("?>\n");
  }
  openNode(name, attributes) {
    const parent2 = this.tos;
    const xml = this._xml;
    if (parent2 && this.open) {
      xml.push(CLOSE_ANGLE);
    }
    this._stack.push(name);
    xml.push(OPEN_ANGLE);
    xml.push(name);
    pushAttributes(xml, attributes);
    this.leaf = true;
    this.open = true;
  }
  addAttribute(name, value) {
    if (!this.open) {
      throw new Error("Cannot write attributes to node if it is not open");
    }
    if (value !== void 0) {
      pushAttribute(this._xml, name, value);
    }
  }
  addAttributes(attrs) {
    if (!this.open) {
      throw new Error("Cannot write attributes to node if it is not open");
    }
    pushAttributes(this._xml, attrs);
  }
  writeText(text) {
    const xml = this._xml;
    if (this.open) {
      xml.push(CLOSE_ANGLE);
      this.open = false;
    }
    this.leaf = false;
    xml.push(utils$e.xmlEncode(text.toString()));
  }
  writeXml(xml) {
    if (this.open) {
      this._xml.push(CLOSE_ANGLE);
      this.open = false;
    }
    this.leaf = false;
    this._xml.push(xml);
  }
  closeNode() {
    const node2 = this._stack.pop();
    const xml = this._xml;
    if (this.leaf) {
      xml.push(CLOSE_SLASH_ANGLE);
    } else {
      xml.push(OPEN_ANGLE_SLASH);
      xml.push(node2);
      xml.push(CLOSE_ANGLE);
    }
    this.open = false;
    this.leaf = false;
  }
  leafNode(name, attributes, text) {
    this.openNode(name, attributes);
    if (text !== void 0) {
      this.writeText(text);
    }
    this.closeNode();
  }
  closeAll() {
    while (this._stack.length) {
      this.closeNode();
    }
  }
  addRollback() {
    this._rollbacks.push({
      xml: this._xml.length,
      stack: this._stack.length,
      leaf: this.leaf,
      open: this.open
    });
    return this.cursor;
  }
  commit() {
    this._rollbacks.pop();
  }
  rollback() {
    const r = this._rollbacks.pop();
    if (this._xml.length > r.xml) {
      this._xml.splice(r.xml, this._xml.length - r.xml);
    }
    if (this._stack.length > r.stack) {
      this._stack.splice(r.stack, this._stack.length - r.stack);
    }
    this.leaf = r.leaf;
    this.open = r.open;
  }
  get xml() {
    this.closeAll();
    return this._xml.join("");
  }
};
XmlStream$g.StdDocAttributes = {
  version: "1.0",
  encoding: "UTF-8",
  standalone: "yes"
};
var xmlStream = XmlStream$g;
var browserBufferDecode = {};
const textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
function bufferToString$2(chunk) {
  if (typeof chunk === "string") {
    return chunk;
  }
  if (textDecoder) {
    return textDecoder.decode(chunk);
  }
  return chunk.toString();
}
browserBufferDecode.bufferToString = bufferToString$2;
var saxes = {};
var ed5$1 = {};
(function(exports) {
  /**
   * Character classes and associated utilities for the 5th edition of XML 1.0.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CHAR = "	\n\r -퟿-�𐀀-􏿿";
  exports.S = " 	\r\n";
  exports.NAME_START_CHAR = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿";
  exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀";
  exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
  exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
  exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
  exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
  exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
  exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
  var TAB2 = 9;
  var NL2 = 10;
  var CR2 = 13;
  var SPACE2 = 32;
  exports.S_LIST = [SPACE2, NL2, CR2, TAB2];
  function isChar(c2) {
    return c2 >= SPACE2 && c2 <= 55295 || c2 === NL2 || c2 === CR2 || c2 === TAB2 || c2 >= 57344 && c2 <= 65533 || c2 >= 65536 && c2 <= 1114111;
  }
  exports.isChar = isChar;
  function isS2(c2) {
    return c2 === SPACE2 || c2 === NL2 || c2 === CR2 || c2 === TAB2;
  }
  exports.isS = isS2;
  function isNameStartChar2(c2) {
    return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || c2 === 58 || c2 === 95 || c2 === 8204 || c2 === 8205 || c2 >= 192 && c2 <= 214 || c2 >= 216 && c2 <= 246 || c2 >= 248 && c2 <= 767 || c2 >= 880 && c2 <= 893 || c2 >= 895 && c2 <= 8191 || c2 >= 8304 && c2 <= 8591 || c2 >= 11264 && c2 <= 12271 || c2 >= 12289 && c2 <= 55295 || c2 >= 63744 && c2 <= 64975 || c2 >= 65008 && c2 <= 65533 || c2 >= 65536 && c2 <= 983039;
  }
  exports.isNameStartChar = isNameStartChar2;
  function isNameChar2(c2) {
    return isNameStartChar2(c2) || c2 >= 48 && c2 <= 57 || c2 === 45 || c2 === 46 || c2 === 183 || c2 >= 768 && c2 <= 879 || c2 >= 8255 && c2 <= 8256;
  }
  exports.isNameChar = isNameChar2;
})(ed5$1);
var ed2$1 = {};
(function(exports) {
  /**
   * Character classes and associated utilities for the 2nd edition of XML 1.1.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CHAR = "-퟿-�𐀀-􏿿";
  exports.RESTRICTED_CHAR = "-\b\v\f---";
  exports.S = " 	\r\n";
  exports.NAME_START_CHAR = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿";
  exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀";
  exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
  exports.RESTRICTED_CHAR_RE = new RegExp("^[" + exports.RESTRICTED_CHAR + "]$", "u");
  exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
  exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
  exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
  exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
  exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
  var TAB2 = 9;
  var NL2 = 10;
  var CR2 = 13;
  var SPACE2 = 32;
  exports.S_LIST = [SPACE2, NL2, CR2, TAB2];
  function isChar(c2) {
    return c2 >= 1 && c2 <= 55295 || c2 >= 57344 && c2 <= 65533 || c2 >= 65536 && c2 <= 1114111;
  }
  exports.isChar = isChar;
  function isRestrictedChar(c2) {
    return c2 >= 1 && c2 <= 8 || c2 === 11 || c2 === 12 || c2 >= 14 && c2 <= 31 || c2 >= 127 && c2 <= 132 || c2 >= 134 && c2 <= 159;
  }
  exports.isRestrictedChar = isRestrictedChar;
  function isCharAndNotRestricted(c2) {
    return c2 === 9 || c2 === 10 || c2 === 13 || c2 > 31 && c2 < 127 || c2 === 133 || c2 > 159 && c2 <= 55295 || c2 >= 57344 && c2 <= 65533 || c2 >= 65536 && c2 <= 1114111;
  }
  exports.isCharAndNotRestricted = isCharAndNotRestricted;
  function isS2(c2) {
    return c2 === SPACE2 || c2 === NL2 || c2 === CR2 || c2 === TAB2;
  }
  exports.isS = isS2;
  function isNameStartChar2(c2) {
    return c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || c2 === 58 || c2 === 95 || c2 === 8204 || c2 === 8205 || c2 >= 192 && c2 <= 214 || c2 >= 216 && c2 <= 246 || c2 >= 248 && c2 <= 767 || c2 >= 880 && c2 <= 893 || c2 >= 895 && c2 <= 8191 || c2 >= 8304 && c2 <= 8591 || c2 >= 11264 && c2 <= 12271 || c2 >= 12289 && c2 <= 55295 || c2 >= 63744 && c2 <= 64975 || c2 >= 65008 && c2 <= 65533 || c2 >= 65536 && c2 <= 983039;
  }
  exports.isNameStartChar = isNameStartChar2;
  function isNameChar2(c2) {
    return isNameStartChar2(c2) || c2 >= 48 && c2 <= 57 || c2 === 45 || c2 === 46 || c2 === 183 || c2 >= 768 && c2 <= 879 || c2 >= 8255 && c2 <= 8256;
  }
  exports.isNameChar = isNameChar2;
})(ed2$1);
var ed3 = {};
(function(exports) {
  /**
   * Character class utilities for XML NS 1.0 edition 3.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NC_NAME_START_CHAR = "A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿";
  exports.NC_NAME_CHAR = "-" + exports.NC_NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀";
  exports.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "]$", "u");
  exports.NC_NAME_CHAR_RE = new RegExp("^[" + exports.NC_NAME_CHAR + "]$", "u");
  exports.NC_NAME_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "][" + exports.NC_NAME_CHAR + "]*$", "u");
  function isNCNameStartChar2(c2) {
    return c2 >= 65 && c2 <= 90 || c2 === 95 || c2 >= 97 && c2 <= 122 || c2 >= 192 && c2 <= 214 || c2 >= 216 && c2 <= 246 || c2 >= 248 && c2 <= 767 || c2 >= 880 && c2 <= 893 || c2 >= 895 && c2 <= 8191 || c2 >= 8204 && c2 <= 8205 || c2 >= 8304 && c2 <= 8591 || c2 >= 11264 && c2 <= 12271 || c2 >= 12289 && c2 <= 55295 || c2 >= 63744 && c2 <= 64975 || c2 >= 65008 && c2 <= 65533 || c2 >= 65536 && c2 <= 983039;
  }
  exports.isNCNameStartChar = isNCNameStartChar2;
  function isNCNameChar2(c2) {
    return isNCNameStartChar2(c2) || (c2 === 45 || c2 === 46 || c2 >= 48 && c2 <= 57 || c2 === 183 || c2 >= 768 && c2 <= 879 || c2 >= 8255 && c2 <= 8256);
  }
  exports.isNCNameChar = isNCNameChar2;
})(ed3);
Object.defineProperty(saxes, "__esModule", { value: true });
const ed5 = ed5$1;
const ed2 = ed2$1;
const NSed3 = ed3;
var isS = ed5.isS;
var isChar10 = ed5.isChar;
var isNameStartChar = ed5.isNameStartChar;
var isNameChar = ed5.isNameChar;
var S_LIST = ed5.S_LIST;
var NAME_RE = ed5.NAME_RE;
var isChar11 = ed2.isChar;
var isNCNameStartChar = NSed3.isNCNameStartChar;
var isNCNameChar = NSed3.isNCNameChar;
var NC_NAME_RE = NSed3.NC_NAME_RE;
const XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
const XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
const rootNS = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  __proto__: null,
  xml: XML_NAMESPACE,
  xmlns: XMLNS_NAMESPACE
};
const XML_ENTITIES = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  __proto__: null,
  amp: "&",
  gt: ">",
  lt: "<",
  quot: '"',
  apos: "'"
};
const EOC = -1;
const NL_LIKE = -2;
const S_BEGIN = 0;
const S_BEGIN_WHITESPACE = 1;
const S_DOCTYPE = 2;
const S_DOCTYPE_QUOTE = 3;
const S_DTD = 4;
const S_DTD_QUOTED = 5;
const S_DTD_OPEN_WAKA = 6;
const S_DTD_OPEN_WAKA_BANG = 7;
const S_DTD_COMMENT = 8;
const S_DTD_COMMENT_ENDING = 9;
const S_DTD_COMMENT_ENDED = 10;
const S_DTD_PI = 11;
const S_DTD_PI_ENDING = 12;
const S_TEXT = 13;
const S_ENTITY = 14;
const S_OPEN_WAKA = 15;
const S_OPEN_WAKA_BANG = 16;
const S_COMMENT = 17;
const S_COMMENT_ENDING = 18;
const S_COMMENT_ENDED = 19;
const S_CDATA = 20;
const S_CDATA_ENDING = 21;
const S_CDATA_ENDING_2 = 22;
const S_PI_FIRST_CHAR = 23;
const S_PI_REST = 24;
const S_PI_BODY = 25;
const S_PI_ENDING = 26;
const S_XML_DECL_NAME_START = 27;
const S_XML_DECL_NAME = 28;
const S_XML_DECL_EQ = 29;
const S_XML_DECL_VALUE_START = 30;
const S_XML_DECL_VALUE = 31;
const S_XML_DECL_SEPARATOR = 32;
const S_XML_DECL_ENDING = 33;
const S_OPEN_TAG = 34;
const S_OPEN_TAG_SLASH = 35;
const S_ATTRIB = 36;
const S_ATTRIB_NAME = 37;
const S_ATTRIB_NAME_SAW_WHITE = 38;
const S_ATTRIB_VALUE = 39;
const S_ATTRIB_VALUE_QUOTED = 40;
const S_ATTRIB_VALUE_CLOSED = 41;
const S_ATTRIB_VALUE_UNQUOTED = 42;
const S_CLOSE_TAG = 43;
const S_CLOSE_TAG_SAW_WHITE = 44;
const TAB = 9;
const NL = 10;
const CR = 13;
const SPACE = 32;
const BANG = 33;
const DQUOTE = 34;
const AMP = 38;
const SQUOTE = 39;
const MINUS = 45;
const FORWARD_SLASH = 47;
const SEMICOLON = 59;
const LESS = 60;
const EQUAL = 61;
const GREATER = 62;
const QUESTION = 63;
const OPEN_BRACKET = 91;
const CLOSE_BRACKET = 93;
const NEL = 133;
const LS = 8232;
const isQuote = (c2) => c2 === DQUOTE || c2 === SQUOTE;
const QUOTES = [DQUOTE, SQUOTE];
const DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];
const DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];
const XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];
const ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];
function nsPairCheck(parser2, prefix, uri) {
  switch (prefix) {
    case "xml":
      if (uri !== XML_NAMESPACE) {
        parser2.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);
      }
      break;
    case "xmlns":
      if (uri !== XMLNS_NAMESPACE) {
        parser2.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);
      }
      break;
  }
  switch (uri) {
    case XMLNS_NAMESPACE:
      parser2.fail(prefix === "" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even "xmlns") to the URI ${XMLNS_NAMESPACE}.`);
      break;
    case XML_NAMESPACE:
      switch (prefix) {
        case "xml":
          break;
        case "":
          parser2.fail(`the default namespace may not be set to ${uri}.`);
          break;
        default:
          parser2.fail("may not assign the xml namespace to another prefix.");
      }
      break;
  }
}
function nsMappingCheck(parser2, mapping) {
  for (const local of Object.keys(mapping)) {
    nsPairCheck(parser2, local, mapping[local]);
  }
}
const isNCName = (name) => NC_NAME_RE.test(name);
const isName = (name) => NAME_RE.test(name);
const FORBIDDEN_START = 0;
const FORBIDDEN_BRACKET = 1;
const FORBIDDEN_BRACKET_BRACKET = 2;
saxes.EVENTS = [
  "xmldecl",
  "text",
  "processinginstruction",
  "doctype",
  "comment",
  "opentagstart",
  "attribute",
  "opentag",
  "closetag",
  "cdata",
  "error",
  "end",
  "ready"
];
const EVENT_NAME_TO_HANDLER_NAME = {
  xmldecl: "xmldeclHandler",
  text: "textHandler",
  processinginstruction: "piHandler",
  doctype: "doctypeHandler",
  comment: "commentHandler",
  opentagstart: "openTagStartHandler",
  attribute: "attributeHandler",
  opentag: "openTagHandler",
  closetag: "closeTagHandler",
  cdata: "cdataHandler",
  error: "errorHandler",
  end: "endHandler",
  ready: "readyHandler"
};
let SaxesParser$1 = class SaxesParser {
  /**
   * @param opt The parser options.
   */
  constructor(opt) {
    this.opt = opt !== null && opt !== void 0 ? opt : {};
    this.fragmentOpt = !!this.opt.fragment;
    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
    this.trackPosition = this.opt.position !== false;
    this.fileName = this.opt.fileName;
    if (xmlnsOpt) {
      this.nameStartCheck = isNCNameStartChar;
      this.nameCheck = isNCNameChar;
      this.isName = isNCName;
      this.processAttribs = this.processAttribsNS;
      this.pushAttrib = this.pushAttribNS;
      this.ns = Object.assign({ __proto__: null }, rootNS);
      const additional = this.opt.additionalNamespaces;
      if (additional != null) {
        nsMappingCheck(this, additional);
        Object.assign(this.ns, additional);
      }
    } else {
      this.nameStartCheck = isNameStartChar;
      this.nameCheck = isNameChar;
      this.isName = isName;
      this.processAttribs = this.processAttribsPlain;
      this.pushAttrib = this.pushAttribPlain;
    }
    this.stateTable = [
      /* eslint-disable @typescript-eslint/unbound-method */
      this.sBegin,
      this.sBeginWhitespace,
      this.sDoctype,
      this.sDoctypeQuote,
      this.sDTD,
      this.sDTDQuoted,
      this.sDTDOpenWaka,
      this.sDTDOpenWakaBang,
      this.sDTDComment,
      this.sDTDCommentEnding,
      this.sDTDCommentEnded,
      this.sDTDPI,
      this.sDTDPIEnding,
      this.sText,
      this.sEntity,
      this.sOpenWaka,
      this.sOpenWakaBang,
      this.sComment,
      this.sCommentEnding,
      this.sCommentEnded,
      this.sCData,
      this.sCDataEnding,
      this.sCDataEnding2,
      this.sPIFirstChar,
      this.sPIRest,
      this.sPIBody,
      this.sPIEnding,
      this.sXMLDeclNameStart,
      this.sXMLDeclName,
      this.sXMLDeclEq,
      this.sXMLDeclValueStart,
      this.sXMLDeclValue,
      this.sXMLDeclSeparator,
      this.sXMLDeclEnding,
      this.sOpenTag,
      this.sOpenTagSlash,
      this.sAttrib,
      this.sAttribName,
      this.sAttribNameSawWhite,
      this.sAttribValue,
      this.sAttribValueQuoted,
      this.sAttribValueClosed,
      this.sAttribValueUnquoted,
      this.sCloseTag,
      this.sCloseTagSawWhite
    ];
    this._init();
  }
  /**
   * Indicates whether or not the parser is closed. If ``true``, wait for
   * the ``ready`` event to write again.
   */
  get closed() {
    return this._closed;
  }
  _init() {
    var _a;
    this.openWakaBang = "";
    this.text = "";
    this.name = "";
    this.piTarget = "";
    this.entity = "";
    this.q = null;
    this.tags = [];
    this.tag = null;
    this.topNS = null;
    this.chunk = "";
    this.chunkPosition = 0;
    this.i = 0;
    this.prevI = 0;
    this.carriedFromPrevious = void 0;
    this.forbiddenState = FORBIDDEN_START;
    this.attribList = [];
    const { fragmentOpt } = this;
    this.state = fragmentOpt ? S_TEXT : S_BEGIN;
    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;
    this.xmlDeclPossible = !fragmentOpt;
    this.xmlDeclExpects = ["version"];
    this.entityReturnState = void 0;
    let { defaultXMLVersion } = this.opt;
    if (defaultXMLVersion === void 0) {
      if (this.opt.forceXMLVersion === true) {
        throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
      }
      defaultXMLVersion = "1.0";
    }
    this.setXMLVersion(defaultXMLVersion);
    this.positionAtNewLine = 0;
    this.doctype = false;
    this._closed = false;
    this.xmlDecl = {
      version: void 0,
      encoding: void 0,
      standalone: void 0
    };
    this.line = 1;
    this.column = 0;
    this.ENTITIES = Object.create(XML_ENTITIES);
    (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  /**
   * The stream position the parser is currently looking at. This field is
   * zero-based.
   *
   * This field is not based on counting Unicode characters but is to be
   * interpreted as a plain index into a JavaScript string.
   */
  get position() {
    return this.chunkPosition + this.i;
  }
  /**
   * The column number of the next character to be read by the parser.  *
   * This field is zero-based. (The first column in a line is 0.)
   *
   * This field reports the index at which the next character would be in the
   * line if the line were represented as a JavaScript string.  Note that this
   * *can* be different to a count based on the number of *Unicode characters*
   * due to how JavaScript handles astral plane characters.
   *
   * See [[column]] for a number that corresponds to a count of Unicode
   * characters.
   */
  get columnIndex() {
    return this.position - this.positionAtNewLine;
  }
  /**
   * Set an event listener on an event. The parser supports one handler per
   * event type. If you try to set an event handler over an existing handler,
   * the old handler is silently overwritten.
   *
   * @param name The event to listen to.
   *
   * @param handler The handler to set.
   */
  on(name, handler) {
    this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
  }
  /**
   * Unset an event handler.
   *
   * @parma name The event to stop listening to.
   */
  off(name) {
    this[EVENT_NAME_TO_HANDLER_NAME[name]] = void 0;
  }
  /**
   * Make an error object. The error object will have a message that contains
   * the ``fileName`` option passed at the creation of the parser. If position
   * tracking was turned on, it will also have line and column number
   * information.
   *
   * @param message The message describing the error to report.
   *
   * @returns An error object with a properly formatted message.
   */
  makeError(message) {
    var _a;
    let msg2 = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
    if (this.trackPosition) {
      if (msg2.length > 0) {
        msg2 += ":";
      }
      msg2 += `${this.line}:${this.column}`;
    }
    if (msg2.length > 0) {
      msg2 += ": ";
    }
    return new Error(msg2 + message);
  }
  /**
   * Report a parsing error. This method is made public so that client code may
   * check for issues that are outside the scope of this project and can report
   * errors.
   *
   * @param message The error to report.
   *
   * @returns this
   */
  fail(message) {
    const err2 = this.makeError(message);
    const handler = this.errorHandler;
    if (handler === void 0) {
      throw err2;
    } else {
      handler(err2);
    }
    return this;
  }
  /**
   * Write a XML data to the parser.
   *
   * @param chunk The XML data to write.
   *
   * @returns this
   */
  write(chunk) {
    if (this.closed) {
      return this.fail("cannot write after close; assign an onready handler.");
    }
    let end2 = false;
    if (chunk === null) {
      end2 = true;
      chunk = "";
    } else if (typeof chunk === "object") {
      chunk = chunk.toString();
    }
    if (this.carriedFromPrevious !== void 0) {
      chunk = `${this.carriedFromPrevious}${chunk}`;
      this.carriedFromPrevious = void 0;
    }
    let limit = chunk.length;
    const lastCode = chunk.charCodeAt(limit - 1);
    if (!end2 && // A trailing CR or surrogate must be carried over to the next
    // chunk.
    (lastCode === CR || lastCode >= 55296 && lastCode <= 56319)) {
      this.carriedFromPrevious = chunk[limit - 1];
      limit--;
      chunk = chunk.slice(0, limit);
    }
    const { stateTable } = this;
    this.chunk = chunk;
    this.i = 0;
    while (this.i < limit) {
      stateTable[this.state].call(this);
    }
    this.chunkPosition += limit;
    return end2 ? this.end() : this;
  }
  /**
   * Close the current stream. Perform final well-formedness checks and reset
   * the parser tstate.
   *
   * @returns this
   */
  close() {
    return this.write(null);
  }
  /**
   * Get a single code point out of the current chunk. This updates the current
   * position if we do position tracking.
   *
   * This is the algorithm to use for XML 1.0.
   *
   * @returns The character read.
   */
  getCode10() {
    const { chunk, i } = this;
    this.prevI = i;
    this.i = i + 1;
    if (i >= chunk.length) {
      return EOC;
    }
    const code = chunk.charCodeAt(i);
    this.column++;
    if (code < 55296) {
      if (code >= SPACE || code === TAB) {
        return code;
      }
      switch (code) {
        case NL:
          this.line++;
          this.column = 0;
          this.positionAtNewLine = this.position;
          return NL;
        case CR:
          if (chunk.charCodeAt(i + 1) === NL) {
            this.i = i + 2;
          }
          this.line++;
          this.column = 0;
          this.positionAtNewLine = this.position;
          return NL_LIKE;
        default:
          this.fail("disallowed character.");
          return code;
      }
    }
    if (code > 56319) {
      if (!(code >= 57344 && code <= 65533)) {
        this.fail("disallowed character.");
      }
      return code;
    }
    const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
    this.i = i + 2;
    if (final > 1114111) {
      this.fail("disallowed character.");
    }
    return final;
  }
  /**
   * Get a single code point out of the current chunk. This updates the current
   * position if we do position tracking.
   *
   * This is the algorithm to use for XML 1.1.
   *
   * @returns {number} The character read.
   */
  getCode11() {
    const { chunk, i } = this;
    this.prevI = i;
    this.i = i + 1;
    if (i >= chunk.length) {
      return EOC;
    }
    const code = chunk.charCodeAt(i);
    this.column++;
    if (code < 55296) {
      if (code > 31 && code < 127 || code > 159 && code !== LS || code === TAB) {
        return code;
      }
      switch (code) {
        case NL:
          this.line++;
          this.column = 0;
          this.positionAtNewLine = this.position;
          return NL;
        case CR: {
          const next = chunk.charCodeAt(i + 1);
          if (next === NL || next === NEL) {
            this.i = i + 2;
          }
        }
        case NEL:
        case LS:
          this.line++;
          this.column = 0;
          this.positionAtNewLine = this.position;
          return NL_LIKE;
        default:
          this.fail("disallowed character.");
          return code;
      }
    }
    if (code > 56319) {
      if (!(code >= 57344 && code <= 65533)) {
        this.fail("disallowed character.");
      }
      return code;
    }
    const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
    this.i = i + 2;
    if (final > 1114111) {
      this.fail("disallowed character.");
    }
    return final;
  }
  /**
   * Like ``getCode`` but with the return value normalized so that ``NL`` is
   * returned for ``NL_LIKE``.
   */
  getCodeNorm() {
    const c2 = this.getCode();
    return c2 === NL_LIKE ? NL : c2;
  }
  unget() {
    this.i = this.prevI;
    this.column--;
  }
  /**
   * Capture characters into a buffer until encountering one of a set of
   * characters.
   *
   * @param chars An array of codepoints. Encountering a character in the array
   * ends the capture. (``chars`` may safely contain ``NL``.)
   *
   * @return The character code that made the capture end, or ``EOC`` if we hit
   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
   * instead.
   */
  captureTo(chars) {
    let { i: start } = this;
    const { chunk } = this;
    while (true) {
      const c2 = this.getCode();
      const isNLLike = c2 === NL_LIKE;
      const final = isNLLike ? NL : c2;
      if (final === EOC || chars.includes(final)) {
        this.text += chunk.slice(start, this.prevI);
        return final;
      }
      if (isNLLike) {
        this.text += `${chunk.slice(start, this.prevI)}
`;
        start = this.i;
      }
    }
  }
  /**
   * Capture characters into a buffer until encountering a character.
   *
   * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
   * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
   *
   * @return ``true`` if we ran into the character. Otherwise, we ran into the
   * end of the current chunk.
   */
  captureToChar(char) {
    let { i: start } = this;
    const { chunk } = this;
    while (true) {
      let c2 = this.getCode();
      switch (c2) {
        case NL_LIKE:
          this.text += `${chunk.slice(start, this.prevI)}
`;
          start = this.i;
          c2 = NL;
          break;
        case EOC:
          this.text += chunk.slice(start);
          return false;
      }
      if (c2 === char) {
        this.text += chunk.slice(start, this.prevI);
        return true;
      }
    }
  }
  /**
   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
   * this parser.
   *
   * @return The character code that made the test fail, or ``EOC`` if we hit
   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
   * instead.
   */
  captureNameChars() {
    const { chunk, i: start } = this;
    while (true) {
      const c2 = this.getCode();
      if (c2 === EOC) {
        this.name += chunk.slice(start);
        return EOC;
      }
      if (!isNameChar(c2)) {
        this.name += chunk.slice(start, this.prevI);
        return c2 === NL_LIKE ? NL : c2;
      }
    }
  }
  /**
   * Skip white spaces.
   *
   * @return The character that ended the skip, or ``EOC`` if we hit
   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
   * instead.
   */
  skipSpaces() {
    while (true) {
      const c2 = this.getCodeNorm();
      if (c2 === EOC || !isS(c2)) {
        return c2;
      }
    }
  }
  setXMLVersion(version2) {
    this.currentXMLVersion = version2;
    if (version2 === "1.0") {
      this.isChar = isChar10;
      this.getCode = this.getCode10;
    } else {
      this.isChar = isChar11;
      this.getCode = this.getCode11;
    }
  }
  // STATE ENGINE METHODS
  // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
  // to be sure never to come back to this state later.
  sBegin() {
    if (this.chunk.charCodeAt(0) === 65279) {
      this.i++;
      this.column++;
    }
    this.state = S_BEGIN_WHITESPACE;
  }
  sBeginWhitespace() {
    const iBefore = this.i;
    const c2 = this.skipSpaces();
    if (this.prevI !== iBefore) {
      this.xmlDeclPossible = false;
    }
    switch (c2) {
      case LESS:
        this.state = S_OPEN_WAKA;
        if (this.text.length !== 0) {
          throw new Error("no-empty text at start");
        }
        break;
      case EOC:
        break;
      default:
        this.unget();
        this.state = S_TEXT;
        this.xmlDeclPossible = false;
    }
  }
  sDoctype() {
    var _a;
    const c2 = this.captureTo(DOCTYPE_TERMINATOR);
    switch (c2) {
      case GREATER: {
        (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
        this.text = "";
        this.state = S_TEXT;
        this.doctype = true;
        break;
      }
      case EOC:
        break;
      default:
        this.text += String.fromCodePoint(c2);
        if (c2 === OPEN_BRACKET) {
          this.state = S_DTD;
        } else if (isQuote(c2)) {
          this.state = S_DOCTYPE_QUOTE;
          this.q = c2;
        }
    }
  }
  sDoctypeQuote() {
    const q = this.q;
    if (this.captureToChar(q)) {
      this.text += String.fromCodePoint(q);
      this.q = null;
      this.state = S_DOCTYPE;
    }
  }
  sDTD() {
    const c2 = this.captureTo(DTD_TERMINATOR);
    if (c2 === EOC) {
      return;
    }
    this.text += String.fromCodePoint(c2);
    if (c2 === CLOSE_BRACKET) {
      this.state = S_DOCTYPE;
    } else if (c2 === LESS) {
      this.state = S_DTD_OPEN_WAKA;
    } else if (isQuote(c2)) {
      this.state = S_DTD_QUOTED;
      this.q = c2;
    }
  }
  sDTDQuoted() {
    const q = this.q;
    if (this.captureToChar(q)) {
      this.text += String.fromCodePoint(q);
      this.state = S_DTD;
      this.q = null;
    }
  }
  sDTDOpenWaka() {
    const c2 = this.getCodeNorm();
    this.text += String.fromCodePoint(c2);
    switch (c2) {
      case BANG:
        this.state = S_DTD_OPEN_WAKA_BANG;
        this.openWakaBang = "";
        break;
      case QUESTION:
        this.state = S_DTD_PI;
        break;
      default:
        this.state = S_DTD;
    }
  }
  sDTDOpenWakaBang() {
    const char = String.fromCodePoint(this.getCodeNorm());
    const owb = this.openWakaBang += char;
    this.text += char;
    if (owb !== "-") {
      this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
      this.openWakaBang = "";
    }
  }
  sDTDComment() {
    if (this.captureToChar(MINUS)) {
      this.text += "-";
      this.state = S_DTD_COMMENT_ENDING;
    }
  }
  sDTDCommentEnding() {
    const c2 = this.getCodeNorm();
    this.text += String.fromCodePoint(c2);
    this.state = c2 === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
  }
  sDTDCommentEnded() {
    const c2 = this.getCodeNorm();
    this.text += String.fromCodePoint(c2);
    if (c2 === GREATER) {
      this.state = S_DTD;
    } else {
      this.fail("malformed comment.");
      this.state = S_DTD_COMMENT;
    }
  }
  sDTDPI() {
    if (this.captureToChar(QUESTION)) {
      this.text += "?";
      this.state = S_DTD_PI_ENDING;
    }
  }
  sDTDPIEnding() {
    const c2 = this.getCodeNorm();
    this.text += String.fromCodePoint(c2);
    if (c2 === GREATER) {
      this.state = S_DTD;
    }
  }
  sText() {
    if (this.tags.length !== 0) {
      this.handleTextInRoot();
    } else {
      this.handleTextOutsideRoot();
    }
  }
  sEntity() {
    let { i: start } = this;
    const { chunk } = this;
    loop:
      while (true) {
        switch (this.getCode()) {
          case NL_LIKE:
            this.entity += `${chunk.slice(start, this.prevI)}
`;
            start = this.i;
            break;
          case SEMICOLON: {
            const { entityReturnState } = this;
            const entity = this.entity + chunk.slice(start, this.prevI);
            this.state = entityReturnState;
            let parsed;
            if (entity === "") {
              this.fail("empty entity name.");
              parsed = "&;";
            } else {
              parsed = this.parseEntity(entity);
              this.entity = "";
            }
            if (entityReturnState !== S_TEXT || this.textHandler !== void 0) {
              this.text += parsed;
            }
            break loop;
          }
          case EOC:
            this.entity += chunk.slice(start);
            break loop;
        }
      }
  }
  sOpenWaka() {
    const c2 = this.getCode();
    if (isNameStartChar(c2)) {
      this.state = S_OPEN_TAG;
      this.unget();
      this.xmlDeclPossible = false;
    } else {
      switch (c2) {
        case FORWARD_SLASH:
          this.state = S_CLOSE_TAG;
          this.xmlDeclPossible = false;
          break;
        case BANG:
          this.state = S_OPEN_WAKA_BANG;
          this.openWakaBang = "";
          this.xmlDeclPossible = false;
          break;
        case QUESTION:
          this.state = S_PI_FIRST_CHAR;
          break;
        default:
          this.fail("disallowed character in tag name");
          this.state = S_TEXT;
          this.xmlDeclPossible = false;
      }
    }
  }
  sOpenWakaBang() {
    this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
    switch (this.openWakaBang) {
      case "[CDATA[":
        if (!this.sawRoot && !this.reportedTextBeforeRoot) {
          this.fail("text data outside of root node.");
          this.reportedTextBeforeRoot = true;
        }
        if (this.closedRoot && !this.reportedTextAfterRoot) {
          this.fail("text data outside of root node.");
          this.reportedTextAfterRoot = true;
        }
        this.state = S_CDATA;
        this.openWakaBang = "";
        break;
      case "--":
        this.state = S_COMMENT;
        this.openWakaBang = "";
        break;
      case "DOCTYPE":
        this.state = S_DOCTYPE;
        if (this.doctype || this.sawRoot) {
          this.fail("inappropriately located doctype declaration.");
        }
        this.openWakaBang = "";
        break;
      default:
        if (this.openWakaBang.length >= 7) {
          this.fail("incorrect syntax.");
        }
    }
  }
  sComment() {
    if (this.captureToChar(MINUS)) {
      this.state = S_COMMENT_ENDING;
    }
  }
  sCommentEnding() {
    var _a;
    const c2 = this.getCodeNorm();
    if (c2 === MINUS) {
      this.state = S_COMMENT_ENDED;
      (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
      this.text = "";
    } else {
      this.text += `-${String.fromCodePoint(c2)}`;
      this.state = S_COMMENT;
    }
  }
  sCommentEnded() {
    const c2 = this.getCodeNorm();
    if (c2 !== GREATER) {
      this.fail("malformed comment.");
      this.text += `--${String.fromCodePoint(c2)}`;
      this.state = S_COMMENT;
    } else {
      this.state = S_TEXT;
    }
  }
  sCData() {
    if (this.captureToChar(CLOSE_BRACKET)) {
      this.state = S_CDATA_ENDING;
    }
  }
  sCDataEnding() {
    const c2 = this.getCodeNorm();
    if (c2 === CLOSE_BRACKET) {
      this.state = S_CDATA_ENDING_2;
    } else {
      this.text += `]${String.fromCodePoint(c2)}`;
      this.state = S_CDATA;
    }
  }
  sCDataEnding2() {
    var _a;
    const c2 = this.getCodeNorm();
    switch (c2) {
      case GREATER: {
        (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
        this.text = "";
        this.state = S_TEXT;
        break;
      }
      case CLOSE_BRACKET:
        this.text += "]";
        break;
      default:
        this.text += `]]${String.fromCodePoint(c2)}`;
        this.state = S_CDATA;
    }
  }
  // We need this separate state to check the first character fo the pi target
  // with this.nameStartCheck which allows less characters than this.nameCheck.
  sPIFirstChar() {
    const c2 = this.getCodeNorm();
    if (this.nameStartCheck(c2)) {
      this.piTarget += String.fromCodePoint(c2);
      this.state = S_PI_REST;
    } else if (c2 === QUESTION || isS(c2)) {
      this.fail("processing instruction without a target.");
      this.state = c2 === QUESTION ? S_PI_ENDING : S_PI_BODY;
    } else {
      this.fail("disallowed character in processing instruction name.");
      this.piTarget += String.fromCodePoint(c2);
      this.state = S_PI_REST;
    }
  }
  sPIRest() {
    const { chunk, i: start } = this;
    while (true) {
      const c2 = this.getCodeNorm();
      if (c2 === EOC) {
        this.piTarget += chunk.slice(start);
        return;
      }
      if (!this.nameCheck(c2)) {
        this.piTarget += chunk.slice(start, this.prevI);
        const isQuestion = c2 === QUESTION;
        if (isQuestion || isS(c2)) {
          if (this.piTarget === "xml") {
            if (!this.xmlDeclPossible) {
              this.fail("an XML declaration must be at the start of the document.");
            }
            this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
          } else {
            this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
          }
        } else {
          this.fail("disallowed character in processing instruction name.");
          this.piTarget += String.fromCodePoint(c2);
        }
        break;
      }
    }
  }
  sPIBody() {
    if (this.text.length === 0) {
      const c2 = this.getCodeNorm();
      if (c2 === QUESTION) {
        this.state = S_PI_ENDING;
      } else if (!isS(c2)) {
        this.text = String.fromCodePoint(c2);
      }
    } else if (this.captureToChar(QUESTION)) {
      this.state = S_PI_ENDING;
    }
  }
  sPIEnding() {
    var _a;
    const c2 = this.getCodeNorm();
    if (c2 === GREATER) {
      const { piTarget } = this;
      if (piTarget.toLowerCase() === "xml") {
        this.fail("the XML declaration must appear at the start of the document.");
      }
      (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {
        target: piTarget,
        body: this.text
      });
      this.piTarget = this.text = "";
      this.state = S_TEXT;
    } else if (c2 === QUESTION) {
      this.text += "?";
    } else {
      this.text += `?${String.fromCodePoint(c2)}`;
      this.state = S_PI_BODY;
    }
    this.xmlDeclPossible = false;
  }
  sXMLDeclNameStart() {
    const c2 = this.skipSpaces();
    if (c2 === QUESTION) {
      this.state = S_XML_DECL_ENDING;
      return;
    }
    if (c2 !== EOC) {
      this.state = S_XML_DECL_NAME;
      this.name = String.fromCodePoint(c2);
    }
  }
  sXMLDeclName() {
    const c2 = this.captureTo(XML_DECL_NAME_TERMINATOR);
    if (c2 === QUESTION) {
      this.state = S_XML_DECL_ENDING;
      this.name += this.text;
      this.text = "";
      this.fail("XML declaration is incomplete.");
      return;
    }
    if (!(isS(c2) || c2 === EQUAL)) {
      return;
    }
    this.name += this.text;
    this.text = "";
    if (!this.xmlDeclExpects.includes(this.name)) {
      switch (this.name.length) {
        case 0:
          this.fail("did not expect any more name/value pairs.");
          break;
        case 1:
          this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
          break;
        default:
          this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`);
      }
    }
    this.state = c2 === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
  }
  sXMLDeclEq() {
    const c2 = this.getCodeNorm();
    if (c2 === QUESTION) {
      this.state = S_XML_DECL_ENDING;
      this.fail("XML declaration is incomplete.");
      return;
    }
    if (isS(c2)) {
      return;
    }
    if (c2 !== EQUAL) {
      this.fail("value required.");
    }
    this.state = S_XML_DECL_VALUE_START;
  }
  sXMLDeclValueStart() {
    const c2 = this.getCodeNorm();
    if (c2 === QUESTION) {
      this.state = S_XML_DECL_ENDING;
      this.fail("XML declaration is incomplete.");
      return;
    }
    if (isS(c2)) {
      return;
    }
    if (!isQuote(c2)) {
      this.fail("value must be quoted.");
      this.q = SPACE;
    } else {
      this.q = c2;
    }
    this.state = S_XML_DECL_VALUE;
  }
  sXMLDeclValue() {
    const c2 = this.captureTo([this.q, QUESTION]);
    if (c2 === QUESTION) {
      this.state = S_XML_DECL_ENDING;
      this.text = "";
      this.fail("XML declaration is incomplete.");
      return;
    }
    if (c2 === EOC) {
      return;
    }
    const value = this.text;
    this.text = "";
    switch (this.name) {
      case "version": {
        this.xmlDeclExpects = ["encoding", "standalone"];
        const version2 = value;
        this.xmlDecl.version = version2;
        if (!/^1\.[0-9]+$/.test(version2)) {
          this.fail("version number must match /^1\\.[0-9]+$/.");
        } else if (!this.opt.forceXMLVersion) {
          this.setXMLVersion(version2);
        }
        break;
      }
      case "encoding":
        if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
          this.fail("encoding value must match /^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
        }
        this.xmlDeclExpects = ["standalone"];
        this.xmlDecl.encoding = value;
        break;
      case "standalone":
        if (value !== "yes" && value !== "no") {
          this.fail('standalone value must match "yes" or "no".');
        }
        this.xmlDeclExpects = [];
        this.xmlDecl.standalone = value;
        break;
    }
    this.name = "";
    this.state = S_XML_DECL_SEPARATOR;
  }
  sXMLDeclSeparator() {
    const c2 = this.getCodeNorm();
    if (c2 === QUESTION) {
      this.state = S_XML_DECL_ENDING;
      return;
    }
    if (!isS(c2)) {
      this.fail("whitespace required.");
      this.unget();
    }
    this.state = S_XML_DECL_NAME_START;
  }
  sXMLDeclEnding() {
    var _a;
    const c2 = this.getCodeNorm();
    if (c2 === GREATER) {
      if (this.piTarget !== "xml") {
        this.fail("processing instructions are not allowed before root.");
      } else if (this.name !== "version" && this.xmlDeclExpects.includes("version")) {
        this.fail("XML declaration must contain a version.");
      }
      (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
      this.name = "";
      this.piTarget = this.text = "";
      this.state = S_TEXT;
    } else {
      this.fail("The character ? is disallowed anywhere in XML declarations.");
    }
    this.xmlDeclPossible = false;
  }
  sOpenTag() {
    var _a;
    const c2 = this.captureNameChars();
    if (c2 === EOC) {
      return;
    }
    const tag = this.tag = {
      name: this.name,
      attributes: /* @__PURE__ */ Object.create(null)
    };
    this.name = "";
    if (this.xmlnsOpt) {
      this.topNS = tag.ns = /* @__PURE__ */ Object.create(null);
    }
    (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
    this.sawRoot = true;
    if (!this.fragmentOpt && this.closedRoot) {
      this.fail("documents may contain only one root.");
    }
    switch (c2) {
      case GREATER:
        this.openTag();
        break;
      case FORWARD_SLASH:
        this.state = S_OPEN_TAG_SLASH;
        break;
      default:
        if (!isS(c2)) {
          this.fail("disallowed character in tag name.");
        }
        this.state = S_ATTRIB;
    }
  }
  sOpenTagSlash() {
    if (this.getCode() === GREATER) {
      this.openSelfClosingTag();
    } else {
      this.fail("forward-slash in opening tag not followed by >.");
      this.state = S_ATTRIB;
    }
  }
  sAttrib() {
    const c2 = this.skipSpaces();
    if (c2 === EOC) {
      return;
    }
    if (isNameStartChar(c2)) {
      this.unget();
      this.state = S_ATTRIB_NAME;
    } else if (c2 === GREATER) {
      this.openTag();
    } else if (c2 === FORWARD_SLASH) {
      this.state = S_OPEN_TAG_SLASH;
    } else {
      this.fail("disallowed character in attribute name.");
    }
  }
  sAttribName() {
    const c2 = this.captureNameChars();
    if (c2 === EQUAL) {
      this.state = S_ATTRIB_VALUE;
    } else if (isS(c2)) {
      this.state = S_ATTRIB_NAME_SAW_WHITE;
    } else if (c2 === GREATER) {
      this.fail("attribute without value.");
      this.pushAttrib(this.name, this.name);
      this.name = this.text = "";
      this.openTag();
    } else if (c2 !== EOC) {
      this.fail("disallowed character in attribute name.");
    }
  }
  sAttribNameSawWhite() {
    const c2 = this.skipSpaces();
    switch (c2) {
      case EOC:
        return;
      case EQUAL:
        this.state = S_ATTRIB_VALUE;
        break;
      default:
        this.fail("attribute without value.");
        this.text = "";
        this.name = "";
        if (c2 === GREATER) {
          this.openTag();
        } else if (isNameStartChar(c2)) {
          this.unget();
          this.state = S_ATTRIB_NAME;
        } else {
          this.fail("disallowed character in attribute name.");
          this.state = S_ATTRIB;
        }
    }
  }
  sAttribValue() {
    const c2 = this.getCodeNorm();
    if (isQuote(c2)) {
      this.q = c2;
      this.state = S_ATTRIB_VALUE_QUOTED;
    } else if (!isS(c2)) {
      this.fail("unquoted attribute value.");
      this.state = S_ATTRIB_VALUE_UNQUOTED;
      this.unget();
    }
  }
  sAttribValueQuoted() {
    const { q, chunk } = this;
    let { i: start } = this;
    while (true) {
      switch (this.getCode()) {
        case q:
          this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
          this.name = this.text = "";
          this.q = null;
          this.state = S_ATTRIB_VALUE_CLOSED;
          return;
        case AMP:
          this.text += chunk.slice(start, this.prevI);
          this.state = S_ENTITY;
          this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
          return;
        case NL:
        case NL_LIKE:
        case TAB:
          this.text += `${chunk.slice(start, this.prevI)} `;
          start = this.i;
          break;
        case LESS:
          this.text += chunk.slice(start, this.prevI);
          this.fail("disallowed character.");
          return;
        case EOC:
          this.text += chunk.slice(start);
          return;
      }
    }
  }
  sAttribValueClosed() {
    const c2 = this.getCodeNorm();
    if (isS(c2)) {
      this.state = S_ATTRIB;
    } else if (c2 === GREATER) {
      this.openTag();
    } else if (c2 === FORWARD_SLASH) {
      this.state = S_OPEN_TAG_SLASH;
    } else if (isNameStartChar(c2)) {
      this.fail("no whitespace between attributes.");
      this.unget();
      this.state = S_ATTRIB_NAME;
    } else {
      this.fail("disallowed character in attribute name.");
    }
  }
  sAttribValueUnquoted() {
    const c2 = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
    switch (c2) {
      case AMP:
        this.state = S_ENTITY;
        this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
        break;
      case LESS:
        this.fail("disallowed character.");
        break;
      case EOC:
        break;
      default:
        if (this.text.includes("]]>")) {
          this.fail('the string "]]>" is disallowed in char data.');
        }
        this.pushAttrib(this.name, this.text);
        this.name = this.text = "";
        if (c2 === GREATER) {
          this.openTag();
        } else {
          this.state = S_ATTRIB;
        }
    }
  }
  sCloseTag() {
    const c2 = this.captureNameChars();
    if (c2 === GREATER) {
      this.closeTag();
    } else if (isS(c2)) {
      this.state = S_CLOSE_TAG_SAW_WHITE;
    } else if (c2 !== EOC) {
      this.fail("disallowed character in closing tag.");
    }
  }
  sCloseTagSawWhite() {
    switch (this.skipSpaces()) {
      case GREATER:
        this.closeTag();
        break;
      case EOC:
        break;
      default:
        this.fail("disallowed character in closing tag.");
    }
  }
  // END OF STATE ENGINE METHODS
  handleTextInRoot() {
    let { i: start, forbiddenState } = this;
    const { chunk, textHandler: handler } = this;
    scanLoop:
      while (true) {
        switch (this.getCode()) {
          case LESS: {
            this.state = S_OPEN_WAKA;
            if (handler !== void 0) {
              const { text } = this;
              const slice3 = chunk.slice(start, this.prevI);
              if (text.length !== 0) {
                handler(text + slice3);
                this.text = "";
              } else if (slice3.length !== 0) {
                handler(slice3);
              }
            }
            forbiddenState = FORBIDDEN_START;
            break scanLoop;
          }
          case AMP:
            this.state = S_ENTITY;
            this.entityReturnState = S_TEXT;
            if (handler !== void 0) {
              this.text += chunk.slice(start, this.prevI);
            }
            forbiddenState = FORBIDDEN_START;
            break scanLoop;
          case CLOSE_BRACKET:
            switch (forbiddenState) {
              case FORBIDDEN_START:
                forbiddenState = FORBIDDEN_BRACKET;
                break;
              case FORBIDDEN_BRACKET:
                forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                break;
              case FORBIDDEN_BRACKET_BRACKET:
                break;
              default:
                throw new Error("impossible state");
            }
            break;
          case GREATER:
            if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
              this.fail('the string "]]>" is disallowed in char data.');
            }
            forbiddenState = FORBIDDEN_START;
            break;
          case NL_LIKE:
            if (handler !== void 0) {
              this.text += `${chunk.slice(start, this.prevI)}
`;
            }
            start = this.i;
            forbiddenState = FORBIDDEN_START;
            break;
          case EOC:
            if (handler !== void 0) {
              this.text += chunk.slice(start);
            }
            break scanLoop;
          default:
            forbiddenState = FORBIDDEN_START;
        }
      }
    this.forbiddenState = forbiddenState;
  }
  handleTextOutsideRoot() {
    let { i: start } = this;
    const { chunk, textHandler: handler } = this;
    let nonSpace = false;
    outRootLoop:
      while (true) {
        const code = this.getCode();
        switch (code) {
          case LESS: {
            this.state = S_OPEN_WAKA;
            if (handler !== void 0) {
              const { text } = this;
              const slice3 = chunk.slice(start, this.prevI);
              if (text.length !== 0) {
                handler(text + slice3);
                this.text = "";
              } else if (slice3.length !== 0) {
                handler(slice3);
              }
            }
            break outRootLoop;
          }
          case AMP:
            this.state = S_ENTITY;
            this.entityReturnState = S_TEXT;
            if (handler !== void 0) {
              this.text += chunk.slice(start, this.prevI);
            }
            nonSpace = true;
            break outRootLoop;
          case NL_LIKE:
            if (handler !== void 0) {
              this.text += `${chunk.slice(start, this.prevI)}
`;
            }
            start = this.i;
            break;
          case EOC:
            if (handler !== void 0) {
              this.text += chunk.slice(start);
            }
            break outRootLoop;
          default:
            if (!isS(code)) {
              nonSpace = true;
            }
        }
      }
    if (!nonSpace) {
      return;
    }
    if (!this.sawRoot && !this.reportedTextBeforeRoot) {
      this.fail("text data outside of root node.");
      this.reportedTextBeforeRoot = true;
    }
    if (this.closedRoot && !this.reportedTextAfterRoot) {
      this.fail("text data outside of root node.");
      this.reportedTextAfterRoot = true;
    }
  }
  pushAttribNS(name, value) {
    var _a;
    const { prefix, local } = this.qname(name);
    const attr = { name, prefix, local, value };
    this.attribList.push(attr);
    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
    if (prefix === "xmlns") {
      const trimmed = value.trim();
      if (this.currentXMLVersion === "1.0" && trimmed === "") {
        this.fail("invalid attempt to undefine prefix in XML 1.0");
      }
      this.topNS[local] = trimmed;
      nsPairCheck(this, local, trimmed);
    } else if (name === "xmlns") {
      const trimmed = value.trim();
      this.topNS[""] = trimmed;
      nsPairCheck(this, "", trimmed);
    }
  }
  pushAttribPlain(name, value) {
    var _a;
    const attr = { name, value };
    this.attribList.push(attr);
    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
  }
  /**
   * End parsing. This performs final well-formedness checks and resets the
   * parser to a clean state.
   *
   * @returns this
   */
  end() {
    var _a, _b;
    if (!this.sawRoot) {
      this.fail("document must contain a root element.");
    }
    const { tags } = this;
    while (tags.length > 0) {
      const tag = tags.pop();
      this.fail(`unclosed tag: ${tag.name}`);
    }
    if (this.state !== S_BEGIN && this.state !== S_TEXT) {
      this.fail("unexpected end.");
    }
    const { text } = this;
    if (text.length !== 0) {
      (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
      this.text = "";
    }
    this._closed = true;
    (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
    this._init();
    return this;
  }
  /**
   * Resolve a namespace prefix.
   *
   * @param prefix The prefix to resolve.
   *
   * @returns The namespace URI or ``undefined`` if the prefix is not defined.
   */
  resolve(prefix) {
    var _a, _b;
    let uri = this.topNS[prefix];
    if (uri !== void 0) {
      return uri;
    }
    const { tags } = this;
    for (let index2 = tags.length - 1; index2 >= 0; index2--) {
      uri = tags[index2].ns[prefix];
      if (uri !== void 0) {
        return uri;
      }
    }
    uri = this.ns[prefix];
    if (uri !== void 0) {
      return uri;
    }
    return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
  }
  /**
   * Parse a qname into its prefix and local name parts.
   *
   * @param name The name to parse
   *
   * @returns
   */
  qname(name) {
    const colon = name.indexOf(":");
    if (colon === -1) {
      return { prefix: "", local: name };
    }
    const local = name.slice(colon + 1);
    const prefix = name.slice(0, colon);
    if (prefix === "" || local === "" || local.includes(":")) {
      this.fail(`malformed name: ${name}.`);
    }
    return { prefix, local };
  }
  processAttribsNS() {
    var _a;
    const { attribList } = this;
    const tag = this.tag;
    {
      const { prefix, local } = this.qname(tag.name);
      tag.prefix = prefix;
      tag.local = local;
      const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
      if (prefix !== "") {
        if (prefix === "xmlns") {
          this.fail('tags may not have "xmlns" as prefix.');
        }
        if (uri === "") {
          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
          tag.uri = prefix;
        }
      }
    }
    if (attribList.length === 0) {
      return;
    }
    const { attributes } = tag;
    const seen = /* @__PURE__ */ new Set();
    for (const attr of attribList) {
      const { name, prefix, local } = attr;
      let uri;
      let eqname;
      if (prefix === "") {
        uri = name === "xmlns" ? XMLNS_NAMESPACE : "";
        eqname = name;
      } else {
        uri = this.resolve(prefix);
        if (uri === void 0) {
          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
          uri = prefix;
        }
        eqname = `{${uri}}${local}`;
      }
      if (seen.has(eqname)) {
        this.fail(`duplicate attribute: ${eqname}.`);
      }
      seen.add(eqname);
      attr.uri = uri;
      attributes[name] = attr;
    }
    this.attribList = [];
  }
  processAttribsPlain() {
    const { attribList } = this;
    const attributes = this.tag.attributes;
    for (const { name, value } of attribList) {
      if (attributes[name] !== void 0) {
        this.fail(`duplicate attribute: ${name}.`);
      }
      attributes[name] = value;
    }
    this.attribList = [];
  }
  /**
   * Handle a complete open tag. This parser code calls this once it has seen
   * the whole tag. This method checks for well-formeness and then emits
   * ``onopentag``.
   */
  openTag() {
    var _a;
    this.processAttribs();
    const { tags } = this;
    const tag = this.tag;
    tag.isSelfClosing = false;
    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
    tags.push(tag);
    this.state = S_TEXT;
    this.name = "";
  }
  /**
   * Handle a complete self-closing tag. This parser code calls this once it has
   * seen the whole tag. This method checks for well-formeness and then emits
   * ``onopentag`` and ``onclosetag``.
   */
  openSelfClosingTag() {
    var _a, _b, _c;
    this.processAttribs();
    const { tags } = this;
    const tag = this.tag;
    tag.isSelfClosing = true;
    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
    (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
    const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
    if (top === null) {
      this.closedRoot = true;
    }
    this.state = S_TEXT;
    this.name = "";
  }
  /**
   * Handle a complete close tag. This parser code calls this once it has seen
   * the whole tag. This method checks for well-formeness and then emits
   * ``onclosetag``.
   */
  closeTag() {
    const { tags, name } = this;
    this.state = S_TEXT;
    this.name = "";
    if (name === "") {
      this.fail("weird empty close tag.");
      this.text += "</>";
      return;
    }
    const handler = this.closeTagHandler;
    let l = tags.length;
    while (l-- > 0) {
      const tag = this.tag = tags.pop();
      this.topNS = tag.ns;
      handler === null || handler === void 0 ? void 0 : handler(tag);
      if (tag.name === name) {
        break;
      }
      this.fail("unexpected close tag.");
    }
    if (l === 0) {
      this.closedRoot = true;
    } else if (l < 0) {
      this.fail(`unmatched closing tag: ${name}.`);
      this.text += `</${name}>`;
    }
  }
  /**
   * Resolves an entity. Makes any necessary well-formedness checks.
   *
   * @param entity The entity to resolve.
   *
   * @returns The parsed entity.
   */
  parseEntity(entity) {
    if (entity[0] !== "#") {
      const defined = this.ENTITIES[entity];
      if (defined !== void 0) {
        return defined;
      }
      this.fail(this.isName(entity) ? "undefined entity." : "disallowed character in entity name.");
      return `&${entity};`;
    }
    let num = NaN;
    if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
      num = parseInt(entity.slice(2), 16);
    } else if (/^#[0-9]+$/.test(entity)) {
      num = parseInt(entity.slice(1), 10);
    }
    if (!this.isChar(num)) {
      this.fail("malformed character entity.");
      return `&${entity};`;
    }
    return String.fromCodePoint(num);
  }
};
saxes.SaxesParser = SaxesParser$1;
const { SaxesParser: SaxesParser2 } = saxes;
const { PassThrough: PassThrough$7 } = readableExports$3;
const { bufferToString: bufferToString$1 } = browserBufferDecode;
var parseSax$4 = async function* (iterable) {
  if (iterable.pipe && !iterable[Symbol.asyncIterator]) {
    iterable = iterable.pipe(new PassThrough$7());
  }
  const saxesParser = new SaxesParser2();
  let error2;
  saxesParser.on("error", (err2) => {
    error2 = err2;
  });
  let events2 = [];
  saxesParser.on("opentag", (value) => events2.push({ eventType: "opentag", value }));
  saxesParser.on("text", (value) => events2.push({ eventType: "text", value }));
  saxesParser.on("closetag", (value) => events2.push({ eventType: "closetag", value }));
  for await (const chunk of iterable) {
    saxesParser.write(bufferToString$1(chunk));
    if (error2) throw error2;
    yield events2;
    events2 = [];
  }
};
const parseSax$3 = parseSax$4;
const XmlStream$f = xmlStream;
let BaseXform$1z = class BaseXform {
  // constructor(/* model, name */) {}
  // ============================================================
  // Virtual Interface
  prepare() {
  }
  render() {
  }
  parseOpen(node2) {
  }
  parseText(text) {
  }
  parseClose(name) {
  }
  reconcile(model, options) {
  }
  // ============================================================
  reset() {
    this.model = null;
    if (this.map) {
      Object.values(this.map).forEach((xform2) => {
        if (xform2 instanceof BaseXform) {
          xform2.reset();
        } else if (xform2.xform) {
          xform2.xform.reset();
        }
      });
    }
  }
  mergeModel(obj) {
    this.model = Object.assign(this.model || {}, obj);
  }
  async parse(saxParser) {
    for await (const events2 of saxParser) {
      for (const { eventType, value } of events2) {
        if (eventType === "opentag") {
          this.parseOpen(value);
        } else if (eventType === "text") {
          this.parseText(value);
        } else if (eventType === "closetag") {
          if (!this.parseClose(value.name)) {
            return this.model;
          }
        }
      }
    }
    return this.model;
  }
  async parseStream(stream2) {
    return this.parse(parseSax$3(stream2));
  }
  get xml() {
    return this.toXml(this.model);
  }
  toXml(model) {
    const xmlStream2 = new XmlStream$f();
    this.render(xmlStream2, model);
    return xmlStream2.xml;
  }
  // ============================================================
  // Useful Utilities
  static toAttribute(value, dflt, always = false) {
    if (value === void 0) {
      if (always) {
        return dflt;
      }
    } else if (always || value !== dflt) {
      return value.toString();
    }
    return void 0;
  }
  static toStringAttribute(value, dflt, always = false) {
    return BaseXform.toAttribute(value, dflt, always);
  }
  static toStringValue(attr, dflt) {
    return attr === void 0 ? dflt : attr;
  }
  static toBoolAttribute(value, dflt, always = false) {
    if (value === void 0) {
      if (always) {
        return dflt;
      }
    } else if (always || value !== dflt) {
      return value ? "1" : "0";
    }
    return void 0;
  }
  static toBoolValue(attr, dflt) {
    return attr === void 0 ? dflt : attr === "1";
  }
  static toIntAttribute(value, dflt, always = false) {
    return BaseXform.toAttribute(value, dflt, always);
  }
  static toIntValue(attr, dflt) {
    return attr === void 0 ? dflt : parseInt(attr, 10);
  }
  static toFloatAttribute(value, dflt, always = false) {
    return BaseXform.toAttribute(value, dflt, always);
  }
  static toFloatValue(attr, dflt) {
    return attr === void 0 ? dflt : parseFloat(attr);
  }
};
var baseXform = BaseXform$1z;
const BaseXform$1y = baseXform;
const XmlStream$e = xmlStream;
function build(xmlStream2, model) {
  xmlStream2.openNode(model.tag, model.$);
  if (model.c) {
    model.c.forEach((child) => {
      build(xmlStream2, child);
    });
  }
  if (model.t) {
    xmlStream2.writeText(model.t);
  }
  xmlStream2.closeNode();
}
let StaticXform$5 = class StaticXform extends BaseXform$1y {
  constructor(model) {
    super();
    this._model = model;
  }
  render(xmlStream2) {
    if (!this._xml) {
      const stream2 = new XmlStream$e();
      build(stream2, this._model);
      this._xml = stream2.xml;
    }
    xmlStream2.writeXml(this._xml);
  }
  parseOpen() {
    return true;
  }
  parseText() {
  }
  parseClose(name) {
    switch (name) {
      case this._model.tag:
        return false;
      default:
        return true;
    }
  }
};
var staticXform = StaticXform$5;
const BaseXform$1x = baseXform;
let ListXform$7 = class ListXform extends BaseXform$1x {
  constructor(options) {
    super();
    this.tag = options.tag;
    this.always = !!options.always;
    this.count = options.count;
    this.empty = options.empty;
    this.$count = options.$count || "count";
    this.$ = options.$;
    this.childXform = options.childXform;
    this.maxItems = options.maxItems;
  }
  prepare(model, options) {
    const { childXform } = this;
    if (model) {
      model.forEach((childModel, index2) => {
        options.index = index2;
        childXform.prepare(childModel, options);
      });
    }
  }
  render(xmlStream2, model) {
    if (this.always || model && model.length) {
      xmlStream2.openNode(this.tag, this.$);
      if (this.count) {
        xmlStream2.addAttribute(this.$count, model && model.length || 0);
      }
      const { childXform } = this;
      (model || []).forEach((childModel, index2) => {
        childXform.render(xmlStream2, childModel, index2);
      });
      xmlStream2.closeNode();
    } else if (this.empty) {
      xmlStream2.leafNode(this.tag);
    }
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.model = [];
        return true;
      default:
        if (this.childXform.parseOpen(node2)) {
          this.parser = this.childXform;
          return true;
        }
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.push(this.parser.model);
        this.parser = void 0;
        if (this.maxItems && this.model.length > this.maxItems) {
          throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);
        }
      }
      return true;
    }
    return false;
  }
  reconcile(model, options) {
    if (model) {
      const { childXform } = this;
      model.forEach((childModel) => {
        childXform.reconcile(childModel, options);
      });
    }
  }
};
var listXform = ListXform$7;
const BaseXform$1w = baseXform;
let ColorXform$7 = class ColorXform extends BaseXform$1w {
  constructor(name) {
    super();
    this.name = name || "color";
  }
  get tag() {
    return this.name;
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.openNode(this.name);
      if (model.argb) {
        xmlStream2.addAttribute("rgb", model.argb);
      } else if (model.theme !== void 0) {
        xmlStream2.addAttribute("theme", model.theme);
        if (model.tint !== void 0) {
          xmlStream2.addAttribute("tint", model.tint);
        }
      } else if (model.indexed !== void 0) {
        xmlStream2.addAttribute("indexed", model.indexed);
      } else {
        xmlStream2.addAttribute("auto", "1");
      }
      xmlStream2.closeNode();
      return true;
    }
    return false;
  }
  parseOpen(node2) {
    if (node2.name === this.name) {
      if (node2.attributes.rgb) {
        this.model = { argb: node2.attributes.rgb };
      } else if (node2.attributes.theme) {
        this.model = { theme: parseInt(node2.attributes.theme, 10) };
        if (node2.attributes.tint) {
          this.model.tint = parseFloat(node2.attributes.tint);
        }
      } else if (node2.attributes.indexed) {
        this.model = { indexed: parseInt(node2.attributes.indexed, 10) };
      } else {
        this.model = void 0;
      }
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var colorXform = ColorXform$7;
const BaseXform$1v = baseXform;
let BooleanXform$1 = class BooleanXform extends BaseXform$1v {
  constructor(options) {
    super();
    this.tag = options.tag;
    this.attr = options.attr;
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.openNode(this.tag);
      xmlStream2.closeNode();
    }
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      this.model = true;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var booleanXform = BooleanXform$1;
const BaseXform$1u = baseXform;
let IntegerXform$3 = class IntegerXform extends BaseXform$1u {
  constructor(options) {
    super();
    this.tag = options.tag;
    this.attr = options.attr;
    this.attrs = options.attrs;
    this.zero = options.zero;
  }
  render(xmlStream2, model) {
    if (model || this.zero) {
      xmlStream2.openNode(this.tag);
      if (this.attrs) {
        xmlStream2.addAttributes(this.attrs);
      }
      if (this.attr) {
        xmlStream2.addAttribute(this.attr, model);
      } else {
        xmlStream2.writeText(model);
      }
      xmlStream2.closeNode();
    }
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      if (this.attr) {
        this.model = parseInt(node2.attributes[this.attr], 10);
      } else {
        this.text = [];
      }
      return true;
    }
    return false;
  }
  parseText(text) {
    if (!this.attr) {
      this.text.push(text);
    }
  }
  parseClose() {
    if (!this.attr) {
      this.model = parseInt(this.text.join("") || 0, 10);
    }
    return false;
  }
};
var integerXform = IntegerXform$3;
const BaseXform$1t = baseXform;
let StringXform$3 = class StringXform extends BaseXform$1t {
  constructor(options) {
    super();
    this.tag = options.tag;
    this.attr = options.attr;
    this.attrs = options.attrs;
  }
  render(xmlStream2, model) {
    if (model !== void 0) {
      xmlStream2.openNode(this.tag);
      if (this.attrs) {
        xmlStream2.addAttributes(this.attrs);
      }
      if (this.attr) {
        xmlStream2.addAttribute(this.attr, model);
      } else {
        xmlStream2.writeText(model);
      }
      xmlStream2.closeNode();
    }
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      if (this.attr) {
        this.model = node2.attributes[this.attr];
      } else {
        this.text = [];
      }
    }
  }
  parseText(text) {
    if (!this.attr) {
      this.text.push(text);
    }
  }
  parseClose() {
    if (!this.attr) {
      this.model = this.text.join("");
    }
    return false;
  }
};
var stringXform = StringXform$3;
const BaseXform$1s = baseXform;
let UnderlineXform$1 = class UnderlineXform extends BaseXform$1s {
  constructor(model) {
    super();
    this.model = model;
  }
  get tag() {
    return "u";
  }
  render(xmlStream2, model) {
    model = model || this.model;
    if (model === true) {
      xmlStream2.leafNode("u");
    } else {
      const attr = UnderlineXform.Attributes[model];
      if (attr) {
        xmlStream2.leafNode("u", attr);
      }
    }
  }
  parseOpen(node2) {
    if (node2.name === "u") {
      this.model = node2.attributes.val || true;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
UnderlineXform$1.Attributes = {
  single: {},
  double: { val: "double" },
  singleAccounting: { val: "singleAccounting" },
  doubleAccounting: { val: "doubleAccounting" }
};
var underlineXform = UnderlineXform$1;
const ColorXform$6 = colorXform;
const BooleanXform2 = booleanXform;
const IntegerXform$2 = integerXform;
const StringXform$2 = stringXform;
const UnderlineXform2 = underlineXform;
const _$d = underDash;
const BaseXform$1r = baseXform;
let FontXform$3 = class FontXform extends BaseXform$1r {
  constructor(options) {
    super();
    this.options = options || FontXform.OPTIONS;
    this.map = {
      b: { prop: "bold", xform: new BooleanXform2({ tag: "b", attr: "val" }) },
      i: { prop: "italic", xform: new BooleanXform2({ tag: "i", attr: "val" }) },
      u: { prop: "underline", xform: new UnderlineXform2() },
      charset: { prop: "charset", xform: new IntegerXform$2({ tag: "charset", attr: "val" }) },
      color: { prop: "color", xform: new ColorXform$6() },
      condense: { prop: "condense", xform: new BooleanXform2({ tag: "condense", attr: "val" }) },
      extend: { prop: "extend", xform: new BooleanXform2({ tag: "extend", attr: "val" }) },
      family: { prop: "family", xform: new IntegerXform$2({ tag: "family", attr: "val" }) },
      outline: { prop: "outline", xform: new BooleanXform2({ tag: "outline", attr: "val" }) },
      vertAlign: { prop: "vertAlign", xform: new StringXform$2({ tag: "vertAlign", attr: "val" }) },
      scheme: { prop: "scheme", xform: new StringXform$2({ tag: "scheme", attr: "val" }) },
      shadow: { prop: "shadow", xform: new BooleanXform2({ tag: "shadow", attr: "val" }) },
      strike: { prop: "strike", xform: new BooleanXform2({ tag: "strike", attr: "val" }) },
      sz: { prop: "size", xform: new IntegerXform$2({ tag: "sz", attr: "val" }) }
    };
    this.map[this.options.fontNameTag] = {
      prop: "name",
      xform: new StringXform$2({ tag: this.options.fontNameTag, attr: "val" })
    };
  }
  get tag() {
    return this.options.tagName;
  }
  render(xmlStream2, model) {
    const { map: map3 } = this;
    xmlStream2.openNode(this.options.tagName);
    _$d.each(this.map, (defn, tag) => {
      map3[tag].xform.render(xmlStream2, model[defn.prop]);
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    if (this.map[node2.name]) {
      this.parser = this.map[node2.name].xform;
      return this.parser.parseOpen(node2);
    }
    switch (node2.name) {
      case this.options.tagName:
        this.model = {};
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser && !this.parser.parseClose(name)) {
      const item = this.map[name];
      if (this.parser.model) {
        this.model[item.prop] = this.parser.model;
      }
      this.parser = void 0;
      return true;
    }
    switch (name) {
      case this.options.tagName:
        return false;
      default:
        return true;
    }
  }
};
FontXform$3.OPTIONS = {
  tagName: "font",
  fontNameTag: "name"
};
var fontXform = FontXform$3;
const BaseXform$1q = baseXform;
const ColorXform$5 = colorXform;
class StopXform extends BaseXform$1q {
  constructor() {
    super();
    this.map = {
      color: new ColorXform$5()
    };
  }
  get tag() {
    return "stop";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("stop");
    xmlStream2.addAttribute("position", model.position);
    this.map.color.render(xmlStream2, model.color);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "stop":
        this.model = {
          position: parseFloat(node2.attributes.position)
        };
        return true;
      case "color":
        this.parser = this.map.color;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.color = this.parser.model;
        this.parser = void 0;
      }
      return true;
    }
    return false;
  }
}
class PatternFillXform extends BaseXform$1q {
  constructor() {
    super();
    this.map = {
      fgColor: new ColorXform$5("fgColor"),
      bgColor: new ColorXform$5("bgColor")
    };
  }
  get name() {
    return "pattern";
  }
  get tag() {
    return "patternFill";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("patternFill");
    xmlStream2.addAttribute("patternType", model.pattern);
    if (model.fgColor) {
      this.map.fgColor.render(xmlStream2, model.fgColor);
    }
    if (model.bgColor) {
      this.map.bgColor.render(xmlStream2, model.bgColor);
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "patternFill":
        this.model = {
          type: "pattern",
          pattern: node2.attributes.patternType
        };
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
          return true;
        }
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        if (this.parser.model) {
          this.model[name] = this.parser.model;
        }
        this.parser = void 0;
      }
      return true;
    }
    return false;
  }
}
class GradientFillXform extends BaseXform$1q {
  constructor() {
    super();
    this.map = {
      stop: new StopXform()
    };
  }
  get name() {
    return "gradient";
  }
  get tag() {
    return "gradientFill";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("gradientFill");
    switch (model.gradient) {
      case "angle":
        xmlStream2.addAttribute("degree", model.degree);
        break;
      case "path":
        xmlStream2.addAttribute("type", "path");
        if (model.center.left) {
          xmlStream2.addAttribute("left", model.center.left);
          if (model.center.right === void 0) {
            xmlStream2.addAttribute("right", model.center.left);
          }
        }
        if (model.center.right) {
          xmlStream2.addAttribute("right", model.center.right);
        }
        if (model.center.top) {
          xmlStream2.addAttribute("top", model.center.top);
          if (model.center.bottom === void 0) {
            xmlStream2.addAttribute("bottom", model.center.top);
          }
        }
        if (model.center.bottom) {
          xmlStream2.addAttribute("bottom", model.center.bottom);
        }
        break;
    }
    const stopXform = this.map.stop;
    model.stops.forEach((stopModel) => {
      stopXform.render(xmlStream2, stopModel);
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "gradientFill": {
        const model = this.model = {
          stops: []
        };
        if (node2.attributes.degree) {
          model.gradient = "angle";
          model.degree = parseInt(node2.attributes.degree, 10);
        } else if (node2.attributes.type === "path") {
          model.gradient = "path";
          model.center = {
            left: node2.attributes.left ? parseFloat(node2.attributes.left) : 0,
            top: node2.attributes.top ? parseFloat(node2.attributes.top) : 0
          };
          if (node2.attributes.right !== node2.attributes.left) {
            model.center.right = node2.attributes.right ? parseFloat(node2.attributes.right) : 0;
          }
          if (node2.attributes.bottom !== node2.attributes.top) {
            model.center.bottom = node2.attributes.bottom ? parseFloat(node2.attributes.bottom) : 0;
          }
        }
        return true;
      }
      case "stop":
        this.parser = this.map.stop;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.stops.push(this.parser.model);
        this.parser = void 0;
      }
      return true;
    }
    return false;
  }
}
let FillXform$2 = class FillXform extends BaseXform$1q {
  constructor() {
    super();
    this.map = {
      patternFill: new PatternFillXform(),
      gradientFill: new GradientFillXform()
    };
  }
  get tag() {
    return "fill";
  }
  render(xmlStream2, model) {
    xmlStream2.addRollback();
    xmlStream2.openNode("fill");
    switch (model.type) {
      case "pattern":
        this.map.patternFill.render(xmlStream2, model);
        break;
      case "gradient":
        this.map.gradientFill.render(xmlStream2, model);
        break;
      default:
        xmlStream2.rollback();
        return;
    }
    xmlStream2.closeNode();
    xmlStream2.commit();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "fill":
        this.model = {};
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
          return true;
        }
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model = this.parser.model;
        this.model.type = this.parser.name;
        this.parser = void 0;
      }
      return true;
    }
    return false;
  }
  validStyle(value) {
    return FillXform.validPatternValues[value];
  }
};
FillXform$2.validPatternValues = [
  "none",
  "solid",
  "darkVertical",
  "darkGray",
  "mediumGray",
  "lightGray",
  "gray125",
  "gray0625",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "lightGrid"
].reduce((p, v) => {
  p[v] = true;
  return p;
}, {});
FillXform$2.StopXform = StopXform;
FillXform$2.PatternFillXform = PatternFillXform;
FillXform$2.GradientFillXform = GradientFillXform;
var fillXform = FillXform$2;
const BaseXform$1p = baseXform;
const utils$d = utils_1;
const ColorXform$4 = colorXform;
class EdgeXform extends BaseXform$1p {
  constructor(name) {
    super();
    this.name = name;
    this.map = {
      color: new ColorXform$4()
    };
  }
  get tag() {
    return this.name;
  }
  render(xmlStream2, model, defaultColor) {
    const color = model && model.color || defaultColor || this.defaultColor;
    xmlStream2.openNode(this.name);
    if (model && model.style) {
      xmlStream2.addAttribute("style", model.style);
      if (color) {
        this.map.color.render(xmlStream2, color);
      }
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.name: {
        const { style } = node2.attributes;
        if (style) {
          this.model = {
            style
          };
        } else {
          this.model = void 0;
        }
        return true;
      }
      case "color":
        this.parser = this.map.color;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    if (name === this.name) {
      if (this.map.color.model) {
        if (!this.model) {
          this.model = {};
        }
        this.model.color = this.map.color.model;
      }
    }
    return false;
  }
  validStyle(value) {
    return EdgeXform.validStyleValues[value];
  }
}
EdgeXform.validStyleValues = [
  "thin",
  "dashed",
  "dotted",
  "dashDot",
  "hair",
  "dashDotDot",
  "slantDashDot",
  "mediumDashed",
  "mediumDashDotDot",
  "mediumDashDot",
  "medium",
  "double",
  "thick"
].reduce((p, v) => {
  p[v] = true;
  return p;
}, {});
let BorderXform$2 = class BorderXform extends BaseXform$1p {
  constructor() {
    super();
    this.map = {
      top: new EdgeXform("top"),
      left: new EdgeXform("left"),
      bottom: new EdgeXform("bottom"),
      right: new EdgeXform("right"),
      diagonal: new EdgeXform("diagonal")
    };
  }
  render(xmlStream2, model) {
    const { color } = model;
    xmlStream2.openNode("border");
    if (model.diagonal && model.diagonal.style) {
      if (model.diagonal.up) {
        xmlStream2.addAttribute("diagonalUp", "1");
      }
      if (model.diagonal.down) {
        xmlStream2.addAttribute("diagonalDown", "1");
      }
    }
    function add(edgeModel, edgeXform) {
      if (edgeModel && !edgeModel.color && model.color) {
        edgeModel = {
          ...edgeModel,
          color: model.color
        };
      }
      edgeXform.render(xmlStream2, edgeModel, color);
    }
    add(model.left, this.map.left);
    add(model.right, this.map.right);
    add(model.top, this.map.top);
    add(model.bottom, this.map.bottom);
    add(model.diagonal, this.map.diagonal);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "border":
        this.reset();
        this.diagonalUp = utils$d.parseBoolean(node2.attributes.diagonalUp);
        this.diagonalDown = utils$d.parseBoolean(node2.attributes.diagonalDown);
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
          return true;
        }
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    if (name === "border") {
      const model = this.model = {};
      const add = function(key, edgeModel, extensions) {
        if (edgeModel) {
          if (extensions) {
            Object.assign(edgeModel, extensions);
          }
          model[key] = edgeModel;
        }
      };
      add("left", this.map.left.model);
      add("right", this.map.right.model);
      add("top", this.map.top.model);
      add("bottom", this.map.bottom.model);
      add("diagonal", this.map.diagonal.model, { up: this.diagonalUp, down: this.diagonalDown });
    }
    return false;
  }
};
var borderXform = BorderXform$2;
var defaultnumformats = {
  0: { f: "General" },
  1: { f: "0" },
  2: { f: "0.00" },
  3: { f: "#,##0" },
  4: { f: "#,##0.00" },
  9: { f: "0%" },
  10: { f: "0.00%" },
  11: { f: "0.00E+00" },
  12: { f: "# ?/?" },
  13: { f: "# ??/??" },
  14: { f: "mm-dd-yy" },
  15: { f: "d-mmm-yy" },
  16: { f: "d-mmm" },
  17: { f: "mmm-yy" },
  18: { f: "h:mm AM/PM" },
  19: { f: "h:mm:ss AM/PM" },
  20: { f: "h:mm" },
  21: { f: "h:mm:ss" },
  22: { f: 'm/d/yy "h":mm' },
  27: {
    "zh-tw": "[$-404]e/m/d",
    "zh-cn": 'yyyy"年"m"月"',
    "ja-jp": "[$-411]ge.m.d",
    "ko-kr": 'yyyy"年" mm"月" dd"日"'
  },
  28: {
    "zh-tw": '[$-404]e"年"m"月"d"日"',
    "zh-cn": 'm"月"d"日"',
    "ja-jp": '[$-411]ggge"年"m"月"d"日"',
    "ko-kr": "mm-dd"
  },
  29: {
    "zh-tw": '[$-404]e"年"m"月"d"日"',
    "zh-cn": 'm"月"d"日"',
    "ja-jp": '[$-411]ggge"年"m"月"d"日"',
    "ko-kr": "mm-dd"
  },
  30: { "zh-tw": "m/d/yy ", "zh-cn": "m-d-yy", "ja-jp": "m/d/yy", "ko-kr": "mm-dd-yy" },
  31: {
    "zh-tw": 'yyyy"年"m"月"d"日"',
    "zh-cn": 'yyyy"年"m"月"d"日"',
    "ja-jp": 'yyyy"年"m"月"d"日"',
    "ko-kr": 'yyyy"년" mm"월" dd"일"'
  },
  32: {
    "zh-tw": 'hh"時"mm"分"',
    "zh-cn": 'h"时"mm"分"',
    "ja-jp": 'h"時"mm"分"',
    "ko-kr": 'h"시" mm"분"'
  },
  33: {
    "zh-tw": 'hh"時"mm"分"ss"秒"',
    "zh-cn": 'h"时"mm"分"ss"秒"',
    "ja-jp": 'h"時"mm"分"ss"秒"',
    "ko-kr": 'h"시" mm"분" ss"초"'
  },
  34: {
    "zh-tw": '上午/下午 hh"時"mm"分"',
    "zh-cn": '上午/下午 h"时"mm"分"',
    "ja-jp": 'yyyy"年"m"月"',
    "ko-kr": "yyyy-mm-dd"
  },
  35: {
    "zh-tw": '上午/下午 hh"時"mm"分"ss"秒"',
    "zh-cn": '上午/下午 h"时"mm"分"ss"秒"',
    "ja-jp": 'm"月"d"日"',
    "ko-kr": "yyyy-mm-dd"
  },
  36: {
    "zh-tw": "[$-404]e/m/d",
    "zh-cn": 'yyyy"年"m"月"',
    "ja-jp": "[$-411]ge.m.d",
    "ko-kr": 'yyyy"年" mm"月" dd"日"'
  },
  37: { f: "#,##0 ;(#,##0)" },
  38: { f: "#,##0 ;[Red](#,##0)" },
  39: { f: "#,##0.00 ;(#,##0.00)" },
  40: { f: "#,##0.00 ;[Red](#,##0.00)" },
  45: { f: "mm:ss" },
  46: { f: "[h]:mm:ss" },
  47: { f: "mmss.0" },
  48: { f: "##0.0E+0" },
  49: { f: "@" },
  50: {
    "zh-tw": "[$-404]e/m/d",
    "zh-cn": 'yyyy"年"m"月"',
    "ja-jp": "[$-411]ge.m.d",
    "ko-kr": 'yyyy"年" mm"月" dd"日"'
  },
  51: {
    "zh-tw": '[$-404]e"年"m"月"d"日"',
    "zh-cn": 'm"月"d"日"',
    "ja-jp": '[$-411]ggge"年"m"月"d"日"',
    "ko-kr": "mm-dd"
  },
  52: {
    "zh-tw": '上午/下午 hh"時"mm"分"',
    "zh-cn": 'yyyy"年"m"月"',
    "ja-jp": 'yyyy"年"m"月"',
    "ko-kr": "yyyy-mm-dd"
  },
  53: {
    "zh-tw": '上午/下午 hh"時"mm"分"ss"秒"',
    "zh-cn": 'm"月"d"日"',
    "ja-jp": 'm"月"d"日"',
    "ko-kr": "yyyy-mm-dd"
  },
  54: {
    "zh-tw": '[$-404]e"年"m"月"d"日"',
    "zh-cn": 'm"月"d"日"',
    "ja-jp": '[$-411]ggge"年"m"月"d"日"',
    "ko-kr": "mm-dd"
  },
  55: {
    "zh-tw": '上午/下午 hh"時"mm"分"',
    "zh-cn": '上午/下午 h"时"mm"分"',
    "ja-jp": 'yyyy"年"m"月"',
    "ko-kr": "yyyy-mm-dd"
  },
  56: {
    "zh-tw": '上午/下午 hh"時"mm"分"ss"秒"',
    "zh-cn": '上午/下午 h"时"mm"分"ss"秒"',
    "ja-jp": 'm"月"d"日"',
    "ko-kr": "yyyy-mm-dd"
  },
  57: {
    "zh-tw": "[$-404]e/m/d",
    "zh-cn": 'yyyy"年"m"月"',
    "ja-jp": "[$-411]ge.m.d",
    "ko-kr": 'yyyy"年" mm"月" dd"日"'
  },
  58: {
    "zh-tw": '[$-404]e"年"m"月"d"日"',
    "zh-cn": 'm"月"d"日"',
    "ja-jp": '[$-411]ggge"年"m"月"d"日"',
    "ko-kr": "mm-dd"
  },
  59: { "th-th": "t0" },
  60: { "th-th": "t0.00" },
  61: { "th-th": "t#,##0" },
  62: { "th-th": "t#,##0.00" },
  67: { "th-th": "t0%" },
  68: { "th-th": "t0.00%" },
  69: { "th-th": "t# ?/?" },
  70: { "th-th": "t# ??/??" },
  81: { "th-th": "d/m/bb" }
};
const _$c = underDash;
const defaultNumFormats = defaultnumformats;
const BaseXform$1o = baseXform;
function hashDefaultFormats() {
  const hash = {};
  _$c.each(defaultNumFormats, (dnf, id) => {
    if (dnf.f) {
      hash[dnf.f] = parseInt(id, 10);
    }
  });
  return hash;
}
const defaultFmtHash = hashDefaultFormats();
let NumFmtXform$2 = class NumFmtXform extends BaseXform$1o {
  constructor(id, formatCode) {
    super();
    this.id = id;
    this.formatCode = formatCode;
  }
  get tag() {
    return "numFmt";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode("numFmt", { numFmtId: model.id, formatCode: model.formatCode });
  }
  parseOpen(node2) {
    switch (node2.name) {
      case "numFmt":
        this.model = {
          id: parseInt(node2.attributes.numFmtId, 10),
          formatCode: node2.attributes.formatCode.replace(/[\\](.)/g, "$1")
        };
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
NumFmtXform$2.getDefaultFmtId = function getDefaultFmtId(formatCode) {
  return defaultFmtHash[formatCode];
};
NumFmtXform$2.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {
  return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;
};
var numfmtXform = NumFmtXform$2;
const Enums$4 = enums;
const utils$c = utils_1;
const BaseXform$1n = baseXform;
const validation$1 = {
  horizontalValues: [
    "left",
    "center",
    "right",
    "fill",
    "centerContinuous",
    "distributed",
    "justify"
  ].reduce((p, v) => {
    p[v] = true;
    return p;
  }, {}),
  horizontal(value) {
    return this.horizontalValues[value] ? value : void 0;
  },
  verticalValues: ["top", "middle", "bottom", "distributed", "justify"].reduce((p, v) => {
    p[v] = true;
    return p;
  }, {}),
  vertical(value) {
    if (value === "middle") return "center";
    return this.verticalValues[value] ? value : void 0;
  },
  wrapText(value) {
    return value ? true : void 0;
  },
  shrinkToFit(value) {
    return value ? true : void 0;
  },
  textRotation(value) {
    switch (value) {
      case "vertical":
        return value;
      default:
        value = utils$c.validInt(value);
        return value >= -90 && value <= 90 ? value : void 0;
    }
  },
  indent(value) {
    value = utils$c.validInt(value);
    return Math.max(0, value);
  },
  readingOrder(value) {
    switch (value) {
      case "ltr":
        return Enums$4.ReadingOrder.LeftToRight;
      case "rtl":
        return Enums$4.ReadingOrder.RightToLeft;
      default:
        return void 0;
    }
  }
};
const textRotationXform = {
  toXml(textRotation) {
    textRotation = validation$1.textRotation(textRotation);
    if (textRotation) {
      if (textRotation === "vertical") {
        return 255;
      }
      const tr = Math.round(textRotation);
      if (tr >= 0 && tr <= 90) {
        return tr;
      }
      if (tr < 0 && tr >= -90) {
        return 90 - tr;
      }
    }
    return void 0;
  },
  toModel(textRotation) {
    const tr = utils$c.validInt(textRotation);
    if (tr !== void 0) {
      if (tr === 255) {
        return "vertical";
      }
      if (tr >= 0 && tr <= 90) {
        return tr;
      }
      if (tr > 90 && tr <= 180) {
        return 90 - tr;
      }
    }
    return void 0;
  }
};
let AlignmentXform$2 = class AlignmentXform extends BaseXform$1n {
  get tag() {
    return "alignment";
  }
  render(xmlStream2, model) {
    xmlStream2.addRollback();
    xmlStream2.openNode("alignment");
    let isValid = false;
    function add(name, value) {
      if (value) {
        xmlStream2.addAttribute(name, value);
        isValid = true;
      }
    }
    add("horizontal", validation$1.horizontal(model.horizontal));
    add("vertical", validation$1.vertical(model.vertical));
    add("wrapText", validation$1.wrapText(model.wrapText) ? "1" : false);
    add("shrinkToFit", validation$1.shrinkToFit(model.shrinkToFit) ? "1" : false);
    add("indent", validation$1.indent(model.indent));
    add("textRotation", textRotationXform.toXml(model.textRotation));
    add("readingOrder", validation$1.readingOrder(model.readingOrder));
    xmlStream2.closeNode();
    if (isValid) {
      xmlStream2.commit();
    } else {
      xmlStream2.rollback();
    }
  }
  parseOpen(node2) {
    const model = {};
    let valid = false;
    function add(truthy, name, value) {
      if (truthy) {
        model[name] = value;
        valid = true;
      }
    }
    add(node2.attributes.horizontal, "horizontal", node2.attributes.horizontal);
    add(
      node2.attributes.vertical,
      "vertical",
      node2.attributes.vertical === "center" ? "middle" : node2.attributes.vertical
    );
    add(node2.attributes.wrapText, "wrapText", utils$c.parseBoolean(node2.attributes.wrapText));
    add(node2.attributes.shrinkToFit, "shrinkToFit", utils$c.parseBoolean(node2.attributes.shrinkToFit));
    add(node2.attributes.indent, "indent", parseInt(node2.attributes.indent, 10));
    add(
      node2.attributes.textRotation,
      "textRotation",
      textRotationXform.toModel(node2.attributes.textRotation)
    );
    add(
      node2.attributes.readingOrder,
      "readingOrder",
      node2.attributes.readingOrder === "2" ? "rtl" : "ltr"
    );
    this.model = valid ? model : null;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var alignmentXform = AlignmentXform$2;
const BaseXform$1m = baseXform;
const validation = {
  boolean(value, dflt) {
    if (value === void 0) {
      return dflt;
    }
    return value;
  }
};
let ProtectionXform$2 = class ProtectionXform extends BaseXform$1m {
  get tag() {
    return "protection";
  }
  render(xmlStream2, model) {
    xmlStream2.addRollback();
    xmlStream2.openNode("protection");
    let isValid = false;
    function add(name, value) {
      if (value !== void 0) {
        xmlStream2.addAttribute(name, value);
        isValid = true;
      }
    }
    add("locked", validation.boolean(model.locked, true) ? void 0 : "0");
    add("hidden", validation.boolean(model.hidden, false) ? "1" : void 0);
    xmlStream2.closeNode();
    if (isValid) {
      xmlStream2.commit();
    } else {
      xmlStream2.rollback();
    }
  }
  parseOpen(node2) {
    const model = {
      locked: !(node2.attributes.locked === "0"),
      hidden: node2.attributes.hidden === "1"
    };
    const isSignificant = !model.locked || model.hidden;
    this.model = isSignificant ? model : null;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var protectionXform = ProtectionXform$2;
const BaseXform$1l = baseXform;
const AlignmentXform$1 = alignmentXform;
const ProtectionXform$1 = protectionXform;
let StyleXform$1 = class StyleXform extends BaseXform$1l {
  constructor(options) {
    super();
    this.xfId = !!(options && options.xfId);
    this.map = {
      alignment: new AlignmentXform$1(),
      protection: new ProtectionXform$1()
    };
  }
  get tag() {
    return "xf";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("xf", {
      numFmtId: model.numFmtId || 0,
      fontId: model.fontId || 0,
      fillId: model.fillId || 0,
      borderId: model.borderId || 0
    });
    if (this.xfId) {
      xmlStream2.addAttribute("xfId", model.xfId || 0);
    }
    if (model.numFmtId) {
      xmlStream2.addAttribute("applyNumberFormat", "1");
    }
    if (model.fontId) {
      xmlStream2.addAttribute("applyFont", "1");
    }
    if (model.fillId) {
      xmlStream2.addAttribute("applyFill", "1");
    }
    if (model.borderId) {
      xmlStream2.addAttribute("applyBorder", "1");
    }
    if (model.alignment) {
      xmlStream2.addAttribute("applyAlignment", "1");
    }
    if (model.protection) {
      xmlStream2.addAttribute("applyProtection", "1");
    }
    if (model.alignment) {
      this.map.alignment.render(xmlStream2, model.alignment);
    }
    if (model.protection) {
      this.map.protection.render(xmlStream2, model.protection);
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "xf":
        this.model = {
          numFmtId: parseInt(node2.attributes.numFmtId, 10),
          fontId: parseInt(node2.attributes.fontId, 10),
          fillId: parseInt(node2.attributes.fillId, 10),
          borderId: parseInt(node2.attributes.borderId, 10)
        };
        if (this.xfId) {
          this.model.xfId = parseInt(node2.attributes.xfId, 10);
        }
        return true;
      case "alignment":
        this.parser = this.map.alignment;
        this.parser.parseOpen(node2);
        return true;
      case "protection":
        this.parser = this.map.protection;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        if (this.map.protection === this.parser) {
          this.model.protection = this.parser.model;
        } else {
          this.model.alignment = this.parser.model;
        }
        this.parser = void 0;
      }
      return true;
    }
    return name !== "xf";
  }
};
var styleXform = StyleXform$1;
const BaseXform$1k = baseXform;
const AlignmentXform2 = alignmentXform;
const BorderXform$1 = borderXform;
const FillXform$1 = fillXform;
const FontXform$2 = fontXform;
const NumFmtXform$1 = numfmtXform;
const ProtectionXform2 = protectionXform;
let DxfXform$1 = class DxfXform extends BaseXform$1k {
  constructor() {
    super();
    this.map = {
      alignment: new AlignmentXform2(),
      border: new BorderXform$1(),
      fill: new FillXform$1(),
      font: new FontXform$2(),
      numFmt: new NumFmtXform$1(),
      protection: new ProtectionXform2()
    };
  }
  get tag() {
    return "dxf";
  }
  // how do we generate dxfid?
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    if (model.font) {
      this.map.font.render(xmlStream2, model.font);
    }
    if (model.numFmt && model.numFmtId) {
      const numFmtModel = { id: model.numFmtId, formatCode: model.numFmt };
      this.map.numFmt.render(xmlStream2, numFmtModel);
    }
    if (model.fill) {
      this.map.fill.render(xmlStream2, model.fill);
    }
    if (model.alignment) {
      this.map.alignment.render(xmlStream2, model.alignment);
    }
    if (model.border) {
      this.map.border.render(xmlStream2, model.border);
    }
    if (model.protection) {
      this.map.protection.render(xmlStream2, model.protection);
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        return true;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    if (name === this.tag) {
      this.model = {
        alignment: this.map.alignment.model,
        border: this.map.border.model,
        fill: this.map.fill.model,
        font: this.map.font.model,
        numFmt: this.map.numFmt.model,
        protection: this.map.protection.model
      };
      return false;
    }
    return true;
  }
};
var dxfXform = DxfXform$1;
const Enums$3 = enums;
const XmlStream$d = xmlStream;
const BaseXform$1j = baseXform;
const StaticXform$4 = staticXform;
const ListXform$6 = listXform;
const FontXform$1 = fontXform;
const FillXform2 = fillXform;
const BorderXform2 = borderXform;
const NumFmtXform2 = numfmtXform;
const StyleXform2 = styleXform;
const DxfXform2 = dxfXform;
const NUMFMT_BASE = 164;
let StylesXform$2 = class StylesXform extends BaseXform$1j {
  constructor(initialise) {
    super();
    this.map = {
      numFmts: new ListXform$6({ tag: "numFmts", count: true, childXform: new NumFmtXform2() }),
      fonts: new ListXform$6({
        tag: "fonts",
        count: true,
        childXform: new FontXform$1(),
        $: { "x14ac:knownFonts": 1 }
      }),
      fills: new ListXform$6({ tag: "fills", count: true, childXform: new FillXform2() }),
      borders: new ListXform$6({ tag: "borders", count: true, childXform: new BorderXform2() }),
      cellStyleXfs: new ListXform$6({ tag: "cellStyleXfs", count: true, childXform: new StyleXform2() }),
      cellXfs: new ListXform$6({
        tag: "cellXfs",
        count: true,
        childXform: new StyleXform2({ xfId: true })
      }),
      dxfs: new ListXform$6({ tag: "dxfs", always: true, count: true, childXform: new DxfXform2() }),
      // for style manager
      numFmt: new NumFmtXform2(),
      font: new FontXform$1(),
      fill: new FillXform2(),
      border: new BorderXform2(),
      style: new StyleXform2({ xfId: true }),
      cellStyles: StylesXform.STATIC_XFORMS.cellStyles,
      tableStyles: StylesXform.STATIC_XFORMS.tableStyles,
      extLst: StylesXform.STATIC_XFORMS.extLst
    };
    if (initialise) {
      this.init();
    }
  }
  initIndex() {
    this.index = {
      style: {},
      numFmt: {},
      numFmtNextId: 164,
      // start custom format ids here
      font: {},
      border: {},
      fill: {}
    };
  }
  init() {
    this.model = {
      styles: [],
      numFmts: [],
      fonts: [],
      borders: [],
      fills: [],
      dxfs: []
    };
    this.initIndex();
    this._addBorder({});
    this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 });
    this._addFill({ type: "pattern", pattern: "none" });
    this._addFill({ type: "pattern", pattern: "gray125" });
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  render(xmlStream2, model) {
    model = model || this.model;
    xmlStream2.openXml(XmlStream$d.StdDocAttributes);
    xmlStream2.openNode("styleSheet", StylesXform.STYLESHEET_ATTRIBUTES);
    if (this.index) {
      if (model.numFmts && model.numFmts.length) {
        xmlStream2.openNode("numFmts", { count: model.numFmts.length });
        model.numFmts.forEach((numFmtXml) => {
          xmlStream2.writeXml(numFmtXml);
        });
        xmlStream2.closeNode();
      }
      if (!model.fonts.length) {
        this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
      }
      xmlStream2.openNode("fonts", { count: model.fonts.length, "x14ac:knownFonts": 1 });
      model.fonts.forEach((fontXml) => {
        xmlStream2.writeXml(fontXml);
      });
      xmlStream2.closeNode();
      xmlStream2.openNode("fills", { count: model.fills.length });
      model.fills.forEach((fillXml) => {
        xmlStream2.writeXml(fillXml);
      });
      xmlStream2.closeNode();
      xmlStream2.openNode("borders", { count: model.borders.length });
      model.borders.forEach((borderXml) => {
        xmlStream2.writeXml(borderXml);
      });
      xmlStream2.closeNode();
      this.map.cellStyleXfs.render(xmlStream2, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
      xmlStream2.openNode("cellXfs", { count: model.styles.length });
      model.styles.forEach((styleXml) => {
        xmlStream2.writeXml(styleXml);
      });
      xmlStream2.closeNode();
    } else {
      this.map.numFmts.render(xmlStream2, model.numFmts);
      this.map.fonts.render(xmlStream2, model.fonts);
      this.map.fills.render(xmlStream2, model.fills);
      this.map.borders.render(xmlStream2, model.borders);
      this.map.cellStyleXfs.render(xmlStream2, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
      this.map.cellXfs.render(xmlStream2, model.styles);
    }
    StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream2);
    this.map.dxfs.render(xmlStream2, model.dxfs);
    StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream2);
    StylesXform.STATIC_XFORMS.extLst.render(xmlStream2);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "styleSheet":
        this.initIndex();
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        return true;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case "styleSheet": {
        this.model = {};
        const add = (propName, xform2) => {
          if (xform2.model && xform2.model.length) {
            this.model[propName] = xform2.model;
          }
        };
        add("numFmts", this.map.numFmts);
        add("fonts", this.map.fonts);
        add("fills", this.map.fills);
        add("borders", this.map.borders);
        add("styles", this.map.cellXfs);
        add("dxfs", this.map.dxfs);
        this.index = {
          model: [],
          numFmt: []
        };
        if (this.model.numFmts) {
          const numFmtIndex = this.index.numFmt;
          this.model.numFmts.forEach((numFmt) => {
            numFmtIndex[numFmt.id] = numFmt.formatCode;
          });
        }
        return false;
      }
      default:
        return true;
    }
  }
  // add a cell's style model to the collection
  // each style property is processed and cross-referenced, etc.
  // the styleId is returned. Note: cellType is used when numFmt not defined
  addStyleModel(model, cellType) {
    if (!model) {
      return 0;
    }
    if (!this.model.fonts.length) {
      this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
    }
    if (this.weakMap && this.weakMap.has(model)) {
      return this.weakMap.get(model);
    }
    const style = {};
    cellType = cellType || Enums$3.ValueType.Number;
    if (model.numFmt) {
      style.numFmtId = this._addNumFmtStr(model.numFmt);
    } else {
      switch (cellType) {
        case Enums$3.ValueType.Number:
          style.numFmtId = this._addNumFmtStr("General");
          break;
        case Enums$3.ValueType.Date:
          style.numFmtId = this._addNumFmtStr("mm-dd-yy");
          break;
      }
    }
    if (model.font) {
      style.fontId = this._addFont(model.font);
    }
    if (model.border) {
      style.borderId = this._addBorder(model.border);
    }
    if (model.fill) {
      style.fillId = this._addFill(model.fill);
    }
    if (model.alignment) {
      style.alignment = model.alignment;
    }
    if (model.protection) {
      style.protection = model.protection;
    }
    const styleId = this._addStyle(style);
    if (this.weakMap) {
      this.weakMap.set(model, styleId);
    }
    return styleId;
  }
  // given a styleId (i.e. s="n"), get the cell's style model
  // objects are shared where possible.
  getStyleModel(id) {
    const style = this.model.styles[id];
    if (!style) return null;
    let model = this.index.model[id];
    if (model) return model;
    model = this.index.model[id] = {};
    if (style.numFmtId) {
      const numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform2.getDefaultFmtCode(style.numFmtId);
      if (numFmt) {
        model.numFmt = numFmt;
      }
    }
    function addStyle(name, group, styleId) {
      if (styleId || styleId === 0) {
        const part = group[styleId];
        if (part) {
          model[name] = part;
        }
      }
    }
    addStyle("font", this.model.fonts, style.fontId);
    addStyle("border", this.model.borders, style.borderId);
    addStyle("fill", this.model.fills, style.fillId);
    if (style.alignment) {
      model.alignment = style.alignment;
    }
    if (style.protection) {
      model.protection = style.protection;
    }
    return model;
  }
  addDxfStyle(style) {
    if (style.numFmt) {
      style.numFmtId = this._addNumFmtStr(style.numFmt);
    }
    this.model.dxfs.push(style);
    return this.model.dxfs.length - 1;
  }
  getDxfStyle(id) {
    return this.model.dxfs[id];
  }
  // =========================================================================
  // Private Interface
  _addStyle(style) {
    const xml = this.map.style.toXml(style);
    let index2 = this.index.style[xml];
    if (index2 === void 0) {
      index2 = this.index.style[xml] = this.model.styles.length;
      this.model.styles.push(xml);
    }
    return index2;
  }
  // =========================================================================
  // Number Formats
  _addNumFmtStr(formatCode) {
    let index2 = NumFmtXform2.getDefaultFmtId(formatCode);
    if (index2 !== void 0) return index2;
    index2 = this.index.numFmt[formatCode];
    if (index2 !== void 0) return index2;
    index2 = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;
    const xml = this.map.numFmt.toXml({ id: index2, formatCode });
    this.model.numFmts.push(xml);
    return index2;
  }
  // =========================================================================
  // Fonts
  _addFont(font) {
    const xml = this.map.font.toXml(font);
    let index2 = this.index.font[xml];
    if (index2 === void 0) {
      index2 = this.index.font[xml] = this.model.fonts.length;
      this.model.fonts.push(xml);
    }
    return index2;
  }
  // =========================================================================
  // Borders
  _addBorder(border) {
    const xml = this.map.border.toXml(border);
    let index2 = this.index.border[xml];
    if (index2 === void 0) {
      index2 = this.index.border[xml] = this.model.borders.length;
      this.model.borders.push(xml);
    }
    return index2;
  }
  // =========================================================================
  // Fills
  _addFill(fill) {
    const xml = this.map.fill.toXml(fill);
    let index2 = this.index.fill[xml];
    if (index2 === void 0) {
      index2 = this.index.fill[xml] = this.model.fills.length;
      this.model.fills.push(xml);
    }
    return index2;
  }
  // =========================================================================
};
StylesXform$2.STYLESHEET_ATTRIBUTES = {
  xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
  "mc:Ignorable": "x14ac x16r2",
  "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",
  "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"
};
StylesXform$2.STATIC_XFORMS = {
  cellStyles: new StaticXform$4({
    tag: "cellStyles",
    $: { count: 1 },
    c: [{ tag: "cellStyle", $: { name: "Normal", xfId: 0, builtinId: 0 } }]
  }),
  dxfs: new StaticXform$4({ tag: "dxfs", $: { count: 0 } }),
  tableStyles: new StaticXform$4({
    tag: "tableStyles",
    $: { count: 0, defaultTableStyle: "TableStyleMedium2", defaultPivotStyle: "PivotStyleLight16" }
  }),
  extLst: new StaticXform$4({
    tag: "extLst",
    c: [
      {
        tag: "ext",
        $: {
          uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}",
          "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
        },
        c: [{ tag: "x14:slicerStyles", $: { defaultSlicerStyle: "SlicerStyleLight1" } }]
      },
      {
        tag: "ext",
        $: {
          uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}",
          "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
        },
        c: [{ tag: "x15:timelineStyles", $: { defaultTimelineStyle: "TimeSlicerStyleLight1" } }]
      }
    ]
  })
};
class StylesXformMock extends StylesXform$2 {
  constructor() {
    super();
    this.model = {
      styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }],
      numFmts: [],
      fonts: [{ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }],
      borders: [{}],
      fills: [
        { type: "pattern", pattern: "none" },
        { type: "pattern", pattern: "gray125" }
      ]
    };
  }
  // =========================================================================
  // Style Manager Interface
  // override normal behaviour - consume and dispose
  parseStream(stream2) {
    stream2.autodrain();
    return Promise.resolve();
  }
  // add a cell's style model to the collection
  // each style property is processed and cross-referenced, etc.
  // the styleId is returned. Note: cellType is used when numFmt not defined
  addStyleModel(model, cellType) {
    switch (cellType) {
      case Enums$3.ValueType.Date:
        return this.dateStyleId;
      default:
        return 0;
    }
  }
  get dateStyleId() {
    if (!this._dateStyleId) {
      const dateStyle = {
        numFmtId: NumFmtXform2.getDefaultFmtId("mm-dd-yy")
      };
      this._dateStyleId = this.model.styles.length;
      this.model.styles.push(dateStyle);
    }
    return this._dateStyleId;
  }
  // given a styleId (i.e. s="n"), get the cell's style model
  // objects are shared where possible.
  getStyleModel() {
    return {};
  }
}
StylesXform$2.Mock = StylesXformMock;
var stylesXform = StylesXform$2;
const BaseXform$1i = baseXform;
let DateXform$1 = class DateXform extends BaseXform$1i {
  constructor(options) {
    super();
    this.tag = options.tag;
    this.attr = options.attr;
    this.attrs = options.attrs;
    this._format = options.format || function(dt) {
      try {
        if (Number.isNaN(dt.getTime())) return "";
        return dt.toISOString();
      } catch (e) {
        return "";
      }
    };
    this._parse = options.parse || function(str) {
      return new Date(str);
    };
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.openNode(this.tag);
      if (this.attrs) {
        xmlStream2.addAttributes(this.attrs);
      }
      if (this.attr) {
        xmlStream2.addAttribute(this.attr, this._format(model));
      } else {
        xmlStream2.writeText(this._format(model));
      }
      xmlStream2.closeNode();
    }
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      if (this.attr) {
        this.model = this._parse(node2.attributes[this.attr]);
      } else {
        this.text = [];
      }
    }
  }
  parseText(text) {
    if (!this.attr) {
      this.text.push(text);
    }
  }
  parseClose() {
    if (!this.attr) {
      this.model = this._parse(this.text.join(""));
    }
    return false;
  }
};
var dateXform = DateXform$1;
const XmlStream$c = xmlStream;
const BaseXform$1h = baseXform;
const DateXform2 = dateXform;
const StringXform$1 = stringXform;
const IntegerXform$1 = integerXform;
let CoreXform$2 = class CoreXform extends BaseXform$1h {
  constructor() {
    super();
    this.map = {
      "dc:creator": new StringXform$1({ tag: "dc:creator" }),
      "dc:title": new StringXform$1({ tag: "dc:title" }),
      "dc:subject": new StringXform$1({ tag: "dc:subject" }),
      "dc:description": new StringXform$1({ tag: "dc:description" }),
      "dc:identifier": new StringXform$1({ tag: "dc:identifier" }),
      "dc:language": new StringXform$1({ tag: "dc:language" }),
      "cp:keywords": new StringXform$1({ tag: "cp:keywords" }),
      "cp:category": new StringXform$1({ tag: "cp:category" }),
      "cp:lastModifiedBy": new StringXform$1({ tag: "cp:lastModifiedBy" }),
      "cp:lastPrinted": new DateXform2({ tag: "cp:lastPrinted", format: CoreXform.DateFormat }),
      "cp:revision": new IntegerXform$1({ tag: "cp:revision" }),
      "cp:version": new StringXform$1({ tag: "cp:version" }),
      "cp:contentStatus": new StringXform$1({ tag: "cp:contentStatus" }),
      "cp:contentType": new StringXform$1({ tag: "cp:contentType" }),
      "dcterms:created": new DateXform2({
        tag: "dcterms:created",
        attrs: CoreXform.DateAttrs,
        format: CoreXform.DateFormat
      }),
      "dcterms:modified": new DateXform2({
        tag: "dcterms:modified",
        attrs: CoreXform.DateAttrs,
        format: CoreXform.DateFormat
      })
    };
  }
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$c.StdDocAttributes);
    xmlStream2.openNode("cp:coreProperties", CoreXform.CORE_PROPERTY_ATTRIBUTES);
    this.map["dc:creator"].render(xmlStream2, model.creator);
    this.map["dc:title"].render(xmlStream2, model.title);
    this.map["dc:subject"].render(xmlStream2, model.subject);
    this.map["dc:description"].render(xmlStream2, model.description);
    this.map["dc:identifier"].render(xmlStream2, model.identifier);
    this.map["dc:language"].render(xmlStream2, model.language);
    this.map["cp:keywords"].render(xmlStream2, model.keywords);
    this.map["cp:category"].render(xmlStream2, model.category);
    this.map["cp:lastModifiedBy"].render(xmlStream2, model.lastModifiedBy);
    this.map["cp:lastPrinted"].render(xmlStream2, model.lastPrinted);
    this.map["cp:revision"].render(xmlStream2, model.revision);
    this.map["cp:version"].render(xmlStream2, model.version);
    this.map["cp:contentStatus"].render(xmlStream2, model.contentStatus);
    this.map["cp:contentType"].render(xmlStream2, model.contentType);
    this.map["dcterms:created"].render(xmlStream2, model.created);
    this.map["dcterms:modified"].render(xmlStream2, model.modified);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "cp:coreProperties":
      case "coreProperties":
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
          return true;
        }
        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case "cp:coreProperties":
      case "coreProperties":
        this.model = {
          creator: this.map["dc:creator"].model,
          title: this.map["dc:title"].model,
          subject: this.map["dc:subject"].model,
          description: this.map["dc:description"].model,
          identifier: this.map["dc:identifier"].model,
          language: this.map["dc:language"].model,
          keywords: this.map["cp:keywords"].model,
          category: this.map["cp:category"].model,
          lastModifiedBy: this.map["cp:lastModifiedBy"].model,
          lastPrinted: this.map["cp:lastPrinted"].model,
          revision: this.map["cp:revision"].model,
          contentStatus: this.map["cp:contentStatus"].model,
          contentType: this.map["cp:contentType"].model,
          created: this.map["dcterms:created"].model,
          modified: this.map["dcterms:modified"].model
        };
        return false;
      default:
        throw new Error(`Unexpected xml node in parseClose: ${name}`);
    }
  }
};
CoreXform$2.DateFormat = function(dt) {
  return dt.toISOString().replace(/[.]\d{3}/, "");
};
CoreXform$2.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
CoreXform$2.CORE_PROPERTY_ATTRIBUTES = {
  "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  "xmlns:dc": "http://purl.org/dc/elements/1.1/",
  "xmlns:dcterms": "http://purl.org/dc/terms/",
  "xmlns:dcmitype": "http://purl.org/dc/dcmitype/",
  "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
};
var coreXform = CoreXform$2;
const BaseXform$1g = baseXform;
let TextXform$3 = class TextXform extends BaseXform$1g {
  get tag() {
    return "t";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("t");
    if (/^\s|\n|\s$/.test(model)) {
      xmlStream2.addAttribute("xml:space", "preserve");
    }
    xmlStream2.writeText(model);
    xmlStream2.closeNode();
  }
  get model() {
    return this._text.join("").replace(/_x([0-9A-F]{4})_/g, ($0, $1) => String.fromCharCode(parseInt($1, 16)));
  }
  parseOpen(node2) {
    switch (node2.name) {
      case "t":
        this._text = [];
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    this._text.push(text);
  }
  parseClose() {
    return false;
  }
};
var textXform = TextXform$3;
const TextXform$2 = textXform;
const FontXform2 = fontXform;
const BaseXform$1f = baseXform;
let RichTextXform$4 = class RichTextXform extends BaseXform$1f {
  constructor(model) {
    super();
    this.model = model;
  }
  get tag() {
    return "r";
  }
  get textXform() {
    return this._textXform || (this._textXform = new TextXform$2());
  }
  get fontXform() {
    return this._fontXform || (this._fontXform = new FontXform2(RichTextXform.FONT_OPTIONS));
  }
  render(xmlStream2, model) {
    model = model || this.model;
    xmlStream2.openNode("r");
    if (model.font) {
      this.fontXform.render(xmlStream2, model.font);
    }
    this.textXform.render(xmlStream2, model.text);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "r":
        this.model = {};
        return true;
      case "t":
        this.parser = this.textXform;
        this.parser.parseOpen(node2);
        return true;
      case "rPr":
        this.parser = this.fontXform;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    switch (name) {
      case "r":
        return false;
      case "t":
        this.model.text = this.parser.model;
        this.parser = void 0;
        return true;
      case "rPr":
        this.model.font = this.parser.model;
        this.parser = void 0;
        return true;
      default:
        if (this.parser) {
          this.parser.parseClose(name);
        }
        return true;
    }
  }
};
RichTextXform$4.FONT_OPTIONS = {
  tagName: "rPr",
  fontNameTag: "rFont"
};
var richTextXform = RichTextXform$4;
const TextXform$1 = textXform;
const RichTextXform$3 = richTextXform;
const BaseXform$1e = baseXform;
let PhoneticTextXform$1 = class PhoneticTextXform extends BaseXform$1e {
  constructor() {
    super();
    this.map = {
      r: new RichTextXform$3(),
      t: new TextXform$1()
    };
  }
  get tag() {
    return "rPh";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      sb: model.sb || 0,
      eb: model.eb || 0
    });
    if (model && model.hasOwnProperty("richText") && model.richText) {
      const { r } = this.map;
      model.richText.forEach((text) => {
        r.render(xmlStream2, text);
      });
    } else if (model) {
      this.map.t.render(xmlStream2, model.text);
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    const { name } = node2;
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    if (name === this.tag) {
      this.model = {
        sb: parseInt(node2.attributes.sb, 10),
        eb: parseInt(node2.attributes.eb, 10)
      };
      return true;
    }
    this.parser = this.map[name];
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    return false;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        switch (name) {
          case "r": {
            let rt = this.model.richText;
            if (!rt) {
              rt = this.model.richText = [];
            }
            rt.push(this.parser.model);
            break;
          }
          case "t":
            this.model.text = this.parser.model;
            break;
        }
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
};
var phoneticTextXform = PhoneticTextXform$1;
const TextXform2 = textXform;
const RichTextXform$2 = richTextXform;
const PhoneticTextXform2 = phoneticTextXform;
const BaseXform$1d = baseXform;
let SharedStringXform$1 = class SharedStringXform extends BaseXform$1d {
  constructor(model) {
    super();
    this.model = model;
    this.map = {
      r: new RichTextXform$2(),
      t: new TextXform2(),
      rPh: new PhoneticTextXform2()
    };
  }
  get tag() {
    return "si";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    if (model && model.hasOwnProperty("richText") && model.richText) {
      if (model.richText.length) {
        model.richText.forEach((text) => {
          this.map.r.render(xmlStream2, text);
        });
      } else {
        this.map.t.render(xmlStream2, "");
      }
    } else if (model !== void 0 && model !== null) {
      this.map.t.render(xmlStream2, model);
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    const { name } = node2;
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    if (name === this.tag) {
      this.model = {};
      return true;
    }
    this.parser = this.map[name];
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    return false;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        switch (name) {
          case "r": {
            let rt = this.model.richText;
            if (!rt) {
              rt = this.model.richText = [];
            }
            rt.push(this.parser.model);
            break;
          }
          case "t":
            this.model = this.parser.model;
            break;
        }
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
};
var sharedStringXform = SharedStringXform$1;
const XmlStream$b = xmlStream;
const BaseXform$1c = baseXform;
const SharedStringXform2 = sharedStringXform;
let SharedStringsXform$2 = class SharedStringsXform extends BaseXform$1c {
  constructor(model) {
    super();
    this.model = model || {
      values: [],
      count: 0
    };
    this.hash = /* @__PURE__ */ Object.create(null);
    this.rich = /* @__PURE__ */ Object.create(null);
  }
  get sharedStringXform() {
    return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform2());
  }
  get values() {
    return this.model.values;
  }
  get uniqueCount() {
    return this.model.values.length;
  }
  get count() {
    return this.model.count;
  }
  getString(index2) {
    return this.model.values[index2];
  }
  add(value) {
    return value.richText ? this.addRichText(value) : this.addText(value);
  }
  addText(value) {
    let index2 = this.hash[value];
    if (index2 === void 0) {
      index2 = this.hash[value] = this.model.values.length;
      this.model.values.push(value);
    }
    this.model.count++;
    return index2;
  }
  addRichText(value) {
    const xml = this.sharedStringXform.toXml(value);
    let index2 = this.rich[xml];
    if (index2 === void 0) {
      index2 = this.rich[xml] = this.model.values.length;
      this.model.values.push(value);
    }
    this.model.count++;
    return index2;
  }
  // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  // <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="<%=totalRefs%>" uniqueCount="<%=count%>">
  //   <si><t><%=text%></t></si>
  //   <si><r><rPr></rPr><t></t></r></si>
  // </sst>
  render(xmlStream2, model) {
    model = model || this._values;
    xmlStream2.openXml(XmlStream$b.StdDocAttributes);
    xmlStream2.openNode("sst", {
      xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
      count: model.count,
      uniqueCount: model.values.length
    });
    const sx = this.sharedStringXform;
    model.values.forEach((sharedString) => {
      sx.render(xmlStream2, sharedString);
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "sst":
        return true;
      case "si":
        this.parser = this.sharedStringXform;
        this.parser.parseOpen(node2);
        return true;
      default:
        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.values.push(this.parser.model);
        this.model.count++;
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case "sst":
        return false;
      default:
        throw new Error(`Unexpected xml node in parseClose: ${name}`);
    }
  }
};
var sharedStringsXform = SharedStringsXform$2;
const BaseXform$1b = baseXform;
let RelationshipXform$1 = class RelationshipXform extends BaseXform$1b {
  render(xmlStream2, model) {
    xmlStream2.leafNode("Relationship", model);
  }
  parseOpen(node2) {
    switch (node2.name) {
      case "Relationship":
        this.model = node2.attributes;
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var relationshipXform = RelationshipXform$1;
const XmlStream$a = xmlStream;
const BaseXform$1a = baseXform;
const RelationshipXform2 = relationshipXform;
let RelationshipsXform$3 = class RelationshipsXform extends BaseXform$1a {
  constructor() {
    super();
    this.map = {
      Relationship: new RelationshipXform2()
    };
  }
  render(xmlStream2, model) {
    model = model || this._values;
    xmlStream2.openXml(XmlStream$a.StdDocAttributes);
    xmlStream2.openNode("Relationships", RelationshipsXform.RELATIONSHIPS_ATTRIBUTES);
    model.forEach((relationship) => {
      this.map.Relationship.render(xmlStream2, relationship);
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "Relationships":
        this.model = [];
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
          return true;
        }
        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.push(this.parser.model);
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case "Relationships":
        return false;
      default:
        throw new Error(`Unexpected xml node in parseClose: ${name}`);
    }
  }
};
RelationshipsXform$3.RELATIONSHIPS_ATTRIBUTES = {
  xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
};
var relationshipsXform = RelationshipsXform$3;
const XmlStream$9 = xmlStream;
const BaseXform$19 = baseXform;
let ContentTypesXform$2 = class ContentTypesXform extends BaseXform$19 {
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$9.StdDocAttributes);
    xmlStream2.openNode("Types", ContentTypesXform.PROPERTY_ATTRIBUTES);
    const mediaHash = {};
    (model.media || []).forEach((medium) => {
      if (medium.type === "image") {
        const imageType = medium.extension;
        if (!mediaHash[imageType]) {
          mediaHash[imageType] = true;
          xmlStream2.leafNode("Default", { Extension: imageType, ContentType: `image/${imageType}` });
        }
      }
    });
    xmlStream2.leafNode("Default", {
      Extension: "rels",
      ContentType: "application/vnd.openxmlformats-package.relationships+xml"
    });
    xmlStream2.leafNode("Default", { Extension: "xml", ContentType: "application/xml" });
    xmlStream2.leafNode("Override", {
      PartName: "/xl/workbook.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"
    });
    model.worksheets.forEach((worksheet2) => {
      const name = `/xl/worksheets/sheet${worksheet2.id}.xml`;
      xmlStream2.leafNode("Override", {
        PartName: name,
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"
      });
    });
    xmlStream2.leafNode("Override", {
      PartName: "/xl/theme/theme1.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
    });
    xmlStream2.leafNode("Override", {
      PartName: "/xl/styles.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"
    });
    const hasSharedStrings = model.sharedStrings && model.sharedStrings.count;
    if (hasSharedStrings) {
      xmlStream2.leafNode("Override", {
        PartName: "/xl/sharedStrings.xml",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"
      });
    }
    if (model.tables) {
      model.tables.forEach((table2) => {
        xmlStream2.leafNode("Override", {
          PartName: `/xl/tables/${table2.target}`,
          ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"
        });
      });
    }
    if (model.drawings) {
      model.drawings.forEach((drawing) => {
        xmlStream2.leafNode("Override", {
          PartName: `/xl/drawings/${drawing.name}.xml`,
          ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml"
        });
      });
    }
    if (model.commentRefs) {
      xmlStream2.leafNode("Default", {
        Extension: "vml",
        ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing"
      });
      model.commentRefs.forEach(({ commentName }) => {
        xmlStream2.leafNode("Override", {
          PartName: `/xl/${commentName}.xml`,
          ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"
        });
      });
    }
    xmlStream2.leafNode("Override", {
      PartName: "/docProps/core.xml",
      ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
    });
    xmlStream2.leafNode("Override", {
      PartName: "/docProps/app.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
    });
    xmlStream2.closeNode();
  }
  parseOpen() {
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
ContentTypesXform$2.PROPERTY_ATTRIBUTES = {
  xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
};
var contentTypesXform = ContentTypesXform$2;
const BaseXform$18 = baseXform;
let AppHeadingPairsXform$1 = class AppHeadingPairsXform extends BaseXform$18 {
  render(xmlStream2, model) {
    xmlStream2.openNode("HeadingPairs");
    xmlStream2.openNode("vt:vector", { size: 2, baseType: "variant" });
    xmlStream2.openNode("vt:variant");
    xmlStream2.leafNode("vt:lpstr", void 0, "Worksheets");
    xmlStream2.closeNode();
    xmlStream2.openNode("vt:variant");
    xmlStream2.leafNode("vt:i4", void 0, model.length);
    xmlStream2.closeNode();
    xmlStream2.closeNode();
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    return node2.name === "HeadingPairs";
  }
  parseText() {
  }
  parseClose(name) {
    return name !== "HeadingPairs";
  }
};
var appHeadingPairsXform = AppHeadingPairsXform$1;
const BaseXform$17 = baseXform;
class AppTitlesOfPartsXform extends BaseXform$17 {
  render(xmlStream2, model) {
    xmlStream2.openNode("TitlesOfParts");
    xmlStream2.openNode("vt:vector", { size: model.length, baseType: "lpstr" });
    model.forEach((sheet) => {
      xmlStream2.leafNode("vt:lpstr", void 0, sheet.name);
    });
    xmlStream2.closeNode();
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    return node2.name === "TitlesOfParts";
  }
  parseText() {
  }
  parseClose(name) {
    return name !== "TitlesOfParts";
  }
}
var appTitlesOfPartsXform = AppTitlesOfPartsXform;
const XmlStream$8 = xmlStream;
const BaseXform$16 = baseXform;
const StringXform2 = stringXform;
const AppHeadingPairsXform2 = appHeadingPairsXform;
const AppTitleOfPartsXform = appTitlesOfPartsXform;
let AppXform$2 = class AppXform extends BaseXform$16 {
  constructor() {
    super();
    this.map = {
      Company: new StringXform2({ tag: "Company" }),
      Manager: new StringXform2({ tag: "Manager" }),
      HeadingPairs: new AppHeadingPairsXform2(),
      TitleOfParts: new AppTitleOfPartsXform()
    };
  }
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$8.StdDocAttributes);
    xmlStream2.openNode("Properties", AppXform.PROPERTY_ATTRIBUTES);
    xmlStream2.leafNode("Application", void 0, "Microsoft Excel");
    xmlStream2.leafNode("DocSecurity", void 0, "0");
    xmlStream2.leafNode("ScaleCrop", void 0, "false");
    this.map.HeadingPairs.render(xmlStream2, model.worksheets);
    this.map.TitleOfParts.render(xmlStream2, model.worksheets);
    this.map.Company.render(xmlStream2, model.company || "");
    this.map.Manager.render(xmlStream2, model.manager);
    xmlStream2.leafNode("LinksUpToDate", void 0, "false");
    xmlStream2.leafNode("SharedDoc", void 0, "false");
    xmlStream2.leafNode("HyperlinksChanged", void 0, "false");
    xmlStream2.leafNode("AppVersion", void 0, "16.0300");
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "Properties":
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
          return true;
        }
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case "Properties":
        this.model = {
          worksheets: this.map.TitleOfParts.model,
          company: this.map.Company.model,
          manager: this.map.Manager.model
        };
        return false;
      default:
        return true;
    }
  }
};
AppXform$2.DateFormat = function(dt) {
  return dt.toISOString().replace(/[.]\d{3,6}/, "");
};
AppXform$2.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
AppXform$2.PROPERTY_ATTRIBUTES = {
  xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
};
var appXform = AppXform$2;
const BaseXform$15 = baseXform;
const colCache$a = colCache_1;
class DefinedNamesXform extends BaseXform$15 {
  render(xmlStream2, model) {
    xmlStream2.openNode("definedName", {
      name: model.name,
      localSheetId: model.localSheetId
    });
    xmlStream2.writeText(model.ranges.join(","));
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    switch (node2.name) {
      case "definedName":
        this._parsedName = node2.attributes.name;
        this._parsedLocalSheetId = node2.attributes.localSheetId;
        this._parsedText = [];
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    this._parsedText.push(text);
  }
  parseClose() {
    this.model = {
      name: this._parsedName,
      ranges: extractRanges(this._parsedText.join(""))
    };
    if (this._parsedLocalSheetId !== void 0) {
      this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);
    }
    return false;
  }
}
function isValidRange(range2) {
  try {
    colCache$a.decodeEx(range2);
    return true;
  } catch (err2) {
    return false;
  }
}
function extractRanges(parsedText) {
  const ranges = [];
  let quotesOpened = false;
  let last = "";
  parsedText.split(",").forEach((item) => {
    if (!item) {
      return;
    }
    const quotes = (item.match(/'/g) || []).length;
    if (!quotes) {
      if (quotesOpened) {
        last += `${item},`;
      } else if (isValidRange(item)) {
        ranges.push(item);
      }
      return;
    }
    const quotesEven = quotes % 2 === 0;
    if (!quotesOpened && quotesEven && isValidRange(item)) {
      ranges.push(item);
    } else if (quotesOpened && !quotesEven) {
      quotesOpened = false;
      if (isValidRange(last + item)) {
        ranges.push(last + item);
      }
      last = "";
    } else {
      quotesOpened = true;
      last += `${item},`;
    }
  });
  return ranges;
}
var definedNameXform = DefinedNamesXform;
const utils$b = utils_1;
const BaseXform$14 = baseXform;
let WorksheetXform$1 = class WorksheetXform extends BaseXform$14 {
  render(xmlStream2, model) {
    xmlStream2.leafNode("sheet", {
      sheetId: model.id,
      name: model.name,
      state: model.state,
      "r:id": model.rId
    });
  }
  parseOpen(node2) {
    if (node2.name === "sheet") {
      this.model = {
        name: utils$b.xmlDecode(node2.attributes.name),
        id: parseInt(node2.attributes.sheetId, 10),
        state: node2.attributes.state,
        rId: node2.attributes["r:id"]
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var sheetXform = WorksheetXform$1;
const BaseXform$13 = baseXform;
let WorkbookViewXform$1 = class WorkbookViewXform extends BaseXform$13 {
  render(xmlStream2, model) {
    const attributes = {
      xWindow: model.x || 0,
      yWindow: model.y || 0,
      windowWidth: model.width || 12e3,
      windowHeight: model.height || 24e3,
      firstSheet: model.firstSheet,
      activeTab: model.activeTab
    };
    if (model.visibility && model.visibility !== "visible") {
      attributes.visibility = model.visibility;
    }
    xmlStream2.leafNode("workbookView", attributes);
  }
  parseOpen(node2) {
    if (node2.name === "workbookView") {
      const model = this.model = {};
      const addS = function(name, value, dflt) {
        const s = value !== void 0 ? model[name] = value : dflt;
        if (s !== void 0) {
          model[name] = s;
        }
      };
      const addN = function(name, value, dflt) {
        const n = value !== void 0 ? model[name] = parseInt(value, 10) : dflt;
        if (n !== void 0) {
          model[name] = n;
        }
      };
      addN("x", node2.attributes.xWindow, 0);
      addN("y", node2.attributes.yWindow, 0);
      addN("width", node2.attributes.windowWidth, 25e3);
      addN("height", node2.attributes.windowHeight, 1e4);
      addS("visibility", node2.attributes.visibility, "visible");
      addN("activeTab", node2.attributes.activeTab, void 0);
      addN("firstSheet", node2.attributes.firstSheet, void 0);
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var workbookViewXform = WorkbookViewXform$1;
const BaseXform$12 = baseXform;
class WorksheetPropertiesXform extends BaseXform$12 {
  render(xmlStream2, model) {
    xmlStream2.leafNode("workbookPr", {
      date1904: model.date1904 ? 1 : void 0,
      defaultThemeVersion: 164011,
      filterPrivacy: 1
    });
  }
  parseOpen(node2) {
    if (node2.name === "workbookPr") {
      this.model = {
        date1904: node2.attributes.date1904 === "1"
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
}
var workbookPropertiesXform = WorksheetPropertiesXform;
const BaseXform$11 = baseXform;
let WorkbookCalcPropertiesXform$1 = class WorkbookCalcPropertiesXform extends BaseXform$11 {
  render(xmlStream2, model) {
    xmlStream2.leafNode("calcPr", {
      calcId: 171027,
      fullCalcOnLoad: model.fullCalcOnLoad ? 1 : void 0
    });
  }
  parseOpen(node2) {
    if (node2.name === "calcPr") {
      this.model = {};
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var workbookCalcPropertiesXform = WorkbookCalcPropertiesXform$1;
const _$b = underDash;
const colCache$9 = colCache_1;
const XmlStream$7 = xmlStream;
const BaseXform$10 = baseXform;
const StaticXform$3 = staticXform;
const ListXform$5 = listXform;
const DefinedNameXform = definedNameXform;
const SheetXform = sheetXform;
const WorkbookViewXform2 = workbookViewXform;
const WorkbookPropertiesXform = workbookPropertiesXform;
const WorkbookCalcPropertiesXform2 = workbookCalcPropertiesXform;
let WorkbookXform$3 = class WorkbookXform extends BaseXform$10 {
  constructor() {
    super();
    this.map = {
      fileVersion: WorkbookXform.STATIC_XFORMS.fileVersion,
      workbookPr: new WorkbookPropertiesXform(),
      bookViews: new ListXform$5({
        tag: "bookViews",
        count: false,
        childXform: new WorkbookViewXform2()
      }),
      sheets: new ListXform$5({ tag: "sheets", count: false, childXform: new SheetXform() }),
      definedNames: new ListXform$5({
        tag: "definedNames",
        count: false,
        childXform: new DefinedNameXform()
      }),
      calcPr: new WorkbookCalcPropertiesXform2()
    };
  }
  prepare(model) {
    model.sheets = model.worksheets;
    const printAreas = [];
    let index2 = 0;
    model.sheets.forEach((sheet) => {
      if (sheet.pageSetup && sheet.pageSetup.printArea) {
        sheet.pageSetup.printArea.split("&&").forEach((printArea) => {
          const printAreaComponents = printArea.split(":");
          const definedName = {
            name: "_xlnm.Print_Area",
            ranges: [`'${sheet.name}'!$${printAreaComponents[0]}:$${printAreaComponents[1]}`],
            localSheetId: index2
          };
          printAreas.push(definedName);
        });
      }
      if (sheet.pageSetup && (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)) {
        const ranges = [];
        if (sheet.pageSetup.printTitlesColumn) {
          const titlesColumns = sheet.pageSetup.printTitlesColumn.split(":");
          ranges.push(`'${sheet.name}'!$${titlesColumns[0]}:$${titlesColumns[1]}`);
        }
        if (sheet.pageSetup.printTitlesRow) {
          const titlesRows = sheet.pageSetup.printTitlesRow.split(":");
          ranges.push(`'${sheet.name}'!$${titlesRows[0]}:$${titlesRows[1]}`);
        }
        const definedName = {
          name: "_xlnm.Print_Titles",
          ranges,
          localSheetId: index2
        };
        printAreas.push(definedName);
      }
      index2++;
    });
    if (printAreas.length) {
      model.definedNames = model.definedNames.concat(printAreas);
    }
    (model.media || []).forEach((medium, i) => {
      medium.name = medium.type + (i + 1);
    });
  }
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$7.StdDocAttributes);
    xmlStream2.openNode("workbook", WorkbookXform.WORKBOOK_ATTRIBUTES);
    this.map.fileVersion.render(xmlStream2);
    this.map.workbookPr.render(xmlStream2, model.properties);
    this.map.bookViews.render(xmlStream2, model.views);
    this.map.sheets.render(xmlStream2, model.sheets);
    this.map.definedNames.render(xmlStream2, model.definedNames);
    this.map.calcPr.render(xmlStream2, model.calcProperties);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "workbook":
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        return true;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case "workbook":
        this.model = {
          sheets: this.map.sheets.model,
          properties: this.map.workbookPr.model || {},
          views: this.map.bookViews.model,
          calcProperties: {}
        };
        if (this.map.definedNames.model) {
          this.model.definedNames = this.map.definedNames.model;
        }
        return false;
      default:
        return true;
    }
  }
  reconcile(model) {
    const rels = (model.workbookRels || []).reduce((map3, rel) => {
      map3[rel.Id] = rel;
      return map3;
    }, {});
    const worksheets = [];
    let worksheet2;
    let index2 = 0;
    (model.sheets || []).forEach((sheet) => {
      const rel = rels[sheet.rId];
      if (!rel) {
        return;
      }
      worksheet2 = model.worksheetHash[`xl/${rel.Target.replace(/^(\s|\/xl\/)+/, "")}`];
      if (worksheet2) {
        worksheet2.name = sheet.name;
        worksheet2.id = sheet.id;
        worksheet2.state = sheet.state;
        worksheets[index2++] = worksheet2;
      }
    });
    const definedNames2 = [];
    _$b.each(model.definedNames, (definedName) => {
      if (definedName.name === "_xlnm.Print_Area") {
        worksheet2 = worksheets[definedName.localSheetId];
        if (worksheet2) {
          if (!worksheet2.pageSetup) {
            worksheet2.pageSetup = {};
          }
          const range2 = colCache$9.decodeEx(definedName.ranges[0]);
          worksheet2.pageSetup.printArea = worksheet2.pageSetup.printArea ? `${worksheet2.pageSetup.printArea}&&${range2.dimensions}` : range2.dimensions;
        }
      } else if (definedName.name === "_xlnm.Print_Titles") {
        worksheet2 = worksheets[definedName.localSheetId];
        if (worksheet2) {
          if (!worksheet2.pageSetup) {
            worksheet2.pageSetup = {};
          }
          const rangeString = definedName.ranges.join(",");
          const dollarRegex = /\$/g;
          const rowRangeRegex = /\$\d+:\$\d+/;
          const rowRangeMatches = rangeString.match(rowRangeRegex);
          if (rowRangeMatches && rowRangeMatches.length) {
            const range2 = rowRangeMatches[0];
            worksheet2.pageSetup.printTitlesRow = range2.replace(dollarRegex, "");
          }
          const columnRangeRegex = /\$[A-Z]+:\$[A-Z]+/;
          const columnRangeMatches = rangeString.match(columnRangeRegex);
          if (columnRangeMatches && columnRangeMatches.length) {
            const range2 = columnRangeMatches[0];
            worksheet2.pageSetup.printTitlesColumn = range2.replace(dollarRegex, "");
          }
        }
      } else {
        definedNames2.push(definedName);
      }
    });
    model.definedNames = definedNames2;
    model.media.forEach((media, i) => {
      media.index = i;
    });
  }
};
WorkbookXform$3.WORKBOOK_ATTRIBUTES = {
  xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
  "mc:Ignorable": "x15",
  "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
};
WorkbookXform$3.STATIC_XFORMS = {
  fileVersion: new StaticXform$3({
    tag: "fileVersion",
    $: { appName: "xl", lastEdited: 5, lowestEdited: 5, rupBuild: 9303 }
  })
};
var workbookXform = WorkbookXform$3;
var relType = {
  OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
  CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain",
  SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table"
};
const _$a = underDash;
const Range$3 = range$2;
const colCache$8 = colCache_1;
const Enums$2 = enums;
let Merges$1 = class Merges {
  constructor() {
    this.merges = {};
  }
  add(merge) {
    if (this.merges[merge.master]) {
      this.merges[merge.master].expandToAddress(merge.address);
    } else {
      const range2 = `${merge.master}:${merge.address}`;
      this.merges[merge.master] = new Range$3(range2);
    }
  }
  get mergeCells() {
    return _$a.map(this.merges, (merge) => merge.range);
  }
  reconcile(mergeCells, rows) {
    _$a.each(mergeCells, (merge) => {
      const dimensions = colCache$8.decode(merge);
      for (let i = dimensions.top; i <= dimensions.bottom; i++) {
        const row2 = rows[i - 1];
        for (let j = dimensions.left; j <= dimensions.right; j++) {
          const cell2 = row2.cells[j - 1];
          if (!cell2) {
            row2.cells[j] = {
              type: Enums$2.ValueType.Null,
              address: colCache$8.encodeAddress(i, j)
            };
          } else if (cell2.type === Enums$2.ValueType.Merge) {
            cell2.master = dimensions.tl;
          }
        }
      }
    });
  }
  getMasterAddress(address) {
    const range2 = this.hash[address];
    return range2 && range2.tl;
  }
};
var merges = Merges$1;
const utils$a = utils_1;
const BaseXform$$ = baseXform;
const Range$2 = range$2;
const Enums$1 = enums;
const RichTextXform$1 = richTextXform;
function getValueType(v) {
  if (v === null || v === void 0) {
    return Enums$1.ValueType.Null;
  }
  if (v instanceof String || typeof v === "string") {
    return Enums$1.ValueType.String;
  }
  if (typeof v === "number") {
    return Enums$1.ValueType.Number;
  }
  if (typeof v === "boolean") {
    return Enums$1.ValueType.Boolean;
  }
  if (v instanceof Date) {
    return Enums$1.ValueType.Date;
  }
  if (v.text && v.hyperlink) {
    return Enums$1.ValueType.Hyperlink;
  }
  if (v.formula) {
    return Enums$1.ValueType.Formula;
  }
  if (v.error) {
    return Enums$1.ValueType.Error;
  }
  throw new Error("I could not understand type of value");
}
function getEffectiveCellType(cell2) {
  switch (cell2.type) {
    case Enums$1.ValueType.Formula:
      return getValueType(cell2.result);
    default:
      return cell2.type;
  }
}
let CellXform$1 = class CellXform extends BaseXform$$ {
  constructor() {
    super();
    this.richTextXForm = new RichTextXform$1();
  }
  get tag() {
    return "c";
  }
  prepare(model, options) {
    const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));
    if (styleId) {
      model.styleId = styleId;
    }
    if (model.comment) {
      options.comments.push({ ...model.comment, ref: model.address });
    }
    switch (model.type) {
      case Enums$1.ValueType.String:
      case Enums$1.ValueType.RichText:
        if (options.sharedStrings) {
          model.ssId = options.sharedStrings.add(model.value);
        }
        break;
      case Enums$1.ValueType.Date:
        if (options.date1904) {
          model.date1904 = true;
        }
        break;
      case Enums$1.ValueType.Hyperlink:
        if (options.sharedStrings && model.text !== void 0 && model.text !== null) {
          model.ssId = options.sharedStrings.add(model.text);
        }
        options.hyperlinks.push({
          address: model.address,
          target: model.hyperlink,
          tooltip: model.tooltip
        });
        break;
      case Enums$1.ValueType.Merge:
        options.merges.add(model);
        break;
      case Enums$1.ValueType.Formula:
        if (options.date1904) {
          model.date1904 = true;
        }
        if (model.shareType === "shared") {
          model.si = options.siFormulae++;
        }
        if (model.formula) {
          options.formulae[model.address] = model;
        } else if (model.sharedFormula) {
          const master = options.formulae[model.sharedFormula];
          if (!master) {
            throw new Error(
              `Shared Formula master must exist above and or left of clone for cell ${model.address}`
            );
          }
          if (master.si === void 0) {
            master.shareType = "shared";
            master.si = options.siFormulae++;
            master.range = new Range$2(master.address, model.address);
          } else if (master.range) {
            master.range.expandToAddress(model.address);
          }
          model.si = master.si;
        }
        break;
    }
  }
  renderFormula(xmlStream2, model) {
    let attrs = null;
    switch (model.shareType) {
      case "shared":
        attrs = {
          t: "shared",
          ref: model.ref || model.range.range,
          si: model.si
        };
        break;
      case "array":
        attrs = {
          t: "array",
          ref: model.ref
        };
        break;
      default:
        if (model.si !== void 0) {
          attrs = {
            t: "shared",
            si: model.si
          };
        }
        break;
    }
    switch (getValueType(model.result)) {
      case Enums$1.ValueType.Null:
        xmlStream2.leafNode("f", attrs, model.formula);
        break;
      case Enums$1.ValueType.String:
        xmlStream2.addAttribute("t", "str");
        xmlStream2.leafNode("f", attrs, model.formula);
        xmlStream2.leafNode("v", null, model.result);
        break;
      case Enums$1.ValueType.Number:
        xmlStream2.leafNode("f", attrs, model.formula);
        xmlStream2.leafNode("v", null, model.result);
        break;
      case Enums$1.ValueType.Boolean:
        xmlStream2.addAttribute("t", "b");
        xmlStream2.leafNode("f", attrs, model.formula);
        xmlStream2.leafNode("v", null, model.result ? 1 : 0);
        break;
      case Enums$1.ValueType.Error:
        xmlStream2.addAttribute("t", "e");
        xmlStream2.leafNode("f", attrs, model.formula);
        xmlStream2.leafNode("v", null, model.result.error);
        break;
      case Enums$1.ValueType.Date:
        xmlStream2.leafNode("f", attrs, model.formula);
        xmlStream2.leafNode("v", null, utils$a.dateToExcel(model.result, model.date1904));
        break;
      default:
        throw new Error("I could not understand type of value");
    }
  }
  render(xmlStream2, model) {
    if (model.type === Enums$1.ValueType.Null && !model.styleId) {
      return;
    }
    xmlStream2.openNode("c");
    xmlStream2.addAttribute("r", model.address);
    if (model.styleId) {
      xmlStream2.addAttribute("s", model.styleId);
    }
    switch (model.type) {
      case Enums$1.ValueType.Null:
        break;
      case Enums$1.ValueType.Number:
        xmlStream2.leafNode("v", null, model.value);
        break;
      case Enums$1.ValueType.Boolean:
        xmlStream2.addAttribute("t", "b");
        xmlStream2.leafNode("v", null, model.value ? "1" : "0");
        break;
      case Enums$1.ValueType.Error:
        xmlStream2.addAttribute("t", "e");
        xmlStream2.leafNode("v", null, model.value.error);
        break;
      case Enums$1.ValueType.String:
      case Enums$1.ValueType.RichText:
        if (model.ssId !== void 0) {
          xmlStream2.addAttribute("t", "s");
          xmlStream2.leafNode("v", null, model.ssId);
        } else if (model.value && model.value.richText) {
          xmlStream2.addAttribute("t", "inlineStr");
          xmlStream2.openNode("is");
          model.value.richText.forEach((text) => {
            this.richTextXForm.render(xmlStream2, text);
          });
          xmlStream2.closeNode("is");
        } else {
          xmlStream2.addAttribute("t", "str");
          xmlStream2.leafNode("v", null, model.value);
        }
        break;
      case Enums$1.ValueType.Date:
        xmlStream2.leafNode("v", null, utils$a.dateToExcel(model.value, model.date1904));
        break;
      case Enums$1.ValueType.Hyperlink:
        if (model.ssId !== void 0) {
          xmlStream2.addAttribute("t", "s");
          xmlStream2.leafNode("v", null, model.ssId);
        } else {
          xmlStream2.addAttribute("t", "str");
          xmlStream2.leafNode("v", null, model.text);
        }
        break;
      case Enums$1.ValueType.Formula:
        this.renderFormula(xmlStream2, model);
        break;
      case Enums$1.ValueType.Merge:
        break;
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "c":
        this.model = {
          address: node2.attributes.r
        };
        this.t = node2.attributes.t;
        if (node2.attributes.s) {
          this.model.styleId = parseInt(node2.attributes.s, 10);
        }
        return true;
      case "f":
        this.currentNode = "f";
        this.model.si = node2.attributes.si;
        this.model.shareType = node2.attributes.t;
        this.model.ref = node2.attributes.ref;
        return true;
      case "v":
        this.currentNode = "v";
        return true;
      case "t":
        this.currentNode = "t";
        return true;
      case "r":
        this.parser = this.richTextXForm;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
      return;
    }
    switch (this.currentNode) {
      case "f":
        this.model.formula = this.model.formula ? this.model.formula + text : text;
        break;
      case "v":
      case "t":
        if (this.model.value && this.model.value.richText) {
          this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;
        } else {
          this.model.value = this.model.value ? this.model.value + text : text;
        }
        break;
    }
  }
  parseClose(name) {
    switch (name) {
      case "c": {
        const { model } = this;
        if (model.formula || model.shareType) {
          model.type = Enums$1.ValueType.Formula;
          if (model.value) {
            if (this.t === "str") {
              model.result = utils$a.xmlDecode(model.value);
            } else if (this.t === "b") {
              model.result = parseInt(model.value, 10) !== 0;
            } else if (this.t === "e") {
              model.result = { error: model.value };
            } else {
              model.result = parseFloat(model.value);
            }
            model.value = void 0;
          }
        } else if (model.value !== void 0) {
          switch (this.t) {
            case "s":
              model.type = Enums$1.ValueType.String;
              model.value = parseInt(model.value, 10);
              break;
            case "str":
              model.type = Enums$1.ValueType.String;
              model.value = utils$a.xmlDecode(model.value);
              break;
            case "inlineStr":
              model.type = Enums$1.ValueType.String;
              break;
            case "b":
              model.type = Enums$1.ValueType.Boolean;
              model.value = parseInt(model.value, 10) !== 0;
              break;
            case "e":
              model.type = Enums$1.ValueType.Error;
              model.value = { error: model.value };
              break;
            default:
              model.type = Enums$1.ValueType.Number;
              model.value = parseFloat(model.value);
              break;
          }
        } else if (model.styleId) {
          model.type = Enums$1.ValueType.Null;
        } else {
          model.type = Enums$1.ValueType.Merge;
        }
        return false;
      }
      case "f":
      case "v":
      case "is":
        this.currentNode = void 0;
        return true;
      case "t":
        if (this.parser) {
          this.parser.parseClose(name);
          return true;
        }
        this.currentNode = void 0;
        return true;
      case "r":
        this.model.value = this.model.value || {};
        this.model.value.richText = this.model.value.richText || [];
        this.model.value.richText.push(this.parser.model);
        this.parser = void 0;
        this.currentNode = void 0;
        return true;
      default:
        if (this.parser) {
          this.parser.parseClose(name);
          return true;
        }
        return false;
    }
  }
  reconcile(model, options) {
    const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);
    if (style) {
      model.style = style;
    }
    if (model.styleId !== void 0) {
      model.styleId = void 0;
    }
    switch (model.type) {
      case Enums$1.ValueType.String:
        if (typeof model.value === "number") {
          if (options.sharedStrings) {
            model.value = options.sharedStrings.getString(model.value);
          }
        }
        if (model.value.richText) {
          model.type = Enums$1.ValueType.RichText;
        }
        break;
      case Enums$1.ValueType.Number:
        if (style && utils$a.isDateFmt(style.numFmt)) {
          model.type = Enums$1.ValueType.Date;
          model.value = utils$a.excelToDate(model.value, options.date1904);
        }
        break;
      case Enums$1.ValueType.Formula:
        if (model.result !== void 0 && style && utils$a.isDateFmt(style.numFmt)) {
          model.result = utils$a.excelToDate(model.result, options.date1904);
        }
        if (model.shareType === "shared") {
          if (model.ref) {
            options.formulae[model.si] = model.address;
          } else {
            model.sharedFormula = options.formulae[model.si];
            delete model.shareType;
          }
          delete model.si;
        }
        break;
    }
    const hyperlink = options.hyperlinkMap[model.address];
    if (hyperlink) {
      if (model.type === Enums$1.ValueType.Formula) {
        model.text = model.result;
        model.result = void 0;
      } else {
        model.text = model.value;
        model.value = void 0;
      }
      model.type = Enums$1.ValueType.Hyperlink;
      model.hyperlink = hyperlink;
    }
    const comment = options.commentsMap && options.commentsMap[model.address];
    if (comment) {
      model.comment = comment;
    }
  }
};
var cellXform = CellXform$1;
const BaseXform$_ = baseXform;
const utils$9 = utils_1;
const CellXform2 = cellXform;
let RowXform$2 = class RowXform extends BaseXform$_ {
  constructor(options) {
    super();
    this.maxItems = options && options.maxItems;
    this.map = {
      c: new CellXform2()
    };
  }
  get tag() {
    return "row";
  }
  prepare(model, options) {
    const styleId = options.styles.addStyleModel(model.style);
    if (styleId) {
      model.styleId = styleId;
    }
    const cellXform2 = this.map.c;
    model.cells.forEach((cellModel) => {
      cellXform2.prepare(cellModel, options);
    });
  }
  render(xmlStream2, model, options) {
    xmlStream2.openNode("row");
    xmlStream2.addAttribute("r", model.number);
    if (model.height) {
      xmlStream2.addAttribute("ht", model.height);
      xmlStream2.addAttribute("customHeight", "1");
    }
    if (model.hidden) {
      xmlStream2.addAttribute("hidden", "1");
    }
    if (model.min > 0 && model.max > 0 && model.min <= model.max) {
      xmlStream2.addAttribute("spans", `${model.min}:${model.max}`);
    }
    if (model.styleId) {
      xmlStream2.addAttribute("s", model.styleId);
      xmlStream2.addAttribute("customFormat", "1");
    }
    xmlStream2.addAttribute("x14ac:dyDescent", "0.25");
    if (model.outlineLevel) {
      xmlStream2.addAttribute("outlineLevel", model.outlineLevel);
    }
    if (model.collapsed) {
      xmlStream2.addAttribute("collapsed", "1");
    }
    const cellXform2 = this.map.c;
    model.cells.forEach((cellModel) => {
      cellXform2.render(xmlStream2, cellModel, options);
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    if (node2.name === "row") {
      this.numRowsSeen += 1;
      const spans = node2.attributes.spans ? node2.attributes.spans.split(":").map((span) => parseInt(span, 10)) : [void 0, void 0];
      const model = this.model = {
        number: parseInt(node2.attributes.r, 10),
        min: spans[0],
        max: spans[1],
        cells: []
      };
      if (node2.attributes.s) {
        model.styleId = parseInt(node2.attributes.s, 10);
      }
      if (utils$9.parseBoolean(node2.attributes.hidden)) {
        model.hidden = true;
      }
      if (utils$9.parseBoolean(node2.attributes.bestFit)) {
        model.bestFit = true;
      }
      if (node2.attributes.ht) {
        model.height = parseFloat(node2.attributes.ht);
      }
      if (node2.attributes.outlineLevel) {
        model.outlineLevel = parseInt(node2.attributes.outlineLevel, 10);
      }
      if (utils$9.parseBoolean(node2.attributes.collapsed)) {
        model.collapsed = true;
      }
      return true;
    }
    this.parser = this.map[node2.name];
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    return false;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.cells.push(this.parser.model);
        if (this.maxItems && this.model.cells.length > this.maxItems) {
          throw new Error(`Max column count (${this.maxItems}) exceeded`);
        }
        this.parser = void 0;
      }
      return true;
    }
    return false;
  }
  reconcile(model, options) {
    model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};
    if (model.styleId !== void 0) {
      model.styleId = void 0;
    }
    const cellXform2 = this.map.c;
    model.cells.forEach((cellModel) => {
      cellXform2.reconcile(cellModel, options);
    });
  }
};
var rowXform = RowXform$2;
const utils$8 = utils_1;
const BaseXform$Z = baseXform;
let ColXform$2 = class ColXform extends BaseXform$Z {
  get tag() {
    return "col";
  }
  prepare(model, options) {
    const styleId = options.styles.addStyleModel(model.style || {});
    if (styleId) {
      model.styleId = styleId;
    }
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("col");
    xmlStream2.addAttribute("min", model.min);
    xmlStream2.addAttribute("max", model.max);
    if (model.width) {
      xmlStream2.addAttribute("width", model.width);
    }
    if (model.styleId) {
      xmlStream2.addAttribute("style", model.styleId);
    }
    if (model.hidden) {
      xmlStream2.addAttribute("hidden", "1");
    }
    if (model.bestFit) {
      xmlStream2.addAttribute("bestFit", "1");
    }
    if (model.outlineLevel) {
      xmlStream2.addAttribute("outlineLevel", model.outlineLevel);
    }
    if (model.collapsed) {
      xmlStream2.addAttribute("collapsed", "1");
    }
    xmlStream2.addAttribute("customWidth", "1");
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (node2.name === "col") {
      const model = this.model = {
        min: parseInt(node2.attributes.min || "0", 10),
        max: parseInt(node2.attributes.max || "0", 10),
        width: node2.attributes.width === void 0 ? void 0 : parseFloat(node2.attributes.width || "0")
      };
      if (node2.attributes.style) {
        model.styleId = parseInt(node2.attributes.style, 10);
      }
      if (utils$8.parseBoolean(node2.attributes.hidden)) {
        model.hidden = true;
      }
      if (utils$8.parseBoolean(node2.attributes.bestFit)) {
        model.bestFit = true;
      }
      if (node2.attributes.outlineLevel) {
        model.outlineLevel = parseInt(node2.attributes.outlineLevel, 10);
      }
      if (utils$8.parseBoolean(node2.attributes.collapsed)) {
        model.collapsed = true;
      }
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
  reconcile(model, options) {
    if (model.styleId) {
      model.style = options.styles.getStyleModel(model.styleId);
    }
  }
};
var colXform = ColXform$2;
const BaseXform$Y = baseXform;
let DimensionXform$1 = class DimensionXform extends BaseXform$Y {
  get tag() {
    return "dimension";
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.leafNode("dimension", { ref: model });
    }
  }
  parseOpen(node2) {
    if (node2.name === "dimension") {
      this.model = node2.attributes.ref;
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var dimensionXform = DimensionXform$1;
const BaseXform$X = baseXform;
let HyperlinkXform$2 = class HyperlinkXform extends BaseXform$X {
  get tag() {
    return "hyperlink";
  }
  render(xmlStream2, model) {
    if (this.isInternalLink(model)) {
      xmlStream2.leafNode("hyperlink", {
        ref: model.address,
        "r:id": model.rId,
        tooltip: model.tooltip,
        location: model.target
      });
    } else {
      xmlStream2.leafNode("hyperlink", {
        ref: model.address,
        "r:id": model.rId,
        tooltip: model.tooltip
      });
    }
  }
  parseOpen(node2) {
    if (node2.name === "hyperlink") {
      this.model = {
        address: node2.attributes.ref,
        rId: node2.attributes["r:id"],
        tooltip: node2.attributes.tooltip
      };
      if (node2.attributes.location) {
        this.model.target = node2.attributes.location;
      }
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
  isInternalLink(model) {
    return model.target && /^[^!]+![a-zA-Z]+[\d]+$/.test(model.target);
  }
};
var hyperlinkXform = HyperlinkXform$2;
const BaseXform$W = baseXform;
let MergeCellXform$1 = class MergeCellXform extends BaseXform$W {
  get tag() {
    return "mergeCell";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode("mergeCell", { ref: model });
  }
  parseOpen(node2) {
    if (node2.name === "mergeCell") {
      this.model = node2.attributes.ref;
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var mergeCellXform = MergeCellXform$1;
const _$9 = underDash;
const utils$7 = utils_1;
const colCache$7 = colCache_1;
const BaseXform$V = baseXform;
const Range$1 = range$2;
function assign(definedName, attributes, name, defaultValue) {
  const value = attributes[name];
  if (value !== void 0) {
    definedName[name] = value;
  } else if (defaultValue !== void 0) {
    definedName[name] = defaultValue;
  }
}
function assignBool(definedName, attributes, name, defaultValue) {
  const value = attributes[name];
  if (value !== void 0) {
    definedName[name] = utils$7.parseBoolean(value);
  }
}
function optimiseDataValidations(model) {
  const dvList = _$9.map(model, (dataValidation, address) => ({
    address,
    dataValidation,
    marked: false
  })).sort((a, b) => _$9.strcmp(a.address, b.address));
  const dvMap = _$9.keyBy(dvList, "address");
  const matchCol = (addr, height, col) => {
    for (let i = 0; i < height; i++) {
      const otherAddress = colCache$7.encodeAddress(addr.row + i, col);
      if (!model[otherAddress] || !_$9.isEqual(model[addr.address], model[otherAddress])) {
        return false;
      }
    }
    return true;
  };
  return dvList.map((dv) => {
    if (!dv.marked) {
      const addr = colCache$7.decodeEx(dv.address);
      if (addr.dimensions) {
        dvMap[addr.dimensions].marked = true;
        return {
          ...dv.dataValidation,
          sqref: dv.address
        };
      }
      let height = 1;
      let otherAddress = colCache$7.encodeAddress(addr.row + height, addr.col);
      while (model[otherAddress] && _$9.isEqual(dv.dataValidation, model[otherAddress])) {
        height++;
        otherAddress = colCache$7.encodeAddress(addr.row + height, addr.col);
      }
      let width = 1;
      while (matchCol(addr, height, addr.col + width)) {
        width++;
      }
      for (let i = 0; i < height; i++) {
        for (let j = 0; j < width; j++) {
          otherAddress = colCache$7.encodeAddress(addr.row + i, addr.col + j);
          dvMap[otherAddress].marked = true;
        }
      }
      if (height > 1 || width > 1) {
        const bottom = addr.row + (height - 1);
        const right = addr.col + (width - 1);
        return {
          ...dv.dataValidation,
          sqref: `${dv.address}:${colCache$7.encodeAddress(bottom, right)}`
        };
      }
      return {
        ...dv.dataValidation,
        sqref: dv.address
      };
    }
    return null;
  }).filter(Boolean);
}
let DataValidationsXform$2 = class DataValidationsXform extends BaseXform$V {
  get tag() {
    return "dataValidations";
  }
  render(xmlStream2, model) {
    const optimizedModel = optimiseDataValidations(model);
    if (optimizedModel.length) {
      xmlStream2.openNode("dataValidations", { count: optimizedModel.length });
      optimizedModel.forEach((value) => {
        xmlStream2.openNode("dataValidation");
        if (value.type !== "any") {
          xmlStream2.addAttribute("type", value.type);
          if (value.operator && value.type !== "list" && value.operator !== "between") {
            xmlStream2.addAttribute("operator", value.operator);
          }
          if (value.allowBlank) {
            xmlStream2.addAttribute("allowBlank", "1");
          }
        }
        if (value.showInputMessage) {
          xmlStream2.addAttribute("showInputMessage", "1");
        }
        if (value.promptTitle) {
          xmlStream2.addAttribute("promptTitle", value.promptTitle);
        }
        if (value.prompt) {
          xmlStream2.addAttribute("prompt", value.prompt);
        }
        if (value.showErrorMessage) {
          xmlStream2.addAttribute("showErrorMessage", "1");
        }
        if (value.errorStyle) {
          xmlStream2.addAttribute("errorStyle", value.errorStyle);
        }
        if (value.errorTitle) {
          xmlStream2.addAttribute("errorTitle", value.errorTitle);
        }
        if (value.error) {
          xmlStream2.addAttribute("error", value.error);
        }
        xmlStream2.addAttribute("sqref", value.sqref);
        (value.formulae || []).forEach((formula, index2) => {
          xmlStream2.openNode(`formula${index2 + 1}`);
          if (value.type === "date") {
            xmlStream2.writeText(utils$7.dateToExcel(new Date(formula)));
          } else {
            xmlStream2.writeText(formula);
          }
          xmlStream2.closeNode();
        });
        xmlStream2.closeNode();
      });
      xmlStream2.closeNode();
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case "dataValidations":
        this.model = {};
        return true;
      case "dataValidation": {
        this._address = node2.attributes.sqref;
        const dataValidation = { type: node2.attributes.type || "any", formulae: [] };
        if (node2.attributes.type) {
          assignBool(dataValidation, node2.attributes, "allowBlank");
        }
        assignBool(dataValidation, node2.attributes, "showInputMessage");
        assignBool(dataValidation, node2.attributes, "showErrorMessage");
        switch (dataValidation.type) {
          case "any":
          case "list":
          case "custom":
            break;
          default:
            assign(dataValidation, node2.attributes, "operator", "between");
            break;
        }
        assign(dataValidation, node2.attributes, "promptTitle");
        assign(dataValidation, node2.attributes, "prompt");
        assign(dataValidation, node2.attributes, "errorStyle");
        assign(dataValidation, node2.attributes, "errorTitle");
        assign(dataValidation, node2.attributes, "error");
        this._dataValidation = dataValidation;
        return true;
      }
      case "formula1":
      case "formula2":
        this._formula = [];
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this._formula) {
      this._formula.push(text);
    }
  }
  parseClose(name) {
    switch (name) {
      case "dataValidations":
        return false;
      case "dataValidation": {
        if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {
          delete this._dataValidation.formulae;
          delete this._dataValidation.operator;
        }
        const list = this._address.split(/\s+/g) || [];
        list.forEach((addr) => {
          if (addr.includes(":")) {
            const range2 = new Range$1(addr);
            range2.forEachAddress((address) => {
              this.model[address] = this._dataValidation;
            });
          } else {
            this.model[addr] = this._dataValidation;
          }
        });
        return true;
      }
      case "formula1":
      case "formula2": {
        let formula = this._formula.join("");
        switch (this._dataValidation.type) {
          case "whole":
          case "textLength":
            formula = parseInt(formula, 10);
            break;
          case "decimal":
            formula = parseFloat(formula);
            break;
          case "date":
            formula = utils$7.excelToDate(parseFloat(formula));
            break;
        }
        this._dataValidation.formulae.push(formula);
        this._formula = void 0;
        return true;
      }
      default:
        return true;
    }
  }
};
var dataValidationsXform = DataValidationsXform$2;
const BaseXform$U = baseXform;
let PageSetupPropertiesXform$1 = class PageSetupPropertiesXform extends BaseXform$U {
  get tag() {
    return "pageSetUpPr";
  }
  render(xmlStream2, model) {
    if (model && model.fitToPage) {
      xmlStream2.leafNode(this.tag, {
        fitToPage: model.fitToPage ? "1" : void 0
      });
      return true;
    }
    return false;
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      this.model = {
        fitToPage: node2.attributes.fitToPage === "1"
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var pageSetupPropertiesXform = PageSetupPropertiesXform$1;
const BaseXform$T = baseXform;
const isDefined = (attr) => typeof attr !== "undefined";
let OutlinePropertiesXform$1 = class OutlinePropertiesXform extends BaseXform$T {
  get tag() {
    return "outlinePr";
  }
  render(xmlStream2, model) {
    if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {
      xmlStream2.leafNode(this.tag, {
        summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : void 0,
        summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : void 0
      });
      return true;
    }
    return false;
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      this.model = {
        summaryBelow: isDefined(node2.attributes.summaryBelow) ? Boolean(Number(node2.attributes.summaryBelow)) : void 0,
        summaryRight: isDefined(node2.attributes.summaryRight) ? Boolean(Number(node2.attributes.summaryRight)) : void 0
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var outlinePropertiesXform = OutlinePropertiesXform$1;
const BaseXform$S = baseXform;
const ColorXform$3 = colorXform;
const PageSetupPropertiesXform2 = pageSetupPropertiesXform;
const OutlinePropertiesXform2 = outlinePropertiesXform;
let SheetPropertiesXform$2 = class SheetPropertiesXform extends BaseXform$S {
  constructor() {
    super();
    this.map = {
      tabColor: new ColorXform$3("tabColor"),
      pageSetUpPr: new PageSetupPropertiesXform2(),
      outlinePr: new OutlinePropertiesXform2()
    };
  }
  get tag() {
    return "sheetPr";
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.addRollback();
      xmlStream2.openNode("sheetPr");
      let inner = false;
      inner = this.map.tabColor.render(xmlStream2, model.tabColor) || inner;
      inner = this.map.pageSetUpPr.render(xmlStream2, model.pageSetup) || inner;
      inner = this.map.outlinePr.render(xmlStream2, model.outlineProperties) || inner;
      if (inner) {
        xmlStream2.closeNode();
        xmlStream2.commit();
      } else {
        xmlStream2.rollback();
      }
    }
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    if (node2.name === this.tag) {
      this.reset();
      return true;
    }
    if (this.map[node2.name]) {
      this.parser = this.map[node2.name];
      this.parser.parseOpen(node2);
      return true;
    }
    return false;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
      return true;
    }
    return false;
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {
      this.model = {};
      if (this.map.tabColor.model) {
        this.model.tabColor = this.map.tabColor.model;
      }
      if (this.map.pageSetUpPr.model) {
        this.model.pageSetup = this.map.pageSetUpPr.model;
      }
      if (this.map.outlinePr.model) {
        this.model.outlineProperties = this.map.outlinePr.model;
      }
    } else {
      this.model = null;
    }
    return false;
  }
};
var sheetPropertiesXform = SheetPropertiesXform$2;
const _$8 = underDash;
const BaseXform$R = baseXform;
let SheetFormatPropertiesXform$2 = class SheetFormatPropertiesXform extends BaseXform$R {
  get tag() {
    return "sheetFormatPr";
  }
  render(xmlStream2, model) {
    if (model) {
      const attributes = {
        defaultRowHeight: model.defaultRowHeight,
        outlineLevelRow: model.outlineLevelRow,
        outlineLevelCol: model.outlineLevelCol,
        "x14ac:dyDescent": model.dyDescent
      };
      if (model.defaultColWidth) {
        attributes.defaultColWidth = model.defaultColWidth;
      }
      if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {
        attributes.customHeight = "1";
      }
      if (_$8.some(attributes, (value) => value !== void 0)) {
        xmlStream2.leafNode("sheetFormatPr", attributes);
      }
    }
  }
  parseOpen(node2) {
    if (node2.name === "sheetFormatPr") {
      this.model = {
        defaultRowHeight: parseFloat(node2.attributes.defaultRowHeight || "0"),
        dyDescent: parseFloat(node2.attributes["x14ac:dyDescent"] || "0"),
        outlineLevelRow: parseInt(node2.attributes.outlineLevelRow || "0", 10),
        outlineLevelCol: parseInt(node2.attributes.outlineLevelCol || "0", 10)
      };
      if (node2.attributes.defaultColWidth) {
        this.model.defaultColWidth = parseFloat(node2.attributes.defaultColWidth);
      }
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var sheetFormatPropertiesXform = SheetFormatPropertiesXform$2;
const colCache$6 = colCache_1;
const BaseXform$Q = baseXform;
const VIEW_STATES = {
  frozen: "frozen",
  frozenSplit: "frozen",
  split: "split"
};
let SheetViewXform$2 = class SheetViewXform extends BaseXform$Q {
  get tag() {
    return "sheetView";
  }
  prepare(model) {
    switch (model.state) {
      case "frozen":
      case "split":
        break;
      default:
        model.state = "normal";
        break;
    }
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("sheetView", {
      workbookViewId: model.workbookViewId || 0
    });
    const add = function(name, value, included) {
      if (included) {
        xmlStream2.addAttribute(name, value);
      }
    };
    add("rightToLeft", "1", model.rightToLeft === true);
    add("tabSelected", "1", model.tabSelected);
    add("showRuler", "0", model.showRuler === false);
    add("showRowColHeaders", "0", model.showRowColHeaders === false);
    add("showGridLines", "0", model.showGridLines === false);
    add("zoomScale", model.zoomScale, model.zoomScale);
    add("zoomScaleNormal", model.zoomScaleNormal, model.zoomScaleNormal);
    add("view", model.style, model.style);
    let topLeftCell;
    let xSplit;
    let ySplit;
    let activePane;
    switch (model.state) {
      case "frozen":
        xSplit = model.xSplit || 0;
        ySplit = model.ySplit || 0;
        topLeftCell = model.topLeftCell || colCache$6.getAddress(ySplit + 1, xSplit + 1).address;
        activePane = model.xSplit && model.ySplit && "bottomRight" || model.xSplit && "topRight" || "bottomLeft";
        xmlStream2.leafNode("pane", {
          xSplit: model.xSplit || void 0,
          ySplit: model.ySplit || void 0,
          topLeftCell,
          activePane,
          state: "frozen"
        });
        xmlStream2.leafNode("selection", {
          pane: activePane,
          activeCell: model.activeCell,
          sqref: model.activeCell
        });
        break;
      case "split":
        if (model.activePane === "topLeft") {
          model.activePane = void 0;
        }
        xmlStream2.leafNode("pane", {
          xSplit: model.xSplit || void 0,
          ySplit: model.ySplit || void 0,
          topLeftCell: model.topLeftCell,
          activePane: model.activePane
        });
        xmlStream2.leafNode("selection", {
          pane: model.activePane,
          activeCell: model.activeCell,
          sqref: model.activeCell
        });
        break;
      case "normal":
        if (model.activeCell) {
          xmlStream2.leafNode("selection", {
            activeCell: model.activeCell,
            sqref: model.activeCell
          });
        }
        break;
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    switch (node2.name) {
      case "sheetView":
        this.sheetView = {
          workbookViewId: parseInt(node2.attributes.workbookViewId, 10),
          rightToLeft: node2.attributes.rightToLeft === "1",
          tabSelected: node2.attributes.tabSelected === "1",
          showRuler: !(node2.attributes.showRuler === "0"),
          showRowColHeaders: !(node2.attributes.showRowColHeaders === "0"),
          showGridLines: !(node2.attributes.showGridLines === "0"),
          zoomScale: parseInt(node2.attributes.zoomScale || "100", 10),
          zoomScaleNormal: parseInt(node2.attributes.zoomScaleNormal || "100", 10),
          style: node2.attributes.view
        };
        this.pane = void 0;
        this.selections = {};
        return true;
      case "pane":
        this.pane = {
          xSplit: parseInt(node2.attributes.xSplit || "0", 10),
          ySplit: parseInt(node2.attributes.ySplit || "0", 10),
          topLeftCell: node2.attributes.topLeftCell,
          activePane: node2.attributes.activePane || "topLeft",
          state: node2.attributes.state
        };
        return true;
      case "selection": {
        const name = node2.attributes.pane || "topLeft";
        this.selections[name] = {
          pane: name,
          activeCell: node2.attributes.activeCell
        };
        return true;
      }
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose(name) {
    let model;
    let selection;
    switch (name) {
      case "sheetView":
        if (this.sheetView && this.pane) {
          model = this.model = {
            workbookViewId: this.sheetView.workbookViewId,
            rightToLeft: this.sheetView.rightToLeft,
            state: VIEW_STATES[this.pane.state] || "split",
            // split is default
            xSplit: this.pane.xSplit,
            ySplit: this.pane.ySplit,
            topLeftCell: this.pane.topLeftCell,
            showRuler: this.sheetView.showRuler,
            showRowColHeaders: this.sheetView.showRowColHeaders,
            showGridLines: this.sheetView.showGridLines,
            zoomScale: this.sheetView.zoomScale,
            zoomScaleNormal: this.sheetView.zoomScaleNormal
          };
          if (this.model.state === "split") {
            model.activePane = this.pane.activePane;
          }
          selection = this.selections[this.pane.activePane];
          if (selection && selection.activeCell) {
            model.activeCell = selection.activeCell;
          }
          if (this.sheetView.style) {
            model.style = this.sheetView.style;
          }
        } else {
          model = this.model = {
            workbookViewId: this.sheetView.workbookViewId,
            rightToLeft: this.sheetView.rightToLeft,
            state: "normal",
            showRuler: this.sheetView.showRuler,
            showRowColHeaders: this.sheetView.showRowColHeaders,
            showGridLines: this.sheetView.showGridLines,
            zoomScale: this.sheetView.zoomScale,
            zoomScaleNormal: this.sheetView.zoomScaleNormal
          };
          selection = this.selections.topLeft;
          if (selection && selection.activeCell) {
            model.activeCell = selection.activeCell;
          }
          if (this.sheetView.style) {
            model.style = this.sheetView.style;
          }
        }
        return false;
      default:
        return true;
    }
  }
  reconcile() {
  }
};
var sheetViewXform = SheetViewXform$2;
const _$7 = underDash;
const BaseXform$P = baseXform;
function booleanToXml$2(model, value) {
  return model ? value : void 0;
}
function xmlToBoolean(value, equals) {
  return value === equals ? true : void 0;
}
let SheetProtectionXform$2 = class SheetProtectionXform extends BaseXform$P {
  get tag() {
    return "sheetProtection";
  }
  render(xmlStream2, model) {
    if (model) {
      const attributes = {
        sheet: booleanToXml$2(model.sheet, "1"),
        selectLockedCells: model.selectLockedCells === false ? "1" : void 0,
        selectUnlockedCells: model.selectUnlockedCells === false ? "1" : void 0,
        formatCells: booleanToXml$2(model.formatCells, "0"),
        formatColumns: booleanToXml$2(model.formatColumns, "0"),
        formatRows: booleanToXml$2(model.formatRows, "0"),
        insertColumns: booleanToXml$2(model.insertColumns, "0"),
        insertRows: booleanToXml$2(model.insertRows, "0"),
        insertHyperlinks: booleanToXml$2(model.insertHyperlinks, "0"),
        deleteColumns: booleanToXml$2(model.deleteColumns, "0"),
        deleteRows: booleanToXml$2(model.deleteRows, "0"),
        sort: booleanToXml$2(model.sort, "0"),
        autoFilter: booleanToXml$2(model.autoFilter, "0"),
        pivotTables: booleanToXml$2(model.pivotTables, "0")
      };
      if (model.sheet) {
        attributes.algorithmName = model.algorithmName;
        attributes.hashValue = model.hashValue;
        attributes.saltValue = model.saltValue;
        attributes.spinCount = model.spinCount;
        attributes.objects = booleanToXml$2(model.objects === false, "1");
        attributes.scenarios = booleanToXml$2(model.scenarios === false, "1");
      }
      if (_$7.some(attributes, (value) => value !== void 0)) {
        xmlStream2.leafNode(this.tag, attributes);
      }
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          sheet: xmlToBoolean(node2.attributes.sheet, "1"),
          objects: node2.attributes.objects === "1" ? false : void 0,
          scenarios: node2.attributes.scenarios === "1" ? false : void 0,
          selectLockedCells: node2.attributes.selectLockedCells === "1" ? false : void 0,
          selectUnlockedCells: node2.attributes.selectUnlockedCells === "1" ? false : void 0,
          formatCells: xmlToBoolean(node2.attributes.formatCells, "0"),
          formatColumns: xmlToBoolean(node2.attributes.formatColumns, "0"),
          formatRows: xmlToBoolean(node2.attributes.formatRows, "0"),
          insertColumns: xmlToBoolean(node2.attributes.insertColumns, "0"),
          insertRows: xmlToBoolean(node2.attributes.insertRows, "0"),
          insertHyperlinks: xmlToBoolean(node2.attributes.insertHyperlinks, "0"),
          deleteColumns: xmlToBoolean(node2.attributes.deleteColumns, "0"),
          deleteRows: xmlToBoolean(node2.attributes.deleteRows, "0"),
          sort: xmlToBoolean(node2.attributes.sort, "0"),
          autoFilter: xmlToBoolean(node2.attributes.autoFilter, "0"),
          pivotTables: xmlToBoolean(node2.attributes.pivotTables, "0")
        };
        if (node2.attributes.algorithmName) {
          this.model.algorithmName = node2.attributes.algorithmName;
          this.model.hashValue = node2.attributes.hashValue;
          this.model.saltValue = node2.attributes.saltValue;
          this.model.spinCount = parseInt(node2.attributes.spinCount, 10);
        }
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var sheetProtectionXform = SheetProtectionXform$2;
const _$6 = underDash;
const BaseXform$O = baseXform;
let PageMarginsXform$2 = class PageMarginsXform extends BaseXform$O {
  get tag() {
    return "pageMargins";
  }
  render(xmlStream2, model) {
    if (model) {
      const attributes = {
        left: model.left,
        right: model.right,
        top: model.top,
        bottom: model.bottom,
        header: model.header,
        footer: model.footer
      };
      if (_$6.some(attributes, (value) => value !== void 0)) {
        xmlStream2.leafNode(this.tag, attributes);
      }
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          left: parseFloat(node2.attributes.left || 0.7),
          right: parseFloat(node2.attributes.right || 0.7),
          top: parseFloat(node2.attributes.top || 0.75),
          bottom: parseFloat(node2.attributes.bottom || 0.75),
          header: parseFloat(node2.attributes.header || 0.3),
          footer: parseFloat(node2.attributes.footer || 0.3)
        };
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var pageMarginsXform = PageMarginsXform$2;
const _$5 = underDash;
const BaseXform$N = baseXform;
function booleanToXml$1(model) {
  return model ? "1" : void 0;
}
function pageOrderToXml(model) {
  switch (model) {
    case "overThenDown":
      return model;
    default:
      return void 0;
  }
}
function cellCommentsToXml(model) {
  switch (model) {
    case "atEnd":
    case "asDisplyed":
      return model;
    default:
      return void 0;
  }
}
function errorsToXml(model) {
  switch (model) {
    case "dash":
    case "blank":
    case "NA":
      return model;
    default:
      return void 0;
  }
}
function pageSizeToModel(value) {
  return value !== void 0 ? parseInt(value, 10) : void 0;
}
let PageSetupXform$2 = class PageSetupXform extends BaseXform$N {
  get tag() {
    return "pageSetup";
  }
  render(xmlStream2, model) {
    if (model) {
      const attributes = {
        paperSize: model.paperSize,
        orientation: model.orientation,
        horizontalDpi: model.horizontalDpi,
        verticalDpi: model.verticalDpi,
        pageOrder: pageOrderToXml(model.pageOrder),
        blackAndWhite: booleanToXml$1(model.blackAndWhite),
        draft: booleanToXml$1(model.draft),
        cellComments: cellCommentsToXml(model.cellComments),
        errors: errorsToXml(model.errors),
        scale: model.scale,
        fitToWidth: model.fitToWidth,
        fitToHeight: model.fitToHeight,
        firstPageNumber: model.firstPageNumber,
        useFirstPageNumber: booleanToXml$1(model.firstPageNumber),
        usePrinterDefaults: booleanToXml$1(model.usePrinterDefaults),
        copies: model.copies
      };
      if (_$5.some(attributes, (value) => value !== void 0)) {
        xmlStream2.leafNode(this.tag, attributes);
      }
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          paperSize: pageSizeToModel(node2.attributes.paperSize),
          orientation: node2.attributes.orientation || "portrait",
          horizontalDpi: parseInt(node2.attributes.horizontalDpi || "4294967295", 10),
          verticalDpi: parseInt(node2.attributes.verticalDpi || "4294967295", 10),
          pageOrder: node2.attributes.pageOrder || "downThenOver",
          blackAndWhite: node2.attributes.blackAndWhite === "1",
          draft: node2.attributes.draft === "1",
          cellComments: node2.attributes.cellComments || "None",
          errors: node2.attributes.errors || "displayed",
          scale: parseInt(node2.attributes.scale || "100", 10),
          fitToWidth: parseInt(node2.attributes.fitToWidth || "1", 10),
          fitToHeight: parseInt(node2.attributes.fitToHeight || "1", 10),
          firstPageNumber: parseInt(node2.attributes.firstPageNumber || "1", 10),
          useFirstPageNumber: node2.attributes.useFirstPageNumber === "1",
          usePrinterDefaults: node2.attributes.usePrinterDefaults === "1",
          copies: parseInt(node2.attributes.copies || "1", 10)
        };
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var pageSetupXform = PageSetupXform$2;
const _$4 = underDash;
const BaseXform$M = baseXform;
function booleanToXml(model) {
  return model ? "1" : void 0;
}
let PrintOptionsXform$1 = class PrintOptionsXform extends BaseXform$M {
  get tag() {
    return "printOptions";
  }
  render(xmlStream2, model) {
    if (model) {
      const attributes = {
        headings: booleanToXml(model.showRowColHeaders),
        gridLines: booleanToXml(model.showGridLines),
        horizontalCentered: booleanToXml(model.horizontalCentered),
        verticalCentered: booleanToXml(model.verticalCentered)
      };
      if (_$4.some(attributes, (value) => value !== void 0)) {
        xmlStream2.leafNode(this.tag, attributes);
      }
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          showRowColHeaders: node2.attributes.headings === "1",
          showGridLines: node2.attributes.gridLines === "1",
          horizontalCentered: node2.attributes.horizontalCentered === "1",
          verticalCentered: node2.attributes.verticalCentered === "1"
        };
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var printOptionsXform = PrintOptionsXform$1;
const colCache$5 = colCache_1;
const BaseXform$L = baseXform;
let AutoFilterXform$4 = class AutoFilterXform extends BaseXform$L {
  get tag() {
    return "autoFilter";
  }
  render(xmlStream2, model) {
    if (model) {
      if (typeof model === "string") {
        xmlStream2.leafNode("autoFilter", { ref: model });
      } else {
        const getAddress = function(addr) {
          if (typeof addr === "string") {
            return addr;
          }
          return colCache$5.getAddress(addr.row, addr.column).address;
        };
        const firstAddress = getAddress(model.from);
        const secondAddress = getAddress(model.to);
        if (firstAddress && secondAddress) {
          xmlStream2.leafNode("autoFilter", { ref: `${firstAddress}:${secondAddress}` });
        }
      }
    }
  }
  parseOpen(node2) {
    if (node2.name === "autoFilter") {
      this.model = node2.attributes.ref;
    }
  }
};
var autoFilterXform$1 = AutoFilterXform$4;
const BaseXform$K = baseXform;
let PictureXform$2 = class PictureXform extends BaseXform$K {
  get tag() {
    return "picture";
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.leafNode(this.tag, { "r:id": model.rId });
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          rId: node2.attributes["r:id"]
        };
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var pictureXform = PictureXform$2;
const BaseXform$J = baseXform;
let DrawingXform$3 = class DrawingXform extends BaseXform$J {
  get tag() {
    return "drawing";
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.leafNode(this.tag, { "r:id": model.rId });
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          rId: node2.attributes["r:id"]
        };
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var drawingXform$1 = DrawingXform$3;
const BaseXform$I = baseXform;
let TablePartXform$1 = class TablePartXform extends BaseXform$I {
  get tag() {
    return "tablePart";
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.leafNode(this.tag, { "r:id": model.rId });
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          rId: node2.attributes["r:id"]
        };
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var tablePartXform = TablePartXform$1;
const BaseXform$H = baseXform;
let PageBreaksXform$1 = class PageBreaksXform extends BaseXform$H {
  get tag() {
    return "brk";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode("brk", model);
  }
  parseOpen(node2) {
    if (node2.name === "brk") {
      this.model = node2.attributes.ref;
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var pageBreaksXform = PageBreaksXform$1;
const PageBreaksXform2 = pageBreaksXform;
const ListXform$4 = listXform;
let RowBreaksXform$2 = class RowBreaksXform extends ListXform$4 {
  constructor() {
    const options = {
      tag: "rowBreaks",
      count: true,
      childXform: new PageBreaksXform2()
    };
    super(options);
  }
  // get tag() { return 'rowBreaks'; }
  render(xmlStream2, model) {
    if (model && model.length) {
      xmlStream2.openNode(this.tag, this.$);
      if (this.count) {
        xmlStream2.addAttribute(this.$count, model.length);
        xmlStream2.addAttribute("manualBreakCount", model.length);
      }
      const { childXform } = this;
      model.forEach((childModel) => {
        childXform.render(xmlStream2, childModel);
      });
      xmlStream2.closeNode();
    } else if (this.empty) {
      xmlStream2.leafNode(this.tag);
    }
  }
};
var rowBreaksXform = RowBreaksXform$2;
const BaseXform$G = baseXform;
let HeaderFooterXform$2 = class HeaderFooterXform extends BaseXform$G {
  get tag() {
    return "headerFooter";
  }
  render(xmlStream2, model) {
    if (model) {
      xmlStream2.addRollback();
      let createTag = false;
      xmlStream2.openNode("headerFooter");
      if (model.differentFirst) {
        xmlStream2.addAttribute("differentFirst", "1");
        createTag = true;
      }
      if (model.differentOddEven) {
        xmlStream2.addAttribute("differentOddEven", "1");
        createTag = true;
      }
      if (model.oddHeader && typeof model.oddHeader === "string") {
        xmlStream2.leafNode("oddHeader", null, model.oddHeader);
        createTag = true;
      }
      if (model.oddFooter && typeof model.oddFooter === "string") {
        xmlStream2.leafNode("oddFooter", null, model.oddFooter);
        createTag = true;
      }
      if (model.evenHeader && typeof model.evenHeader === "string") {
        xmlStream2.leafNode("evenHeader", null, model.evenHeader);
        createTag = true;
      }
      if (model.evenFooter && typeof model.evenFooter === "string") {
        xmlStream2.leafNode("evenFooter", null, model.evenFooter);
        createTag = true;
      }
      if (model.firstHeader && typeof model.firstHeader === "string") {
        xmlStream2.leafNode("firstHeader", null, model.firstHeader);
        createTag = true;
      }
      if (model.firstFooter && typeof model.firstFooter === "string") {
        xmlStream2.leafNode("firstFooter", null, model.firstFooter);
        createTag = true;
      }
      if (createTag) {
        xmlStream2.closeNode();
        xmlStream2.commit();
      } else {
        xmlStream2.rollback();
      }
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case "headerFooter":
        this.model = {};
        if (node2.attributes.differentFirst) {
          this.model.differentFirst = parseInt(node2.attributes.differentFirst, 0) === 1;
        }
        if (node2.attributes.differentOddEven) {
          this.model.differentOddEven = parseInt(node2.attributes.differentOddEven, 0) === 1;
        }
        return true;
      case "oddHeader":
        this.currentNode = "oddHeader";
        return true;
      case "oddFooter":
        this.currentNode = "oddFooter";
        return true;
      case "evenHeader":
        this.currentNode = "evenHeader";
        return true;
      case "evenFooter":
        this.currentNode = "evenFooter";
        return true;
      case "firstHeader":
        this.currentNode = "firstHeader";
        return true;
      case "firstFooter":
        this.currentNode = "firstFooter";
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    switch (this.currentNode) {
      case "oddHeader":
        this.model.oddHeader = text;
        break;
      case "oddFooter":
        this.model.oddFooter = text;
        break;
      case "evenHeader":
        this.model.evenHeader = text;
        break;
      case "evenFooter":
        this.model.evenFooter = text;
        break;
      case "firstHeader":
        this.model.firstHeader = text;
        break;
      case "firstFooter":
        this.model.firstFooter = text;
        break;
    }
  }
  parseClose() {
    switch (this.currentNode) {
      case "oddHeader":
      case "oddFooter":
      case "evenHeader":
      case "evenFooter":
      case "firstHeader":
      case "firstFooter":
        this.currentNode = void 0;
        return true;
      default:
        return false;
    }
  }
};
var headerFooterXform = HeaderFooterXform$2;
const BaseXform$F = baseXform;
let CompositeXform$d = class CompositeXform extends BaseXform$F {
  createNewModel(node2) {
    return {};
  }
  parseOpen(node2) {
    this.parser = this.parser || this.map[node2.name];
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    if (node2.name === this.tag) {
      this.model = this.createNewModel(node2);
      return true;
    }
    return false;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  onParserClose(name, parser2) {
    this.model[name] = parser2.model;
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.onParserClose(name, this.parser);
        this.parser = void 0;
      }
      return true;
    }
    return name !== this.tag;
  }
};
var compositeXform = CompositeXform$d;
const BaseXform$E = baseXform;
let CfvoXform$3 = class CfvoXform extends BaseXform$E {
  get tag() {
    return "cfvo";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      type: model.type,
      val: model.value
    });
  }
  parseOpen(node2) {
    this.model = {
      type: node2.attributes.type,
      value: BaseXform$E.toFloatValue(node2.attributes.val)
    };
  }
  parseClose(name) {
    return name !== this.tag;
  }
};
var cfvoXform = CfvoXform$3;
const CompositeXform$c = compositeXform;
const ColorXform$2 = colorXform;
const CfvoXform$2 = cfvoXform;
let DatabarXform$1 = class DatabarXform extends CompositeXform$c {
  constructor() {
    super();
    this.map = {
      cfvo: this.cfvoXform = new CfvoXform$2(),
      color: this.colorXform = new ColorXform$2()
    };
  }
  get tag() {
    return "dataBar";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    model.cfvo.forEach((cfvo) => {
      this.cfvoXform.render(xmlStream2, cfvo);
    });
    this.colorXform.render(xmlStream2, model.color);
    xmlStream2.closeNode();
  }
  createNewModel() {
    return {
      cfvo: []
    };
  }
  onParserClose(name, parser2) {
    switch (name) {
      case "cfvo":
        this.model.cfvo.push(parser2.model);
        break;
      case "color":
        this.model.color = parser2.model;
        break;
    }
  }
};
var databarXform = DatabarXform$1;
const BaseXform$D = baseXform;
const CompositeXform$b = compositeXform;
class X14IdXform extends BaseXform$D {
  get tag() {
    return "x14:id";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, null, model);
  }
  parseOpen() {
    this.model = "";
  }
  parseText(text) {
    this.model += text;
  }
  parseClose(name) {
    return name !== this.tag;
  }
}
let ExtXform$3 = class ExtXform extends CompositeXform$b {
  constructor() {
    super();
    this.map = {
      "x14:id": this.idXform = new X14IdXform()
    };
  }
  get tag() {
    return "ext";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}",
      "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
    });
    this.idXform.render(xmlStream2, model.x14Id);
    xmlStream2.closeNode();
  }
  createNewModel() {
    return {};
  }
  onParserClose(name, parser2) {
    this.model.x14Id = parser2.model;
  }
};
let ExtLstRefXform$1 = class ExtLstRefXform extends CompositeXform$b {
  constructor() {
    super();
    this.map = {
      ext: new ExtXform$3()
    };
  }
  get tag() {
    return "extLst";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    this.map.ext.render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  createNewModel() {
    return {};
  }
  onParserClose(name, parser2) {
    Object.assign(this.model, parser2.model);
  }
};
var extLstRefXform = ExtLstRefXform$1;
const BaseXform$C = baseXform;
let FormulaXform$1 = class FormulaXform extends BaseXform$C {
  get tag() {
    return "formula";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, null, model);
  }
  parseOpen() {
    this.model = "";
  }
  parseText(text) {
    this.model += text;
  }
  parseClose(name) {
    return name !== this.tag;
  }
};
var formulaXform = FormulaXform$1;
const CompositeXform$a = compositeXform;
const ColorXform$1 = colorXform;
const CfvoXform$1 = cfvoXform;
let ColorScaleXform$1 = class ColorScaleXform extends CompositeXform$a {
  constructor() {
    super();
    this.map = {
      cfvo: this.cfvoXform = new CfvoXform$1(),
      color: this.colorXform = new ColorXform$1()
    };
  }
  get tag() {
    return "colorScale";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    model.cfvo.forEach((cfvo) => {
      this.cfvoXform.render(xmlStream2, cfvo);
    });
    model.color.forEach((color) => {
      this.colorXform.render(xmlStream2, color);
    });
    xmlStream2.closeNode();
  }
  createNewModel(node2) {
    return {
      cfvo: [],
      color: []
    };
  }
  onParserClose(name, parser2) {
    this.model[name].push(parser2.model);
  }
};
var colorScaleXform = ColorScaleXform$1;
const BaseXform$B = baseXform;
const CompositeXform$9 = compositeXform;
const CfvoXform2 = cfvoXform;
let IconSetXform$1 = class IconSetXform extends CompositeXform$9 {
  constructor() {
    super();
    this.map = {
      cfvo: this.cfvoXform = new CfvoXform2()
    };
  }
  get tag() {
    return "iconSet";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      iconSet: BaseXform$B.toStringAttribute(model.iconSet, "3TrafficLights"),
      reverse: BaseXform$B.toBoolAttribute(model.reverse, false),
      showValue: BaseXform$B.toBoolAttribute(model.showValue, true)
    });
    model.cfvo.forEach((cfvo) => {
      this.cfvoXform.render(xmlStream2, cfvo);
    });
    xmlStream2.closeNode();
  }
  createNewModel({ attributes }) {
    return {
      iconSet: BaseXform$B.toStringValue(attributes.iconSet, "3TrafficLights"),
      reverse: BaseXform$B.toBoolValue(attributes.reverse),
      showValue: BaseXform$B.toBoolValue(attributes.showValue),
      cfvo: []
    };
  }
  onParserClose(name, parser2) {
    this.model[name].push(parser2.model);
  }
};
var iconSetXform = IconSetXform$1;
const BaseXform$A = baseXform;
const CompositeXform$8 = compositeXform;
const Range2 = range$2;
const DatabarXform2 = databarXform;
const ExtLstRefXform2 = extLstRefXform;
const FormulaXform2 = formulaXform;
const ColorScaleXform2 = colorScaleXform;
const IconSetXform2 = iconSetXform;
const extIcons$1 = {
  "3Triangles": true,
  "3Stars": true,
  "5Boxes": true
};
const getTextFormula = (model) => {
  if (model.formulae && model.formulae[0]) {
    return model.formulae[0];
  }
  const range2 = new Range2(model.ref);
  const { tl } = range2;
  switch (model.operator) {
    case "containsText":
      return `NOT(ISERROR(SEARCH("${model.text}",${tl})))`;
    case "containsBlanks":
      return `LEN(TRIM(${tl}))=0`;
    case "notContainsBlanks":
      return `LEN(TRIM(${tl}))>0`;
    case "containsErrors":
      return `ISERROR(${tl})`;
    case "notContainsErrors":
      return `NOT(ISERROR(${tl}))`;
    default:
      return void 0;
  }
};
const getTimePeriodFormula = (model) => {
  if (model.formulae && model.formulae[0]) {
    return model.formulae[0];
  }
  const range2 = new Range2(model.ref);
  const { tl } = range2;
  switch (model.timePeriod) {
    case "thisWeek":
      return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;
    case "lastWeek":
      return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;
    case "nextWeek":
      return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;
    case "yesterday":
      return `FLOOR(${tl},1)=TODAY()-1`;
    case "today":
      return `FLOOR(${tl},1)=TODAY()`;
    case "tomorrow":
      return `FLOOR(${tl},1)=TODAY()+1`;
    case "last7Days":
      return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;
    case "lastMonth":
      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;
    case "thisMonth":
      return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;
    case "nextMonth":
      return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;
    default:
      return void 0;
  }
};
const opType = (attributes) => {
  const { type, operator } = attributes;
  switch (type) {
    case "containsText":
    case "containsBlanks":
    case "notContainsBlanks":
    case "containsErrors":
    case "notContainsErrors":
      return {
        type: "containsText",
        operator: type
      };
    default:
      return { type, operator };
  }
};
let CfRuleXform$1 = class CfRuleXform extends CompositeXform$8 {
  constructor() {
    super();
    this.map = {
      dataBar: this.databarXform = new DatabarXform2(),
      extLst: this.extLstRefXform = new ExtLstRefXform2(),
      formula: this.formulaXform = new FormulaXform2(),
      colorScale: this.colorScaleXform = new ColorScaleXform2(),
      iconSet: this.iconSetXform = new IconSetXform2()
    };
  }
  get tag() {
    return "cfRule";
  }
  static isPrimitive(rule) {
    if (rule.type === "iconSet") {
      if (rule.custom || extIcons$1[rule.iconSet]) {
        return false;
      }
    }
    return true;
  }
  render(xmlStream2, model) {
    switch (model.type) {
      case "expression":
        this.renderExpression(xmlStream2, model);
        break;
      case "cellIs":
        this.renderCellIs(xmlStream2, model);
        break;
      case "top10":
        this.renderTop10(xmlStream2, model);
        break;
      case "aboveAverage":
        this.renderAboveAverage(xmlStream2, model);
        break;
      case "dataBar":
        this.renderDataBar(xmlStream2, model);
        break;
      case "colorScale":
        this.renderColorScale(xmlStream2, model);
        break;
      case "iconSet":
        this.renderIconSet(xmlStream2, model);
        break;
      case "containsText":
        this.renderText(xmlStream2, model);
        break;
      case "timePeriod":
        this.renderTimePeriod(xmlStream2, model);
        break;
    }
  }
  renderExpression(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: "expression",
      dxfId: model.dxfId,
      priority: model.priority
    });
    this.formulaXform.render(xmlStream2, model.formulae[0]);
    xmlStream2.closeNode();
  }
  renderCellIs(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: "cellIs",
      dxfId: model.dxfId,
      priority: model.priority,
      operator: model.operator
    });
    model.formulae.forEach((formula) => {
      this.formulaXform.render(xmlStream2, formula);
    });
    xmlStream2.closeNode();
  }
  renderTop10(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      type: "top10",
      dxfId: model.dxfId,
      priority: model.priority,
      percent: BaseXform$A.toBoolAttribute(model.percent, false),
      bottom: BaseXform$A.toBoolAttribute(model.bottom, false),
      rank: BaseXform$A.toIntValue(model.rank, 10, true)
    });
  }
  renderAboveAverage(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      type: "aboveAverage",
      dxfId: model.dxfId,
      priority: model.priority,
      aboveAverage: BaseXform$A.toBoolAttribute(model.aboveAverage, true)
    });
  }
  renderDataBar(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: "dataBar",
      priority: model.priority
    });
    this.databarXform.render(xmlStream2, model);
    this.extLstRefXform.render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  renderColorScale(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: "colorScale",
      priority: model.priority
    });
    this.colorScaleXform.render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  renderIconSet(xmlStream2, model) {
    if (!CfRuleXform.isPrimitive(model)) {
      return;
    }
    xmlStream2.openNode(this.tag, {
      type: "iconSet",
      priority: model.priority
    });
    this.iconSetXform.render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  renderText(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: model.operator,
      dxfId: model.dxfId,
      priority: model.priority,
      operator: BaseXform$A.toStringAttribute(model.operator, "containsText")
    });
    const formula = getTextFormula(model);
    if (formula) {
      this.formulaXform.render(xmlStream2, formula);
    }
    xmlStream2.closeNode();
  }
  renderTimePeriod(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: "timePeriod",
      dxfId: model.dxfId,
      priority: model.priority,
      timePeriod: model.timePeriod
    });
    const formula = getTimePeriodFormula(model);
    if (formula) {
      this.formulaXform.render(xmlStream2, formula);
    }
    xmlStream2.closeNode();
  }
  createNewModel({ attributes }) {
    return {
      ...opType(attributes),
      dxfId: BaseXform$A.toIntValue(attributes.dxfId),
      priority: BaseXform$A.toIntValue(attributes.priority),
      timePeriod: attributes.timePeriod,
      percent: BaseXform$A.toBoolValue(attributes.percent),
      bottom: BaseXform$A.toBoolValue(attributes.bottom),
      rank: BaseXform$A.toIntValue(attributes.rank),
      aboveAverage: BaseXform$A.toBoolValue(attributes.aboveAverage)
    };
  }
  onParserClose(name, parser2) {
    switch (name) {
      case "dataBar":
      case "extLst":
      case "colorScale":
      case "iconSet":
        Object.assign(this.model, parser2.model);
        break;
      case "formula":
        this.model.formulae = this.model.formulae || [];
        this.model.formulae.push(parser2.model);
        break;
    }
  }
};
var cfRuleXform = CfRuleXform$1;
const CompositeXform$7 = compositeXform;
const CfRuleXform2 = cfRuleXform;
let ConditionalFormattingXform$1 = class ConditionalFormattingXform extends CompositeXform$7 {
  constructor() {
    super();
    this.map = {
      cfRule: new CfRuleXform2()
    };
  }
  get tag() {
    return "conditionalFormatting";
  }
  render(xmlStream2, model) {
    if (!model.rules.some(CfRuleXform2.isPrimitive)) {
      return;
    }
    xmlStream2.openNode(this.tag, { sqref: model.ref });
    model.rules.forEach((rule) => {
      if (CfRuleXform2.isPrimitive(rule)) {
        rule.ref = model.ref;
        this.map.cfRule.render(xmlStream2, rule);
      }
    });
    xmlStream2.closeNode();
  }
  createNewModel({ attributes }) {
    return {
      ref: attributes.sqref,
      rules: []
    };
  }
  onParserClose(name, parser2) {
    this.model.rules.push(parser2.model);
  }
};
var conditionalFormattingXform = ConditionalFormattingXform$1;
const BaseXform$z = baseXform;
const ConditionalFormattingXform2 = conditionalFormattingXform;
let ConditionalFormattingsXform$2 = class ConditionalFormattingsXform extends BaseXform$z {
  constructor() {
    super();
    this.cfXform = new ConditionalFormattingXform2();
  }
  get tag() {
    return "conditionalFormatting";
  }
  reset() {
    this.model = [];
  }
  prepare(model, options) {
    let nextPriority = model.reduce(
      (p, cf) => Math.max(p, ...cf.rules.map((rule) => rule.priority || 0)),
      1
    );
    model.forEach((cf) => {
      cf.rules.forEach((rule) => {
        if (!rule.priority) {
          rule.priority = nextPriority++;
        }
        if (rule.style) {
          rule.dxfId = options.styles.addDxfStyle(rule.style);
        }
      });
    });
  }
  render(xmlStream2, model) {
    model.forEach((cf) => {
      this.cfXform.render(xmlStream2, cf);
    });
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "conditionalFormatting":
        this.parser = this.cfXform;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.push(this.parser.model);
        this.parser = void 0;
        return false;
      }
      return true;
    }
    return false;
  }
  reconcile(model, options) {
    model.forEach((cf) => {
      cf.rules.forEach((rule) => {
        if (rule.dxfId !== void 0) {
          rule.style = options.styles.getDxfStyle(rule.dxfId);
          delete rule.dxfId;
        }
      });
    });
  }
};
var conditionalFormattingsXform = ConditionalFormattingsXform$2;
const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto$1.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
let _nodeId;
let _clockseq;
let _lastMSecs = 0;
let _lastNSecs = 0;
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node2 = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node2 == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node2 == null) {
      node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node2[n];
  }
  return buf || stringify(b);
}
function parse$2(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse$2(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err2) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto$1.createHash("md5").update(bytes).digest();
}
const v3 = v35("v3", 48, md5);
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return crypto$1.createHash("sha1").update(bytes).digest();
}
const v5 = v35("v5", 80, sha1);
const nil = "00000000-0000-0000-0000-000000000000";
function version$1(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
const esmNode = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$2,
  stringify,
  v1,
  v3,
  v4,
  v5,
  validate,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esmNode);
const BaseXform$y = baseXform;
let FExtXform$1 = class FExtXform extends BaseXform$y {
  get tag() {
    return "xm:f";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, null, model);
  }
  parseOpen() {
    this.model = "";
  }
  parseText(text) {
    this.model += text;
  }
  parseClose(name) {
    return name !== this.tag;
  }
};
var fExtXform = FExtXform$1;
const CompositeXform$6 = compositeXform;
const FExtXform2 = fExtXform;
let CfvoExtXform$2 = class CfvoExtXform extends CompositeXform$6 {
  constructor() {
    super();
    this.map = {
      "xm:f": this.fExtXform = new FExtXform2()
    };
  }
  get tag() {
    return "x14:cfvo";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: model.type
    });
    if (model.value !== void 0) {
      this.fExtXform.render(xmlStream2, model.value);
    }
    xmlStream2.closeNode();
  }
  createNewModel(node2) {
    return {
      type: node2.attributes.type
    };
  }
  onParserClose(name, parser2) {
    switch (name) {
      case "xm:f":
        this.model.value = parser2.model ? parseFloat(parser2.model) : 0;
        break;
    }
  }
};
var cfvoExtXform = CfvoExtXform$2;
const BaseXform$x = baseXform;
const CompositeXform$5 = compositeXform;
const ColorXform2 = colorXform;
const CfvoExtXform$1 = cfvoExtXform;
let DatabarExtXform$1 = class DatabarExtXform extends CompositeXform$5 {
  constructor() {
    super();
    this.map = {
      "x14:cfvo": this.cfvoXform = new CfvoExtXform$1(),
      "x14:borderColor": this.borderColorXform = new ColorXform2("x14:borderColor"),
      "x14:negativeBorderColor": this.negativeBorderColorXform = new ColorXform2(
        "x14:negativeBorderColor"
      ),
      "x14:negativeFillColor": this.negativeFillColorXform = new ColorXform2(
        "x14:negativeFillColor"
      ),
      "x14:axisColor": this.axisColorXform = new ColorXform2("x14:axisColor")
    };
  }
  static isExt(rule) {
    return !rule.gradient;
  }
  get tag() {
    return "x14:dataBar";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      minLength: BaseXform$x.toIntAttribute(model.minLength, 0, true),
      maxLength: BaseXform$x.toIntAttribute(model.maxLength, 100, true),
      border: BaseXform$x.toBoolAttribute(model.border, false),
      gradient: BaseXform$x.toBoolAttribute(model.gradient, true),
      negativeBarColorSameAsPositive: BaseXform$x.toBoolAttribute(
        model.negativeBarColorSameAsPositive,
        true
      ),
      negativeBarBorderColorSameAsPositive: BaseXform$x.toBoolAttribute(
        model.negativeBarBorderColorSameAsPositive,
        true
      ),
      axisPosition: BaseXform$x.toAttribute(model.axisPosition, "auto"),
      direction: BaseXform$x.toAttribute(model.direction, "leftToRight")
    });
    model.cfvo.forEach((cfvo) => {
      this.cfvoXform.render(xmlStream2, cfvo);
    });
    this.borderColorXform.render(xmlStream2, model.borderColor);
    this.negativeBorderColorXform.render(xmlStream2, model.negativeBorderColor);
    this.negativeFillColorXform.render(xmlStream2, model.negativeFillColor);
    this.axisColorXform.render(xmlStream2, model.axisColor);
    xmlStream2.closeNode();
  }
  createNewModel({ attributes }) {
    return {
      cfvo: [],
      minLength: BaseXform$x.toIntValue(attributes.minLength, 0),
      maxLength: BaseXform$x.toIntValue(attributes.maxLength, 100),
      border: BaseXform$x.toBoolValue(attributes.border, false),
      gradient: BaseXform$x.toBoolValue(attributes.gradient, true),
      negativeBarColorSameAsPositive: BaseXform$x.toBoolValue(
        attributes.negativeBarColorSameAsPositive,
        true
      ),
      negativeBarBorderColorSameAsPositive: BaseXform$x.toBoolValue(
        attributes.negativeBarBorderColorSameAsPositive,
        true
      ),
      axisPosition: BaseXform$x.toStringValue(attributes.axisPosition, "auto"),
      direction: BaseXform$x.toStringValue(attributes.direction, "leftToRight")
    };
  }
  onParserClose(name, parser2) {
    const [, prop] = name.split(":");
    switch (prop) {
      case "cfvo":
        this.model.cfvo.push(parser2.model);
        break;
      default:
        this.model[prop] = parser2.model;
        break;
    }
  }
};
var databarExtXform = DatabarExtXform$1;
const BaseXform$w = baseXform;
let CfIconExtXform$1 = class CfIconExtXform extends BaseXform$w {
  get tag() {
    return "x14:cfIcon";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      iconSet: model.iconSet,
      iconId: model.iconId
    });
  }
  parseOpen({ attributes }) {
    this.model = {
      iconSet: attributes.iconSet,
      iconId: BaseXform$w.toIntValue(attributes.iconId)
    };
  }
  parseClose(name) {
    return name !== this.tag;
  }
};
var cfIconExtXform = CfIconExtXform$1;
const BaseXform$v = baseXform;
const CompositeXform$4 = compositeXform;
const CfvoExtXform2 = cfvoExtXform;
const CfIconExtXform2 = cfIconExtXform;
let IconSetExtXform$1 = class IconSetExtXform extends CompositeXform$4 {
  constructor() {
    super();
    this.map = {
      "x14:cfvo": this.cfvoXform = new CfvoExtXform2(),
      "x14:cfIcon": this.cfIconXform = new CfIconExtXform2()
    };
  }
  get tag() {
    return "x14:iconSet";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      iconSet: BaseXform$v.toStringAttribute(model.iconSet),
      reverse: BaseXform$v.toBoolAttribute(model.reverse, false),
      showValue: BaseXform$v.toBoolAttribute(model.showValue, true),
      custom: BaseXform$v.toBoolAttribute(model.icons, false)
    });
    model.cfvo.forEach((cfvo) => {
      this.cfvoXform.render(xmlStream2, cfvo);
    });
    if (model.icons) {
      model.icons.forEach((icon, i) => {
        icon.iconId = i;
        this.cfIconXform.render(xmlStream2, icon);
      });
    }
    xmlStream2.closeNode();
  }
  createNewModel({ attributes }) {
    return {
      cfvo: [],
      iconSet: BaseXform$v.toStringValue(attributes.iconSet, "3TrafficLights"),
      reverse: BaseXform$v.toBoolValue(attributes.reverse, false),
      showValue: BaseXform$v.toBoolValue(attributes.showValue, true)
    };
  }
  onParserClose(name, parser2) {
    const [, prop] = name.split(":");
    switch (prop) {
      case "cfvo":
        this.model.cfvo.push(parser2.model);
        break;
      case "cfIcon":
        if (!this.model.icons) {
          this.model.icons = [];
        }
        this.model.icons.push(parser2.model);
        break;
      default:
        this.model[prop] = parser2.model;
        break;
    }
  }
};
var iconSetExtXform = IconSetExtXform$1;
const { v4: uuidv4 } = require$$0;
const BaseXform$u = baseXform;
const CompositeXform$3 = compositeXform;
const DatabarExtXform2 = databarExtXform;
const IconSetExtXform2 = iconSetExtXform;
const extIcons = {
  "3Triangles": true,
  "3Stars": true,
  "5Boxes": true
};
let CfRuleExtXform$2 = class CfRuleExtXform extends CompositeXform$3 {
  constructor() {
    super();
    this.map = {
      "x14:dataBar": this.databarXform = new DatabarExtXform2(),
      "x14:iconSet": this.iconSetXform = new IconSetExtXform2()
    };
  }
  get tag() {
    return "x14:cfRule";
  }
  static isExt(rule) {
    if (rule.type === "dataBar") {
      return DatabarExtXform2.isExt(rule);
    }
    if (rule.type === "iconSet") {
      if (rule.custom || extIcons[rule.iconSet]) {
        return true;
      }
    }
    return false;
  }
  prepare(model) {
    if (CfRuleExtXform.isExt(model)) {
      model.x14Id = `{${uuidv4()}}`.toUpperCase();
    }
  }
  render(xmlStream2, model) {
    if (!CfRuleExtXform.isExt(model)) {
      return;
    }
    switch (model.type) {
      case "dataBar":
        this.renderDataBar(xmlStream2, model);
        break;
      case "iconSet":
        this.renderIconSet(xmlStream2, model);
        break;
    }
  }
  renderDataBar(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: "dataBar",
      id: model.x14Id
    });
    this.databarXform.render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  renderIconSet(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      type: "iconSet",
      priority: model.priority,
      id: model.x14Id || `{${uuidv4()}}`
    });
    this.iconSetXform.render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  createNewModel({ attributes }) {
    return {
      type: attributes.type,
      x14Id: attributes.id,
      priority: BaseXform$u.toIntValue(attributes.priority)
    };
  }
  onParserClose(name, parser2) {
    Object.assign(this.model, parser2.model);
  }
};
var cfRuleExtXform = CfRuleExtXform$2;
const BaseXform$t = baseXform;
class SqrefExtXform extends BaseXform$t {
  get tag() {
    return "xm:sqref";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, null, model);
  }
  parseOpen() {
    this.model = "";
  }
  parseText(text) {
    this.model += text;
  }
  parseClose(name) {
    return name !== this.tag;
  }
}
var sqrefExtXform = SqrefExtXform;
const CompositeXform$2 = compositeXform;
const SqRefExtXform = sqrefExtXform;
const CfRuleExtXform$1 = cfRuleExtXform;
let ConditionalFormattingExtXform$1 = class ConditionalFormattingExtXform extends CompositeXform$2 {
  constructor() {
    super();
    this.map = {
      "xm:sqref": this.sqRef = new SqRefExtXform(),
      "x14:cfRule": this.cfRule = new CfRuleExtXform$1()
    };
  }
  get tag() {
    return "x14:conditionalFormatting";
  }
  prepare(model, options) {
    model.rules.forEach((rule) => {
      this.cfRule.prepare(rule, options);
    });
  }
  render(xmlStream2, model) {
    if (!model.rules.some(CfRuleExtXform$1.isExt)) {
      return;
    }
    xmlStream2.openNode(this.tag, {
      "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main"
    });
    model.rules.filter(CfRuleExtXform$1.isExt).forEach((rule) => this.cfRule.render(xmlStream2, rule));
    this.sqRef.render(xmlStream2, model.ref);
    xmlStream2.closeNode();
  }
  createNewModel() {
    return {
      rules: []
    };
  }
  onParserClose(name, parser2) {
    switch (name) {
      case "xm:sqref":
        this.model.ref = parser2.model;
        break;
      case "x14:cfRule":
        this.model.rules.push(parser2.model);
        break;
    }
  }
};
var conditionalFormattingExtXform = ConditionalFormattingExtXform$1;
const CompositeXform$1 = compositeXform;
const CfRuleExtXform2 = cfRuleExtXform;
const ConditionalFormattingExtXform2 = conditionalFormattingExtXform;
class ConditionalFormattingsExtXform extends CompositeXform$1 {
  constructor() {
    super();
    this.map = {
      "x14:conditionalFormatting": this.cfXform = new ConditionalFormattingExtXform2()
    };
  }
  get tag() {
    return "x14:conditionalFormattings";
  }
  hasContent(model) {
    if (model.hasExtContent === void 0) {
      model.hasExtContent = model.some((cf) => cf.rules.some(CfRuleExtXform2.isExt));
    }
    return model.hasExtContent;
  }
  prepare(model, options) {
    model.forEach((cf) => {
      this.cfXform.prepare(cf, options);
    });
  }
  render(xmlStream2, model) {
    if (this.hasContent(model)) {
      xmlStream2.openNode(this.tag);
      model.forEach((cf) => this.cfXform.render(xmlStream2, cf));
      xmlStream2.closeNode();
    }
  }
  createNewModel() {
    return [];
  }
  onParserClose(name, parser2) {
    this.model.push(parser2.model);
  }
}
var conditionalFormattingsExtXform = ConditionalFormattingsExtXform;
const CompositeXform2 = compositeXform;
const ConditionalFormattingsExt = conditionalFormattingsExtXform;
let ExtXform$2 = class ExtXform2 extends CompositeXform2 {
  constructor() {
    super();
    this.map = {
      "x14:conditionalFormattings": this.conditionalFormattings = new ConditionalFormattingsExt()
    };
  }
  get tag() {
    return "ext";
  }
  hasContent(model) {
    return this.conditionalFormattings.hasContent(model.conditionalFormattings);
  }
  prepare(model, options) {
    this.conditionalFormattings.prepare(model.conditionalFormattings, options);
  }
  render(xmlStream2, model) {
    xmlStream2.openNode("ext", {
      uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}",
      "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
    });
    this.conditionalFormattings.render(xmlStream2, model.conditionalFormattings);
    xmlStream2.closeNode();
  }
  createNewModel() {
    return {};
  }
  onParserClose(name, parser2) {
    this.model[name] = parser2.model;
  }
};
let ExtLstXform$2 = class ExtLstXform extends CompositeXform2 {
  constructor() {
    super();
    this.map = {
      ext: this.ext = new ExtXform$2()
    };
  }
  get tag() {
    return "extLst";
  }
  prepare(model, options) {
    this.ext.prepare(model, options);
  }
  hasContent(model) {
    return this.ext.hasContent(model);
  }
  render(xmlStream2, model) {
    if (!this.hasContent(model)) {
      return;
    }
    xmlStream2.openNode("extLst");
    this.ext.render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  createNewModel() {
    return {};
  }
  onParserClose(name, parser2) {
    Object.assign(this.model, parser2.model);
  }
};
var extLstXform$1 = ExtLstXform$2;
const _$3 = underDash;
const colCache$4 = colCache_1;
const XmlStream$6 = xmlStream;
const RelType$5 = relType;
const Merges2 = merges;
const BaseXform$s = baseXform;
const ListXform$3 = listXform;
const RowXform$1 = rowXform;
const ColXform$1 = colXform;
const DimensionXform2 = dimensionXform;
const HyperlinkXform$1 = hyperlinkXform;
const MergeCellXform2 = mergeCellXform;
const DataValidationsXform$1 = dataValidationsXform;
const SheetPropertiesXform$1 = sheetPropertiesXform;
const SheetFormatPropertiesXform$1 = sheetFormatPropertiesXform;
const SheetViewXform$1 = sheetViewXform;
const SheetProtectionXform$1 = sheetProtectionXform;
const PageMarginsXform$1 = pageMarginsXform;
const PageSetupXform$1 = pageSetupXform;
const PrintOptionsXform2 = printOptionsXform;
const AutoFilterXform$3 = autoFilterXform$1;
const PictureXform$1 = pictureXform;
const DrawingXform$2 = drawingXform$1;
const TablePartXform2 = tablePartXform;
const RowBreaksXform$1 = rowBreaksXform;
const HeaderFooterXform$1 = headerFooterXform;
const ConditionalFormattingsXform$1 = conditionalFormattingsXform;
const ExtListXform = extLstXform$1;
const mergeRule = (rule, extRule) => {
  Object.keys(extRule).forEach((key) => {
    const value = rule[key];
    const extValue = extRule[key];
    if (value === void 0 && extValue !== void 0) {
      rule[key] = extValue;
    }
  });
};
const mergeConditionalFormattings = (model, extModel) => {
  if (!extModel || !extModel.length) {
    return model;
  }
  if (!model || !model.length) {
    return extModel;
  }
  const cfMap = {};
  const ruleMap = {};
  model.forEach((cf) => {
    cfMap[cf.ref] = cf;
    cf.rules.forEach((rule) => {
      const { x14Id } = rule;
      if (x14Id) {
        ruleMap[x14Id] = rule;
      }
    });
  });
  extModel.forEach((extCf) => {
    extCf.rules.forEach((extRule) => {
      const rule = ruleMap[extRule.x14Id];
      if (rule) {
        mergeRule(rule, extRule);
      } else if (cfMap[extCf.ref]) {
        cfMap[extCf.ref].rules.push(extRule);
      } else {
        model.push({
          ref: extCf.ref,
          rules: [extRule]
        });
      }
    });
  });
  return model;
};
class WorkSheetXform extends BaseXform$s {
  constructor(options) {
    super();
    const { maxRows, maxCols, ignoreNodes } = options || {};
    this.ignoreNodes = ignoreNodes || [];
    this.map = {
      sheetPr: new SheetPropertiesXform$1(),
      dimension: new DimensionXform2(),
      sheetViews: new ListXform$3({
        tag: "sheetViews",
        count: false,
        childXform: new SheetViewXform$1()
      }),
      sheetFormatPr: new SheetFormatPropertiesXform$1(),
      cols: new ListXform$3({ tag: "cols", count: false, childXform: new ColXform$1() }),
      sheetData: new ListXform$3({
        tag: "sheetData",
        count: false,
        empty: true,
        childXform: new RowXform$1({ maxItems: maxCols }),
        maxItems: maxRows
      }),
      autoFilter: new AutoFilterXform$3(),
      mergeCells: new ListXform$3({ tag: "mergeCells", count: true, childXform: new MergeCellXform2() }),
      rowBreaks: new RowBreaksXform$1(),
      hyperlinks: new ListXform$3({
        tag: "hyperlinks",
        count: false,
        childXform: new HyperlinkXform$1()
      }),
      pageMargins: new PageMarginsXform$1(),
      dataValidations: new DataValidationsXform$1(),
      pageSetup: new PageSetupXform$1(),
      headerFooter: new HeaderFooterXform$1(),
      printOptions: new PrintOptionsXform2(),
      picture: new PictureXform$1(),
      drawing: new DrawingXform$2(),
      sheetProtection: new SheetProtectionXform$1(),
      tableParts: new ListXform$3({ tag: "tableParts", count: true, childXform: new TablePartXform2() }),
      conditionalFormatting: new ConditionalFormattingsXform$1(),
      extLst: new ExtListXform()
    };
  }
  prepare(model, options) {
    options.merges = new Merges2();
    model.hyperlinks = options.hyperlinks = [];
    model.comments = options.comments = [];
    options.formulae = {};
    options.siFormulae = 0;
    this.map.cols.prepare(model.cols, options);
    this.map.sheetData.prepare(model.rows, options);
    this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);
    model.mergeCells = options.merges.mergeCells;
    const rels = model.rels = [];
    function nextRid(r) {
      return `rId${r.length + 1}`;
    }
    model.hyperlinks.forEach((hyperlink) => {
      const rId = nextRid(rels);
      hyperlink.rId = rId;
      rels.push({
        Id: rId,
        Type: RelType$5.Hyperlink,
        Target: hyperlink.target,
        TargetMode: "External"
      });
    });
    if (model.comments.length > 0) {
      const comment = {
        Id: nextRid(rels),
        Type: RelType$5.Comments,
        Target: `../comments${model.id}.xml`
      };
      rels.push(comment);
      const vmlDrawing = {
        Id: nextRid(rels),
        Type: RelType$5.VmlDrawing,
        Target: `../drawings/vmlDrawing${model.id}.vml`
      };
      rels.push(vmlDrawing);
      model.comments.forEach((item) => {
        item.refAddress = colCache$4.decodeAddress(item.ref);
      });
      options.commentRefs.push({
        commentName: `comments${model.id}`,
        vmlDrawing: `vmlDrawing${model.id}`
      });
    }
    const drawingRelsHash = [];
    let bookImage;
    model.media.forEach((medium) => {
      if (medium.type === "background") {
        const rId = nextRid(rels);
        bookImage = options.media[medium.imageId];
        rels.push({
          Id: rId,
          Type: RelType$5.Image,
          Target: `../media/${bookImage.name}.${bookImage.extension}`
        });
        model.background = {
          rId
        };
        model.image = options.media[medium.imageId];
      } else if (medium.type === "image") {
        let { drawing } = model;
        bookImage = options.media[medium.imageId];
        if (!drawing) {
          drawing = model.drawing = {
            rId: nextRid(rels),
            name: `drawing${++options.drawingsCount}`,
            anchors: [],
            rels: []
          };
          options.drawings.push(drawing);
          rels.push({
            Id: drawing.rId,
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
            Target: `../drawings/${drawing.name}.xml`
          });
        }
        let rIdImage = this.preImageId === medium.imageId ? drawingRelsHash[medium.imageId] : drawingRelsHash[drawing.rels.length];
        if (!rIdImage) {
          rIdImage = nextRid(drawing.rels);
          drawingRelsHash[drawing.rels.length] = rIdImage;
          drawing.rels.push({
            Id: rIdImage,
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            Target: `../media/${bookImage.name}.${bookImage.extension}`
          });
        }
        const anchor2 = {
          picture: {
            rId: rIdImage
          },
          range: medium.range
        };
        if (medium.hyperlinks && medium.hyperlinks.hyperlink) {
          const rIdHyperLink = nextRid(drawing.rels);
          drawingRelsHash[drawing.rels.length] = rIdHyperLink;
          anchor2.picture.hyperlinks = {
            tooltip: medium.hyperlinks.tooltip,
            rId: rIdHyperLink
          };
          drawing.rels.push({
            Id: rIdHyperLink,
            Type: RelType$5.Hyperlink,
            Target: medium.hyperlinks.hyperlink,
            TargetMode: "External"
          });
        }
        this.preImageId = medium.imageId;
        drawing.anchors.push(anchor2);
      }
    });
    model.tables.forEach((table2) => {
      const rId = nextRid(rels);
      table2.rId = rId;
      rels.push({
        Id: rId,
        Type: RelType$5.Table,
        Target: `../tables/${table2.target}`
      });
      table2.columns.forEach((column2) => {
        const { style } = column2;
        if (style) {
          column2.dxfId = options.styles.addDxfStyle(style);
        }
      });
    });
    this.map.extLst.prepare(model, options);
  }
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$6.StdDocAttributes);
    xmlStream2.openNode("worksheet", WorkSheetXform.WORKSHEET_ATTRIBUTES);
    const sheetFormatPropertiesModel = model.properties ? {
      defaultRowHeight: model.properties.defaultRowHeight,
      dyDescent: model.properties.dyDescent,
      outlineLevelCol: model.properties.outlineLevelCol,
      outlineLevelRow: model.properties.outlineLevelRow
    } : void 0;
    if (model.properties && model.properties.defaultColWidth) {
      sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;
    }
    const sheetPropertiesModel = {
      outlineProperties: model.properties && model.properties.outlineProperties,
      tabColor: model.properties && model.properties.tabColor,
      pageSetup: model.pageSetup && model.pageSetup.fitToPage ? {
        fitToPage: model.pageSetup.fitToPage
      } : void 0
    };
    const pageMarginsModel = model.pageSetup && model.pageSetup.margins;
    const printOptionsModel = {
      showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders,
      showGridLines: model.pageSetup && model.pageSetup.showGridLines,
      horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered,
      verticalCentered: model.pageSetup && model.pageSetup.verticalCentered
    };
    const sheetProtectionModel = model.sheetProtection;
    this.map.sheetPr.render(xmlStream2, sheetPropertiesModel);
    this.map.dimension.render(xmlStream2, model.dimensions);
    this.map.sheetViews.render(xmlStream2, model.views);
    this.map.sheetFormatPr.render(xmlStream2, sheetFormatPropertiesModel);
    this.map.cols.render(xmlStream2, model.cols);
    this.map.sheetData.render(xmlStream2, model.rows);
    this.map.sheetProtection.render(xmlStream2, sheetProtectionModel);
    this.map.autoFilter.render(xmlStream2, model.autoFilter);
    this.map.mergeCells.render(xmlStream2, model.mergeCells);
    this.map.conditionalFormatting.render(xmlStream2, model.conditionalFormattings);
    this.map.dataValidations.render(xmlStream2, model.dataValidations);
    this.map.hyperlinks.render(xmlStream2, model.hyperlinks);
    this.map.printOptions.render(xmlStream2, printOptionsModel);
    this.map.pageMargins.render(xmlStream2, pageMarginsModel);
    this.map.pageSetup.render(xmlStream2, model.pageSetup);
    this.map.headerFooter.render(xmlStream2, model.headerFooter);
    this.map.rowBreaks.render(xmlStream2, model.rowBreaks);
    this.map.drawing.render(xmlStream2, model.drawing);
    this.map.picture.render(xmlStream2, model.background);
    this.map.tableParts.render(xmlStream2, model.tables);
    this.map.extLst.render(xmlStream2, model);
    if (model.rels) {
      model.rels.forEach((rel) => {
        if (rel.Type === RelType$5.VmlDrawing) {
          xmlStream2.leafNode("legacyDrawing", { "r:id": rel.Id });
        }
      });
    }
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    if (node2.name === "worksheet") {
      _$3.each(this.map, (xform2) => {
        xform2.reset();
      });
      return true;
    }
    if (this.map[node2.name] && !this.ignoreNodes.includes(node2.name)) {
      this.parser = this.map[node2.name];
      this.parser.parseOpen(node2);
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case "worksheet": {
        const properties = this.map.sheetFormatPr.model || {};
        if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {
          properties.tabColor = this.map.sheetPr.model.tabColor;
        }
        if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {
          properties.outlineProperties = this.map.sheetPr.model.outlineProperties;
        }
        const sheetProperties = {
          fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false,
          margins: this.map.pageMargins.model
        };
        const pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);
        const conditionalFormattings = mergeConditionalFormattings(
          this.map.conditionalFormatting.model,
          this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]
        );
        this.model = {
          dimensions: this.map.dimension.model,
          cols: this.map.cols.model,
          rows: this.map.sheetData.model,
          mergeCells: this.map.mergeCells.model,
          hyperlinks: this.map.hyperlinks.model,
          dataValidations: this.map.dataValidations.model,
          properties,
          views: this.map.sheetViews.model,
          pageSetup,
          headerFooter: this.map.headerFooter.model,
          background: this.map.picture.model,
          drawing: this.map.drawing.model,
          tables: this.map.tableParts.model,
          conditionalFormattings
        };
        if (this.map.autoFilter.model) {
          this.model.autoFilter = this.map.autoFilter.model;
        }
        if (this.map.sheetProtection.model) {
          this.model.sheetProtection = this.map.sheetProtection.model;
        }
        return false;
      }
      default:
        return true;
    }
  }
  reconcile(model, options) {
    const rels = (model.relationships || []).reduce((h, rel) => {
      h[rel.Id] = rel;
      if (rel.Type === RelType$5.Comments) {
        model.comments = options.comments[rel.Target].comments;
      }
      if (rel.Type === RelType$5.VmlDrawing && model.comments && model.comments.length) {
        const vmlComment = options.vmlDrawings[rel.Target].comments;
        model.comments.forEach((comment, index2) => {
          comment.note = Object.assign({}, comment.note, vmlComment[index2]);
        });
      }
      return h;
    }, {});
    options.commentsMap = (model.comments || []).reduce((h, comment) => {
      if (comment.ref) {
        h[comment.ref] = comment;
      }
      return h;
    }, {});
    options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink) => {
      if (hyperlink.rId) {
        h[hyperlink.address] = rels[hyperlink.rId].Target;
      }
      return h;
    }, {});
    options.formulae = {};
    model.rows = model.rows && model.rows.filter(Boolean) || [];
    model.rows.forEach((row2) => {
      row2.cells = row2.cells && row2.cells.filter(Boolean) || [];
    });
    this.map.cols.reconcile(model.cols, options);
    this.map.sheetData.reconcile(model.rows, options);
    this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);
    model.media = [];
    if (model.drawing) {
      const drawingRel = rels[model.drawing.rId];
      const match2 = drawingRel.Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
      if (match2) {
        const drawingName = match2[1];
        const drawing = options.drawings[drawingName];
        drawing.anchors.forEach((anchor2) => {
          if (anchor2.medium) {
            const image2 = {
              type: "image",
              imageId: anchor2.medium.index,
              range: anchor2.range,
              hyperlinks: anchor2.picture.hyperlinks
            };
            model.media.push(image2);
          }
        });
      }
    }
    const backgroundRel = model.background && rels[model.background.rId];
    if (backgroundRel) {
      const target = backgroundRel.Target.split("/media/")[1];
      const imageId = options.mediaIndex && options.mediaIndex[target];
      if (imageId !== void 0) {
        model.media.push({
          type: "background",
          imageId
        });
      }
    }
    model.tables = (model.tables || []).map((tablePart) => {
      const rel = rels[tablePart.rId];
      return options.tables[rel.Target];
    });
    delete model.relationships;
    delete model.hyperlinks;
    delete model.comments;
  }
}
WorkSheetXform.WORKSHEET_ATTRIBUTES = {
  xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
  "mc:Ignorable": "x14ac",
  "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"
};
var worksheetXform = WorkSheetXform;
const BaseXform$r = baseXform;
let BaseCellAnchorXform$2 = class BaseCellAnchorXform extends BaseXform$r {
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        this.model = {
          range: {
            editAs: node2.attributes.editAs || "oneCell"
          }
        };
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  reconcilePicture(model, options) {
    if (model && model.rId) {
      const rel = options.rels[model.rId];
      const match2 = rel.Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
      if (match2) {
        const name = match2[1];
        const mediaId = options.mediaIndex[name];
        return options.media[mediaId];
      }
    }
    return void 0;
  }
};
var baseCellAnchorXform = BaseCellAnchorXform$2;
const BaseXform$q = baseXform;
const IntegerXform2 = integerXform;
let CellPositionXform$2 = class CellPositionXform extends BaseXform$q {
  constructor(options) {
    super();
    this.tag = options.tag;
    this.map = {
      "xdr:col": new IntegerXform2({ tag: "xdr:col", zero: true }),
      "xdr:colOff": new IntegerXform2({ tag: "xdr:colOff", zero: true }),
      "xdr:row": new IntegerXform2({ tag: "xdr:row", zero: true }),
      "xdr:rowOff": new IntegerXform2({ tag: "xdr:rowOff", zero: true })
    };
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    this.map["xdr:col"].render(xmlStream2, model.nativeCol);
    this.map["xdr:colOff"].render(xmlStream2, model.nativeColOff);
    this.map["xdr:row"].render(xmlStream2, model.nativeRow);
    this.map["xdr:rowOff"].render(xmlStream2, model.nativeRowOff);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model = {
          nativeCol: this.map["xdr:col"].model,
          nativeColOff: this.map["xdr:colOff"].model,
          nativeRow: this.map["xdr:row"].model,
          nativeRowOff: this.map["xdr:rowOff"].model
        };
        return false;
      default:
        return true;
    }
  }
};
var cellPositionXform = CellPositionXform$2;
const BaseXform$p = baseXform;
let BlipXform$1 = class BlipXform extends BaseXform$p {
  get tag() {
    return "a:blip";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      "r:embed": model.rId,
      cstate: "print"
    });
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          rId: node2.attributes["r:embed"]
        };
        return true;
      default:
        return true;
    }
  }
  parseText() {
  }
  parseClose(name) {
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
};
var blipXform = BlipXform$1;
const BaseXform$o = baseXform;
const BlipXform2 = blipXform;
let BlipFillXform$1 = class BlipFillXform extends BaseXform$o {
  constructor() {
    super();
    this.map = {
      "a:blip": new BlipXform2()
    };
  }
  get tag() {
    return "xdr:blipFill";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    this.map["a:blip"].render(xmlStream2, model);
    xmlStream2.openNode("a:stretch");
    xmlStream2.leafNode("a:fillRect");
    xmlStream2.closeNode();
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText() {
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model = this.map["a:blip"].model;
        return false;
      default:
        return true;
    }
  }
};
var blipFillXform = BlipFillXform$1;
const BaseXform$n = baseXform;
class HLinkClickXform extends BaseXform$n {
  get tag() {
    return "a:hlinkClick";
  }
  render(xmlStream2, model) {
    if (!(model.hyperlinks && model.hyperlinks.rId)) {
      return;
    }
    xmlStream2.leafNode(this.tag, {
      "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
      "r:id": model.hyperlinks.rId,
      tooltip: model.hyperlinks.tooltip
    });
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          hyperlinks: {
            rId: node2.attributes["r:id"],
            tooltip: node2.attributes.tooltip
          }
        };
        return true;
      default:
        return true;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
}
var hlinkClickXform = HLinkClickXform;
const BaseXform$m = baseXform;
let ExtLstXform$1 = class ExtLstXform2 extends BaseXform$m {
  get tag() {
    return "a:extLst";
  }
  render(xmlStream2) {
    xmlStream2.openNode(this.tag);
    xmlStream2.openNode("a:ext", {
      uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
    });
    xmlStream2.leafNode("a16:creationId", {
      "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main",
      id: "{00000000-0008-0000-0000-000002000000}"
    });
    xmlStream2.closeNode();
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        return true;
      default:
        return true;
    }
  }
  parseText() {
  }
  parseClose(name) {
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
};
var extLstXform = ExtLstXform$1;
const BaseXform$l = baseXform;
const HlickClickXform = hlinkClickXform;
const ExtLstXform3 = extLstXform;
let CNvPrXform$1 = class CNvPrXform extends BaseXform$l {
  constructor() {
    super();
    this.map = {
      "a:hlinkClick": new HlickClickXform(),
      "a:extLst": new ExtLstXform3()
    };
  }
  get tag() {
    return "xdr:cNvPr";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, {
      id: model.index,
      name: `Picture ${model.index}`
    });
    this.map["a:hlinkClick"].render(xmlStream2, model);
    this.map["a:extLst"].render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText() {
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model = this.map["a:hlinkClick"].model;
        return false;
      default:
        return true;
    }
  }
};
var cNvPrXform = CNvPrXform$1;
const BaseXform$k = baseXform;
let CNvPicPrXform$1 = class CNvPicPrXform extends BaseXform$k {
  get tag() {
    return "xdr:cNvPicPr";
  }
  render(xmlStream2) {
    xmlStream2.openNode(this.tag);
    xmlStream2.leafNode("a:picLocks", {
      noChangeAspect: "1"
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        return true;
      default:
        return true;
    }
  }
  parseText() {
  }
  parseClose(name) {
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
};
var cNvPicPrXform = CNvPicPrXform$1;
const BaseXform$j = baseXform;
const CNvPrXform2 = cNvPrXform;
const CNvPicPrXform2 = cNvPicPrXform;
let NvPicPrXform$1 = class NvPicPrXform extends BaseXform$j {
  constructor() {
    super();
    this.map = {
      "xdr:cNvPr": new CNvPrXform2(),
      "xdr:cNvPicPr": new CNvPicPrXform2()
    };
  }
  get tag() {
    return "xdr:nvPicPr";
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    this.map["xdr:cNvPr"].render(xmlStream2, model);
    this.map["xdr:cNvPicPr"].render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText() {
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model = this.map["xdr:cNvPr"].model;
        return false;
      default:
        return true;
    }
  }
};
var nvPicPrXform = NvPicPrXform$1;
var spPr = {
  tag: "xdr:spPr",
  c: [
    {
      tag: "a:xfrm",
      c: [
        { tag: "a:off", $: { x: "0", y: "0" } },
        { tag: "a:ext", $: { cx: "0", cy: "0" } }
      ]
    },
    {
      tag: "a:prstGeom",
      $: { prst: "rect" },
      c: [{ tag: "a:avLst" }]
    }
  ]
};
const BaseXform$i = baseXform;
const StaticXform$2 = staticXform;
const BlipFillXform2 = blipFillXform;
const NvPicPrXform2 = nvPicPrXform;
const spPrJSON = spPr;
let PicXform$2 = class PicXform extends BaseXform$i {
  constructor() {
    super();
    this.map = {
      "xdr:nvPicPr": new NvPicPrXform2(),
      "xdr:blipFill": new BlipFillXform2(),
      "xdr:spPr": new StaticXform$2(spPrJSON)
    };
  }
  get tag() {
    return "xdr:pic";
  }
  prepare(model, options) {
    model.index = options.index + 1;
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    this.map["xdr:nvPicPr"].render(xmlStream2, model);
    this.map["xdr:blipFill"].render(xmlStream2, model);
    this.map["xdr:spPr"].render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText() {
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.mergeModel(this.parser.model);
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
};
var picXform = PicXform$2;
const BaseCellAnchorXform$1 = baseCellAnchorXform;
const StaticXform$1 = staticXform;
const CellPositionXform$1 = cellPositionXform;
const PicXform$1 = picXform;
let TwoCellAnchorXform$1 = class TwoCellAnchorXform extends BaseCellAnchorXform$1 {
  constructor() {
    super();
    this.map = {
      "xdr:from": new CellPositionXform$1({ tag: "xdr:from" }),
      "xdr:to": new CellPositionXform$1({ tag: "xdr:to" }),
      "xdr:pic": new PicXform$1(),
      "xdr:clientData": new StaticXform$1({ tag: "xdr:clientData" })
    };
  }
  get tag() {
    return "xdr:twoCellAnchor";
  }
  prepare(model, options) {
    this.map["xdr:pic"].prepare(model.picture, options);
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
    this.map["xdr:from"].render(xmlStream2, model.range.tl);
    this.map["xdr:to"].render(xmlStream2, model.range.br);
    this.map["xdr:pic"].render(xmlStream2, model.picture);
    this.map["xdr:clientData"].render(xmlStream2, {});
    xmlStream2.closeNode();
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model.range.tl = this.map["xdr:from"].model;
        this.model.range.br = this.map["xdr:to"].model;
        this.model.picture = this.map["xdr:pic"].model;
        return false;
      default:
        return true;
    }
  }
  reconcile(model, options) {
    model.medium = this.reconcilePicture(model.picture, options);
  }
};
var twoCellAnchorXform = TwoCellAnchorXform$1;
const BaseXform$h = baseXform;
const EMU_PER_PIXEL_AT_96_DPI = 9525;
let ExtXform$1 = class ExtXform3 extends BaseXform$h {
  constructor(options) {
    super();
    this.tag = options.tag;
    this.map = {};
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag);
    const width = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);
    const height = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);
    xmlStream2.addAttribute("cx", width);
    xmlStream2.addAttribute("cy", height);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      this.model = {
        width: parseInt(node2.attributes.cx || "0", 10) / EMU_PER_PIXEL_AT_96_DPI,
        height: parseInt(node2.attributes.cy || "0", 10) / EMU_PER_PIXEL_AT_96_DPI
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var extXform = ExtXform$1;
const BaseCellAnchorXform2 = baseCellAnchorXform;
const StaticXform2 = staticXform;
const CellPositionXform2 = cellPositionXform;
const ExtXform4 = extXform;
const PicXform2 = picXform;
let OneCellAnchorXform$1 = class OneCellAnchorXform extends BaseCellAnchorXform2 {
  constructor() {
    super();
    this.map = {
      "xdr:from": new CellPositionXform2({ tag: "xdr:from" }),
      "xdr:ext": new ExtXform4({ tag: "xdr:ext" }),
      "xdr:pic": new PicXform2(),
      "xdr:clientData": new StaticXform2({ tag: "xdr:clientData" })
    };
  }
  get tag() {
    return "xdr:oneCellAnchor";
  }
  prepare(model, options) {
    this.map["xdr:pic"].prepare(model.picture, options);
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
    this.map["xdr:from"].render(xmlStream2, model.range.tl);
    this.map["xdr:ext"].render(xmlStream2, model.range.ext);
    this.map["xdr:pic"].render(xmlStream2, model.picture);
    this.map["xdr:clientData"].render(xmlStream2, {});
    xmlStream2.closeNode();
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model.range.tl = this.map["xdr:from"].model;
        this.model.range.ext = this.map["xdr:ext"].model;
        this.model.picture = this.map["xdr:pic"].model;
        return false;
      default:
        return true;
    }
  }
  reconcile(model, options) {
    model.medium = this.reconcilePicture(model.picture, options);
  }
};
var oneCellAnchorXform = OneCellAnchorXform$1;
const colCache$3 = colCache_1;
const XmlStream$5 = xmlStream;
const BaseXform$g = baseXform;
const TwoCellAnchorXform2 = twoCellAnchorXform;
const OneCellAnchorXform2 = oneCellAnchorXform;
function getAnchorType(model) {
  const range2 = typeof model.range === "string" ? colCache$3.decode(model.range) : model.range;
  return range2.br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
}
let DrawingXform$1 = class DrawingXform2 extends BaseXform$g {
  constructor() {
    super();
    this.map = {
      "xdr:twoCellAnchor": new TwoCellAnchorXform2(),
      "xdr:oneCellAnchor": new OneCellAnchorXform2()
    };
  }
  prepare(model) {
    model.anchors.forEach((item, index2) => {
      item.anchorType = getAnchorType(item);
      const anchor2 = this.map[item.anchorType];
      anchor2.prepare(item, { index: index2 });
    });
  }
  get tag() {
    return "xdr:wsDr";
  }
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$5.StdDocAttributes);
    xmlStream2.openNode(this.tag, DrawingXform2.DRAWING_ATTRIBUTES);
    model.anchors.forEach((item) => {
      const anchor2 = this.map[item.anchorType];
      anchor2.render(xmlStream2, item);
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        this.model = {
          anchors: []
        };
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.anchors.push(this.parser.model);
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
  reconcile(model, options) {
    model.anchors.forEach((anchor2) => {
      if (anchor2.br) {
        this.map["xdr:twoCellAnchor"].reconcile(anchor2, options);
      } else {
        this.map["xdr:oneCellAnchor"].reconcile(anchor2, options);
      }
    });
  }
};
DrawingXform$1.DRAWING_ATTRIBUTES = {
  "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
  "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main"
};
var drawingXform = DrawingXform$1;
const BaseXform$f = baseXform;
let CustomFilterXform$1 = class CustomFilterXform extends BaseXform$f {
  get tag() {
    return "customFilter";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      val: model.val,
      operator: model.operator
    });
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      this.model = {
        val: node2.attributes.val,
        operator: node2.attributes.operator
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var customFilterXform = CustomFilterXform$1;
const BaseXform$e = baseXform;
let FilterXform$1 = class FilterXform extends BaseXform$e {
  get tag() {
    return "filter";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      val: model.val
    });
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      this.model = {
        val: node2.attributes.val
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var filterXform = FilterXform$1;
const BaseXform$d = baseXform;
const ListXform$2 = listXform;
const CustomFilterXform2 = customFilterXform;
const FilterXform2 = filterXform;
let FilterColumnXform$1 = class FilterColumnXform extends BaseXform$d {
  constructor() {
    super();
    this.map = {
      customFilters: new ListXform$2({
        tag: "customFilters",
        count: false,
        empty: true,
        childXform: new CustomFilterXform2()
      }),
      filters: new ListXform$2({
        tag: "filters",
        count: false,
        empty: true,
        childXform: new FilterXform2()
      })
    };
  }
  get tag() {
    return "filterColumn";
  }
  prepare(model, options) {
    model.colId = options.index.toString();
  }
  render(xmlStream2, model) {
    if (model.customFilters) {
      xmlStream2.openNode(this.tag, {
        colId: model.colId,
        hiddenButton: model.filterButton ? "0" : "1"
      });
      this.map.customFilters.render(xmlStream2, model.customFilters);
      xmlStream2.closeNode();
      return true;
    }
    xmlStream2.leafNode(this.tag, {
      colId: model.colId,
      hiddenButton: model.filterButton ? "0" : "1"
    });
    return true;
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    const { attributes } = node2;
    switch (node2.name) {
      case this.tag:
        this.model = {
          filterButton: attributes.hiddenButton === "0"
        };
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parseOpen(node2);
          return true;
        }
        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
    }
  }
  parseText() {
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model.customFilters = this.map.customFilters.model;
        return false;
      default:
        return true;
    }
  }
};
var filterColumnXform = FilterColumnXform$1;
const BaseXform$c = baseXform;
const FilterColumnXform2 = filterColumnXform;
let AutoFilterXform$2 = class AutoFilterXform2 extends BaseXform$c {
  constructor() {
    super();
    this.map = {
      filterColumn: new FilterColumnXform2()
    };
  }
  get tag() {
    return "autoFilter";
  }
  prepare(model) {
    model.columns.forEach((column2, index2) => {
      this.map.filterColumn.prepare(column2, { index: index2 });
    });
  }
  render(xmlStream2, model) {
    xmlStream2.openNode(this.tag, { ref: model.autoFilterRef });
    model.columns.forEach((column2) => {
      this.map.filterColumn.render(xmlStream2, column2);
    });
    xmlStream2.closeNode();
    return true;
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.model = {
          autoFilterRef: node2.attributes.ref,
          columns: []
        };
        return true;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parseOpen(node2);
          return true;
        }
        throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
    }
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.columns.push(this.parser.model);
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        return false;
      default:
        throw new Error(`Unexpected xml node in parseClose: ${name}`);
    }
  }
};
var autoFilterXform = AutoFilterXform$2;
const BaseXform$b = baseXform;
let TableColumnXform$1 = class TableColumnXform extends BaseXform$b {
  get tag() {
    return "tableColumn";
  }
  prepare(model, options) {
    model.id = options.index + 1;
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      id: model.id.toString(),
      name: model.name,
      totalsRowLabel: model.totalsRowLabel,
      totalsRowFunction: model.totalsRowFunction,
      dxfId: model.dxfId
    });
    return true;
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      const { attributes } = node2;
      this.model = {
        name: attributes.name,
        totalsRowLabel: attributes.totalsRowLabel,
        totalsRowFunction: attributes.totalsRowFunction,
        dxfId: attributes.dxfId
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var tableColumnXform = TableColumnXform$1;
const BaseXform$a = baseXform;
let TableStyleInfoXform$1 = class TableStyleInfoXform extends BaseXform$a {
  get tag() {
    return "tableStyleInfo";
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, {
      name: model.theme ? model.theme : void 0,
      showFirstColumn: model.showFirstColumn ? "1" : "0",
      showLastColumn: model.showLastColumn ? "1" : "0",
      showRowStripes: model.showRowStripes ? "1" : "0",
      showColumnStripes: model.showColumnStripes ? "1" : "0"
    });
    return true;
  }
  parseOpen(node2) {
    if (node2.name === this.tag) {
      const { attributes } = node2;
      this.model = {
        theme: attributes.name ? attributes.name : null,
        showFirstColumn: attributes.showFirstColumn === "1",
        showLastColumn: attributes.showLastColumn === "1",
        showRowStripes: attributes.showRowStripes === "1",
        showColumnStripes: attributes.showColumnStripes === "1"
      };
      return true;
    }
    return false;
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var tableStyleInfoXform = TableStyleInfoXform$1;
const XmlStream$4 = xmlStream;
const BaseXform$9 = baseXform;
const ListXform$1 = listXform;
const AutoFilterXform$1 = autoFilterXform;
const TableColumnXform2 = tableColumnXform;
const TableStyleInfoXform2 = tableStyleInfoXform;
let TableXform$1 = class TableXform extends BaseXform$9 {
  constructor() {
    super();
    this.map = {
      autoFilter: new AutoFilterXform$1(),
      tableColumns: new ListXform$1({
        tag: "tableColumns",
        count: true,
        empty: true,
        childXform: new TableColumnXform2()
      }),
      tableStyleInfo: new TableStyleInfoXform2()
    };
  }
  prepare(model, options) {
    this.map.autoFilter.prepare(model);
    this.map.tableColumns.prepare(model.columns, options);
  }
  get tag() {
    return "table";
  }
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$4.StdDocAttributes);
    xmlStream2.openNode(this.tag, {
      ...TableXform.TABLE_ATTRIBUTES,
      id: model.id,
      name: model.name,
      displayName: model.displayName || model.name,
      ref: model.tableRef,
      totalsRowCount: model.totalsRow ? "1" : void 0,
      totalsRowShown: model.totalsRow ? void 0 : "1",
      headerRowCount: model.headerRow ? "1" : "0"
    });
    this.map.autoFilter.render(xmlStream2, model);
    this.map.tableColumns.render(xmlStream2, model.columns);
    this.map.tableStyleInfo.render(xmlStream2, model.style);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    const { name, attributes } = node2;
    switch (name) {
      case this.tag:
        this.reset();
        this.model = {
          name: attributes.name,
          displayName: attributes.displayName || attributes.name,
          tableRef: attributes.ref,
          totalsRow: attributes.totalsRowCount === "1",
          headerRow: attributes.headerRowCount === "1"
        };
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model.columns = this.map.tableColumns.model;
        if (this.map.autoFilter.model) {
          this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;
          this.map.autoFilter.model.columns.forEach((column2, index2) => {
            this.model.columns[index2].filterButton = column2.filterButton;
          });
        }
        this.model.style = this.map.tableStyleInfo.model;
        return false;
      default:
        return true;
    }
  }
  reconcile(model, options) {
    model.columns.forEach((column2) => {
      if (column2.dxfId !== void 0) {
        column2.style = options.styles.getDxfStyle(column2.dxfId);
      }
    });
  }
};
TableXform$1.TABLE_ATTRIBUTES = {
  xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
  "mc:Ignorable": "xr xr3",
  "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",
  "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3"
  // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',
};
var tableXform = TableXform$1;
var commentsXform = { exports: {} };
var commentXform = { exports: {} };
const RichTextXform2 = richTextXform;
const utils$6 = utils_1;
const BaseXform$8 = baseXform;
const CommentXform$2 = commentXform.exports = function(model) {
  this.model = model;
};
utils$6.inherits(CommentXform$2, BaseXform$8, {
  get tag() {
    return "r";
  },
  get richTextXform() {
    if (!this._richTextXform) {
      this._richTextXform = new RichTextXform2();
    }
    return this._richTextXform;
  },
  render(xmlStream2, model) {
    model = model || this.model;
    xmlStream2.openNode("comment", {
      ref: model.ref,
      authorId: 0
    });
    xmlStream2.openNode("text");
    if (model && model.note && model.note.texts) {
      model.note.texts.forEach((text) => {
        this.richTextXform.render(xmlStream2, text);
      });
    }
    xmlStream2.closeNode();
    xmlStream2.closeNode();
  },
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case "comment":
        this.model = {
          type: "note",
          note: {
            texts: []
          },
          ...node2.attributes
        };
        return true;
      case "r":
        this.parser = this.richTextXform;
        this.parser.parseOpen(node2);
        return true;
      default:
        return false;
    }
  },
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  },
  parseClose(name) {
    switch (name) {
      case "comment":
        return false;
      case "r":
        this.model.note.texts.push(this.parser.model);
        this.parser = void 0;
        return true;
      default:
        if (this.parser) {
          this.parser.parseClose(name);
        }
        return true;
    }
  }
});
var commentXformExports = commentXform.exports;
const XmlStream$3 = xmlStream;
const utils$5 = utils_1;
const BaseXform$7 = baseXform;
const CommentXform$1 = commentXformExports;
const CommentsXform$1 = commentsXform.exports = function() {
  this.map = {
    comment: new CommentXform$1()
  };
};
utils$5.inherits(
  CommentsXform$1,
  BaseXform$7,
  {
    COMMENTS_ATTRIBUTES: {
      xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
    }
  },
  {
    render(xmlStream2, model) {
      model = model || this.model;
      xmlStream2.openXml(XmlStream$3.StdDocAttributes);
      xmlStream2.openNode("comments", CommentsXform$1.COMMENTS_ATTRIBUTES);
      xmlStream2.openNode("authors");
      xmlStream2.leafNode("author", null, "Author");
      xmlStream2.closeNode();
      xmlStream2.openNode("commentList");
      model.comments.forEach((comment) => {
        this.map.comment.render(xmlStream2, comment);
      });
      xmlStream2.closeNode();
      xmlStream2.closeNode();
    },
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "commentList":
          this.model = {
            comments: []
          };
          return true;
        case "comment":
          this.parser = this.map.comment;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    },
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    },
    parseClose(name) {
      switch (name) {
        case "commentList":
          return false;
        case "comment":
          this.model.comments.push(this.parser.model);
          this.parser = void 0;
          return true;
        default:
          if (this.parser) {
            this.parser.parseClose(name);
          }
          return true;
      }
    }
  }
);
var commentsXformExports = commentsXform.exports;
const BaseXform$6 = baseXform;
let VmlTextboxXform$1 = class VmlTextboxXform extends BaseXform$6 {
  get tag() {
    return "v:textbox";
  }
  conversionUnit(value, multiple, unit) {
    return `${parseFloat(value) * multiple.toFixed(2)}${unit}`;
  }
  reverseConversionUnit(inset) {
    return (inset || "").split(",").map((margin) => {
      return Number(parseFloat(this.conversionUnit(parseFloat(margin), 0.1, "")).toFixed(2));
    });
  }
  render(xmlStream2, model) {
    const attributes = {
      style: "mso-direction-alt:auto"
    };
    if (model && model.note) {
      let { inset } = model.note && model.note.margins;
      if (Array.isArray(inset)) {
        inset = inset.map((margin) => {
          return this.conversionUnit(margin, 10, "mm");
        }).join(",");
      }
      if (inset) {
        attributes.inset = inset;
      }
    }
    xmlStream2.openNode("v:textbox", attributes);
    xmlStream2.leafNode("div", { style: "text-align:left" });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {
          inset: this.reverseConversionUnit(node2.attributes.inset)
        };
        return true;
      default:
        return true;
    }
  }
  parseText() {
  }
  parseClose(name) {
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
};
var vmlTextboxXform = VmlTextboxXform$1;
const BaseXform$5 = baseXform;
let VmlAnchorXform$1 = class VmlAnchorXform extends BaseXform$5 {
  get tag() {
    return "x:Anchor";
  }
  getAnchorRect(anchor2) {
    const l = Math.floor(anchor2.left);
    const lf = Math.floor((anchor2.left - l) * 68);
    const t = Math.floor(anchor2.top);
    const tf = Math.floor((anchor2.top - t) * 18);
    const r = Math.floor(anchor2.right);
    const rf = Math.floor((anchor2.right - r) * 68);
    const b = Math.floor(anchor2.bottom);
    const bf = Math.floor((anchor2.bottom - b) * 18);
    return [l, lf, t, tf, r, rf, b, bf];
  }
  getDefaultRect(ref) {
    const l = ref.col;
    const lf = 6;
    const t = Math.max(ref.row - 2, 0);
    const tf = 14;
    const r = l + 2;
    const rf = 2;
    const b = t + 4;
    const bf = 16;
    return [l, lf, t, tf, r, rf, b, bf];
  }
  render(xmlStream2, model) {
    const rect = model.anchor ? this.getAnchorRect(model.anchor) : this.getDefaultRect(model.refAddress);
    xmlStream2.leafNode("x:Anchor", null, rect.join(", "));
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.text = "";
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    this.text = text;
  }
  parseClose() {
    return false;
  }
};
var vmlAnchorXform = VmlAnchorXform$1;
const BaseXform$4 = baseXform;
let VmlProtectionXform$1 = class VmlProtectionXform extends BaseXform$4 {
  constructor(model) {
    super();
    this._model = model;
  }
  get tag() {
    return this._model && this._model.tag;
  }
  render(xmlStream2, model) {
    xmlStream2.leafNode(this.tag, null, model);
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.text = "";
        return true;
      default:
        return false;
    }
  }
  parseText(text) {
    this.text = text;
  }
  parseClose() {
    return false;
  }
};
var vmlProtectionXform = VmlProtectionXform$1;
const BaseXform$3 = baseXform;
let VmlPositionXform$1 = class VmlPositionXform extends BaseXform$3 {
  constructor(model) {
    super();
    this._model = model;
  }
  get tag() {
    return this._model && this._model.tag;
  }
  render(xmlStream2, model, type) {
    if (model === type[2]) {
      xmlStream2.leafNode(this.tag);
    } else if (this.tag === "x:SizeWithCells" && model === type[1]) {
      xmlStream2.leafNode(this.tag);
    }
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.model = {};
        this.model[this.tag] = true;
        return true;
      default:
        return false;
    }
  }
  parseText() {
  }
  parseClose() {
    return false;
  }
};
var vmlPositionXform = VmlPositionXform$1;
const BaseXform$2 = baseXform;
const VmlAnchorXform2 = vmlAnchorXform;
const VmlProtectionXform2 = vmlProtectionXform;
const VmlPositionXform2 = vmlPositionXform;
const POSITION_TYPE = ["twoCells", "oneCells", "absolute"];
let VmlClientDataXform$1 = class VmlClientDataXform extends BaseXform$2 {
  constructor() {
    super();
    this.map = {
      "x:Anchor": new VmlAnchorXform2(),
      "x:Locked": new VmlProtectionXform2({ tag: "x:Locked" }),
      "x:LockText": new VmlProtectionXform2({ tag: "x:LockText" }),
      "x:SizeWithCells": new VmlPositionXform2({ tag: "x:SizeWithCells" }),
      "x:MoveWithCells": new VmlPositionXform2({ tag: "x:MoveWithCells" })
    };
  }
  get tag() {
    return "x:ClientData";
  }
  render(xmlStream2, model) {
    const { protection, editAs } = model.note;
    xmlStream2.openNode(this.tag, { ObjectType: "Note" });
    this.map["x:MoveWithCells"].render(xmlStream2, editAs, POSITION_TYPE);
    this.map["x:SizeWithCells"].render(xmlStream2, editAs, POSITION_TYPE);
    this.map["x:Anchor"].render(xmlStream2, model);
    this.map["x:Locked"].render(xmlStream2, protection.locked);
    xmlStream2.leafNode("x:AutoFill", null, "False");
    this.map["x:LockText"].render(xmlStream2, protection.lockText);
    xmlStream2.leafNode("x:Row", null, model.refAddress.row - 1);
    xmlStream2.leafNode("x:Column", null, model.refAddress.col - 1);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    switch (node2.name) {
      case this.tag:
        this.reset();
        this.model = {
          anchor: [],
          protection: {},
          editAs: ""
        };
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.normalizeModel();
        return false;
      default:
        return true;
    }
  }
  normalizeModel() {
    const position = Object.assign(
      {},
      this.map["x:MoveWithCells"].model,
      this.map["x:SizeWithCells"].model
    );
    const len = Object.keys(position).length;
    this.model.editAs = POSITION_TYPE[len];
    this.model.anchor = this.map["x:Anchor"].text;
    this.model.protection.locked = this.map["x:Locked"].text;
    this.model.protection.lockText = this.map["x:LockText"].text;
  }
};
var vmlClientDataXform = VmlClientDataXform$1;
const BaseXform$1 = baseXform;
const VmlTextboxXform2 = vmlTextboxXform;
const VmlClientDataXform2 = vmlClientDataXform;
let VmlShapeXform$2 = class VmlShapeXform extends BaseXform$1 {
  constructor() {
    super();
    this.map = {
      "v:textbox": new VmlTextboxXform2(),
      "x:ClientData": new VmlClientDataXform2()
    };
  }
  get tag() {
    return "v:shape";
  }
  render(xmlStream2, model, index2) {
    xmlStream2.openNode("v:shape", VmlShapeXform.V_SHAPE_ATTRIBUTES(model, index2));
    xmlStream2.leafNode("v:fill", { color2: "infoBackground [80]" });
    xmlStream2.leafNode("v:shadow", { color: "none [81]", obscured: "t" });
    xmlStream2.leafNode("v:path", { "o:connecttype": "none" });
    this.map["v:textbox"].render(xmlStream2, model);
    this.map["x:ClientData"].render(xmlStream2, model);
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        this.model = {
          margins: {
            insetmode: node2.attributes["o:insetmode"]
          },
          anchor: "",
          editAs: "",
          protection: {}
        };
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset;
        this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection;
        this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor;
        this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs;
        return false;
      default:
        return true;
    }
  }
};
VmlShapeXform$2.V_SHAPE_ATTRIBUTES = (model, index2) => ({
  id: `_x0000_s${1025 + index2}`,
  type: "#_x0000_t202",
  style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden",
  fillcolor: "infoBackground [80]",
  strokecolor: "none [81]",
  "o:insetmode": model.note.margins && model.note.margins.insetmode
});
var vmlShapeXform = VmlShapeXform$2;
const XmlStream$2 = xmlStream;
const BaseXform2 = baseXform;
const VmlShapeXform$1 = vmlShapeXform;
let VmlNotesXform$1 = class VmlNotesXform extends BaseXform2 {
  constructor() {
    super();
    this.map = {
      "v:shape": new VmlShapeXform$1()
    };
  }
  get tag() {
    return "xml";
  }
  render(xmlStream2, model) {
    xmlStream2.openXml(XmlStream$2.StdDocAttributes);
    xmlStream2.openNode(this.tag, VmlNotesXform.DRAWING_ATTRIBUTES);
    xmlStream2.openNode("o:shapelayout", { "v:ext": "edit" });
    xmlStream2.leafNode("o:idmap", { "v:ext": "edit", data: 1 });
    xmlStream2.closeNode();
    xmlStream2.openNode("v:shapetype", {
      id: "_x0000_t202",
      coordsize: "21600,21600",
      "o:spt": 202,
      path: "m,l,21600r21600,l21600,xe"
    });
    xmlStream2.leafNode("v:stroke", { joinstyle: "miter" });
    xmlStream2.leafNode("v:path", { gradientshapeok: "t", "o:connecttype": "rect" });
    xmlStream2.closeNode();
    model.comments.forEach((item, index2) => {
      this.map["v:shape"].render(xmlStream2, item, index2);
    });
    xmlStream2.closeNode();
  }
  parseOpen(node2) {
    if (this.parser) {
      this.parser.parseOpen(node2);
      return true;
    }
    switch (node2.name) {
      case this.tag:
        this.reset();
        this.model = {
          comments: []
        };
        break;
      default:
        this.parser = this.map[node2.name];
        if (this.parser) {
          this.parser.parseOpen(node2);
        }
        break;
    }
    return true;
  }
  parseText(text) {
    if (this.parser) {
      this.parser.parseText(text);
    }
  }
  parseClose(name) {
    if (this.parser) {
      if (!this.parser.parseClose(name)) {
        this.model.comments.push(this.parser.model);
        this.parser = void 0;
      }
      return true;
    }
    switch (name) {
      case this.tag:
        return false;
      default:
        return true;
    }
  }
  reconcile(model, options) {
    model.anchors.forEach((anchor2) => {
      if (anchor2.br) {
        this.map["xdr:twoCellAnchor"].reconcile(anchor2, options);
      } else {
        this.map["xdr:oneCellAnchor"].reconcile(anchor2, options);
      }
    });
  }
};
VmlNotesXform$1.DRAWING_ATTRIBUTES = {
  "xmlns:v": "urn:schemas-microsoft-com:vml",
  "xmlns:o": "urn:schemas-microsoft-com:office:office",
  "xmlns:x": "urn:schemas-microsoft-com:office:excel"
};
var vmlNotesXform = VmlNotesXform$1;
var theme1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/> <a:font script="Hang" typeface="맑은 고딕"/> <a:font script="Hans" typeface="宋体"/> <a:font script="Hant" typeface="新細明體"/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/> <a:font script="Hang" typeface="맑은 고딕"/> <a:font script="Hans" typeface="宋体"/> <a:font script="Hant" typeface="新細明體"/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';
const fs$g = require$$0$2;
const JSZip = lib$1;
const { PassThrough: PassThrough$6 } = readableExports$3;
const ZipStream$1 = zipStream$1;
const StreamBuf$2 = streamBuf;
const utils$4 = utils_1;
const XmlStream$1 = xmlStream;
const { bufferToString } = browserBufferDecode;
const StylesXform$1 = stylesXform;
const CoreXform$1 = coreXform;
const SharedStringsXform$1 = sharedStringsXform;
const RelationshipsXform$2 = relationshipsXform;
const ContentTypesXform$1 = contentTypesXform;
const AppXform$1 = appXform;
const WorkbookXform$2 = workbookXform;
const WorksheetXform2 = worksheetXform;
const DrawingXform3 = drawingXform;
const TableXform2 = tableXform;
const CommentsXform = commentsXformExports;
const VmlNotesXform2 = vmlNotesXform;
const theme1Xml$1 = theme1;
function fsReadFileAsync(filename, options) {
  return new Promise((resolve2, reject2) => {
    fs$g.readFile(filename, options, (error2, data) => {
      if (error2) {
        reject2(error2);
      } else {
        resolve2(data);
      }
    });
  });
}
let XLSX$2 = class XLSX {
  constructor(workbook2) {
    this.workbook = workbook2;
  }
  // ===============================================================================
  // Workbook
  // =========================================================================
  // Read
  async readFile(filename, options) {
    if (!await utils$4.fs.exists(filename)) {
      throw new Error(`File not found: ${filename}`);
    }
    const stream2 = fs$g.createReadStream(filename);
    try {
      const workbook2 = await this.read(stream2, options);
      stream2.close();
      return workbook2;
    } catch (error2) {
      stream2.close();
      throw error2;
    }
  }
  parseRels(stream2) {
    const xform2 = new RelationshipsXform$2();
    return xform2.parseStream(stream2);
  }
  parseWorkbook(stream2) {
    const xform2 = new WorkbookXform$2();
    return xform2.parseStream(stream2);
  }
  parseSharedStrings(stream2) {
    const xform2 = new SharedStringsXform$1();
    return xform2.parseStream(stream2);
  }
  reconcile(model, options) {
    const workbookXform2 = new WorkbookXform$2();
    const worksheetXform2 = new WorksheetXform2(options);
    const drawingXform2 = new DrawingXform3();
    const tableXform2 = new TableXform2();
    workbookXform2.reconcile(model);
    const drawingOptions = {
      media: model.media,
      mediaIndex: model.mediaIndex
    };
    Object.keys(model.drawings).forEach((name) => {
      const drawing = model.drawings[name];
      const drawingRel = model.drawingRels[name];
      if (drawingRel) {
        drawingOptions.rels = drawingRel.reduce((o, rel) => {
          o[rel.Id] = rel;
          return o;
        }, {});
        (drawing.anchors || []).forEach((anchor2) => {
          const hyperlinks = anchor2.picture && anchor2.picture.hyperlinks;
          if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {
            hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;
            delete hyperlinks.rId;
          }
        });
        drawingXform2.reconcile(drawing, drawingOptions);
      }
    });
    const tableOptions = {
      styles: model.styles
    };
    Object.values(model.tables).forEach((table2) => {
      tableXform2.reconcile(table2, tableOptions);
    });
    const sheetOptions = {
      styles: model.styles,
      sharedStrings: model.sharedStrings,
      media: model.media,
      mediaIndex: model.mediaIndex,
      date1904: model.properties && model.properties.date1904,
      drawings: model.drawings,
      comments: model.comments,
      tables: model.tables,
      vmlDrawings: model.vmlDrawings
    };
    model.worksheets.forEach((worksheet2) => {
      worksheet2.relationships = model.worksheetRels[worksheet2.sheetNo];
      worksheetXform2.reconcile(worksheet2, sheetOptions);
    });
    delete model.worksheetHash;
    delete model.worksheetRels;
    delete model.globalRels;
    delete model.sharedStrings;
    delete model.workbookRels;
    delete model.sheetDefs;
    delete model.styles;
    delete model.mediaIndex;
    delete model.drawings;
    delete model.drawingRels;
    delete model.vmlDrawings;
  }
  async _processWorksheetEntry(stream2, model, sheetNo, options, path2) {
    const xform2 = new WorksheetXform2(options);
    const worksheet2 = await xform2.parseStream(stream2);
    worksheet2.sheetNo = sheetNo;
    model.worksheetHash[path2] = worksheet2;
    model.worksheets.push(worksheet2);
  }
  async _processCommentEntry(stream2, model, name) {
    const xform2 = new CommentsXform();
    const comments = await xform2.parseStream(stream2);
    model.comments[`../${name}.xml`] = comments;
  }
  async _processTableEntry(stream2, model, name) {
    const xform2 = new TableXform2();
    const table2 = await xform2.parseStream(stream2);
    model.tables[`../tables/${name}.xml`] = table2;
  }
  async _processWorksheetRelsEntry(stream2, model, sheetNo) {
    const xform2 = new RelationshipsXform$2();
    const relationships = await xform2.parseStream(stream2);
    model.worksheetRels[sheetNo] = relationships;
  }
  async _processMediaEntry(entry, model, filename) {
    const lastDot = filename.lastIndexOf(".");
    if (lastDot >= 1) {
      const extension = filename.substr(lastDot + 1);
      const name = filename.substr(0, lastDot);
      await new Promise((resolve2, reject2) => {
        const streamBuf2 = new StreamBuf$2();
        streamBuf2.on("finish", () => {
          model.mediaIndex[filename] = model.media.length;
          model.mediaIndex[name] = model.media.length;
          const medium = {
            type: "image",
            name,
            extension,
            buffer: streamBuf2.toBuffer()
          };
          model.media.push(medium);
          resolve2();
        });
        entry.on("error", (error2) => {
          reject2(error2);
        });
        entry.pipe(streamBuf2);
      });
    }
  }
  async _processDrawingEntry(entry, model, name) {
    const xform2 = new DrawingXform3();
    const drawing = await xform2.parseStream(entry);
    model.drawings[name] = drawing;
  }
  async _processDrawingRelsEntry(entry, model, name) {
    const xform2 = new RelationshipsXform$2();
    const relationships = await xform2.parseStream(entry);
    model.drawingRels[name] = relationships;
  }
  async _processVmlDrawingEntry(entry, model, name) {
    const xform2 = new VmlNotesXform2();
    const vmlDrawing = await xform2.parseStream(entry);
    model.vmlDrawings[`../drawings/${name}.vml`] = vmlDrawing;
  }
  async _processThemeEntry(entry, model, name) {
    await new Promise((resolve2, reject2) => {
      const stream2 = new StreamBuf$2();
      entry.on("error", reject2);
      stream2.on("error", reject2);
      stream2.on("finish", () => {
        model.themes[name] = stream2.read().toString();
        resolve2();
      });
      entry.pipe(stream2);
    });
  }
  /**
   * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
   */
  createInputStream() {
    throw new Error(
      "`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md"
    );
  }
  async read(stream2, options) {
    if (!stream2[Symbol.asyncIterator] && stream2.pipe) {
      stream2 = stream2.pipe(new PassThrough$6());
    }
    const chunks = [];
    for await (const chunk of stream2) {
      chunks.push(chunk);
    }
    return this.load(Buffer.concat(chunks), options);
  }
  async load(data, options) {
    let buffer;
    if (options && options.base64) {
      buffer = Buffer.from(data.toString(), "base64");
    } else {
      buffer = data;
    }
    const model = {
      worksheets: [],
      worksheetHash: {},
      worksheetRels: [],
      themes: {},
      media: [],
      mediaIndex: {},
      drawings: {},
      drawingRels: {},
      comments: {},
      tables: {},
      vmlDrawings: {}
    };
    const zip2 = await JSZip.loadAsync(buffer);
    for (const entry of Object.values(zip2.files)) {
      if (!entry.dir) {
        let entryName = entry.name;
        if (entryName[0] === "/") {
          entryName = entryName.substr(1);
        }
        let stream2;
        if (entryName.match(/xl\/media\//) || // themes are not parsed as stream
        entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)) {
          stream2 = new PassThrough$6();
          stream2.write(await entry.async("nodebuffer"));
        } else {
          stream2 = new PassThrough$6({
            writableObjectMode: true,
            readableObjectMode: true
          });
          let content;
          if (process.browser) {
            content = bufferToString(await entry.async("nodebuffer"));
          } else {
            content = await entry.async("string");
          }
          const chunkSize = 16 * 1024;
          for (let i = 0; i < content.length; i += chunkSize) {
            stream2.write(content.substring(i, i + chunkSize));
          }
        }
        stream2.end();
        switch (entryName) {
          case "_rels/.rels":
            model.globalRels = await this.parseRels(stream2);
            break;
          case "xl/workbook.xml": {
            const workbook2 = await this.parseWorkbook(stream2);
            model.sheets = workbook2.sheets;
            model.definedNames = workbook2.definedNames;
            model.views = workbook2.views;
            model.properties = workbook2.properties;
            model.calcProperties = workbook2.calcProperties;
            break;
          }
          case "xl/_rels/workbook.xml.rels":
            model.workbookRels = await this.parseRels(stream2);
            break;
          case "xl/sharedStrings.xml":
            model.sharedStrings = new SharedStringsXform$1();
            await model.sharedStrings.parseStream(stream2);
            break;
          case "xl/styles.xml":
            model.styles = new StylesXform$1();
            await model.styles.parseStream(stream2);
            break;
          case "docProps/app.xml": {
            const appXform2 = new AppXform$1();
            const appProperties = await appXform2.parseStream(stream2);
            model.company = appProperties.company;
            model.manager = appProperties.manager;
            break;
          }
          case "docProps/core.xml": {
            const coreXform2 = new CoreXform$1();
            const coreProperties = await coreXform2.parseStream(stream2);
            Object.assign(model, coreProperties);
            break;
          }
          default: {
            let match2 = entryName.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
            if (match2) {
              await this._processWorksheetEntry(stream2, model, match2[1], options, entryName);
              break;
            }
            match2 = entryName.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
            if (match2) {
              await this._processWorksheetRelsEntry(stream2, model, match2[1]);
              break;
            }
            match2 = entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/);
            if (match2) {
              await this._processThemeEntry(stream2, model, match2[1]);
              break;
            }
            match2 = entryName.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);
            if (match2) {
              await this._processMediaEntry(stream2, model, match2[1]);
              break;
            }
            match2 = entryName.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/);
            if (match2) {
              await this._processDrawingEntry(stream2, model, match2[1]);
              break;
            }
            match2 = entryName.match(/xl\/(comments\d+)[.]xml/);
            if (match2) {
              await this._processCommentEntry(stream2, model, match2[1]);
              break;
            }
            match2 = entryName.match(/xl\/tables\/(table\d+)[.]xml/);
            if (match2) {
              await this._processTableEntry(stream2, model, match2[1]);
              break;
            }
            match2 = entryName.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/);
            if (match2) {
              await this._processDrawingRelsEntry(stream2, model, match2[1]);
              break;
            }
            match2 = entryName.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/);
            if (match2) {
              await this._processVmlDrawingEntry(stream2, model, match2[1]);
              break;
            }
          }
        }
      }
    }
    this.reconcile(model, options);
    this.workbook.model = model;
    return this.workbook;
  }
  // =========================================================================
  // Write
  async addMedia(zip2, model) {
    await Promise.all(
      model.media.map(async (medium) => {
        if (medium.type === "image") {
          const filename = `xl/media/${medium.name}.${medium.extension}`;
          if (medium.filename) {
            const data = await fsReadFileAsync(medium.filename);
            return zip2.append(data, { name: filename });
          }
          if (medium.buffer) {
            return zip2.append(medium.buffer, { name: filename });
          }
          if (medium.base64) {
            const dataimg64 = medium.base64;
            const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
            return zip2.append(content, { name: filename, base64: true });
          }
        }
        throw new Error("Unsupported media");
      })
    );
  }
  addDrawings(zip2, model) {
    const drawingXform2 = new DrawingXform3();
    const relsXform = new RelationshipsXform$2();
    model.worksheets.forEach((worksheet2) => {
      const { drawing } = worksheet2;
      if (drawing) {
        drawingXform2.prepare(drawing, {});
        let xml = drawingXform2.toXml(drawing);
        zip2.append(xml, { name: `xl/drawings/${drawing.name}.xml` });
        xml = relsXform.toXml(drawing.rels);
        zip2.append(xml, { name: `xl/drawings/_rels/${drawing.name}.xml.rels` });
      }
    });
  }
  addTables(zip2, model) {
    const tableXform2 = new TableXform2();
    model.worksheets.forEach((worksheet2) => {
      const { tables } = worksheet2;
      tables.forEach((table2) => {
        tableXform2.prepare(table2, {});
        const tableXml = tableXform2.toXml(table2);
        zip2.append(tableXml, { name: `xl/tables/${table2.target}` });
      });
    });
  }
  async addContentTypes(zip2, model) {
    const xform2 = new ContentTypesXform$1();
    const xml = xform2.toXml(model);
    zip2.append(xml, { name: "[Content_Types].xml" });
  }
  async addApp(zip2, model) {
    const xform2 = new AppXform$1();
    const xml = xform2.toXml(model);
    zip2.append(xml, { name: "docProps/app.xml" });
  }
  async addCore(zip2, model) {
    const coreXform2 = new CoreXform$1();
    zip2.append(coreXform2.toXml(model), { name: "docProps/core.xml" });
  }
  async addThemes(zip2, model) {
    const themes = model.themes || { theme1: theme1Xml$1 };
    Object.keys(themes).forEach((name) => {
      const xml = themes[name];
      const path2 = `xl/theme/${name}.xml`;
      zip2.append(xml, { name: path2 });
    });
  }
  async addOfficeRels(zip2) {
    const xform2 = new RelationshipsXform$2();
    const xml = xform2.toXml([
      { Id: "rId1", Type: XLSX.RelType.OfficeDocument, Target: "xl/workbook.xml" },
      { Id: "rId2", Type: XLSX.RelType.CoreProperties, Target: "docProps/core.xml" },
      { Id: "rId3", Type: XLSX.RelType.ExtenderProperties, Target: "docProps/app.xml" }
    ]);
    zip2.append(xml, { name: "_rels/.rels" });
  }
  async addWorkbookRels(zip2, model) {
    let count = 1;
    const relationships = [
      { Id: `rId${count++}`, Type: XLSX.RelType.Styles, Target: "styles.xml" },
      { Id: `rId${count++}`, Type: XLSX.RelType.Theme, Target: "theme/theme1.xml" }
    ];
    if (model.sharedStrings.count) {
      relationships.push({
        Id: `rId${count++}`,
        Type: XLSX.RelType.SharedStrings,
        Target: "sharedStrings.xml"
      });
    }
    model.worksheets.forEach((worksheet2) => {
      worksheet2.rId = `rId${count++}`;
      relationships.push({
        Id: worksheet2.rId,
        Type: XLSX.RelType.Worksheet,
        Target: `worksheets/sheet${worksheet2.id}.xml`
      });
    });
    const xform2 = new RelationshipsXform$2();
    const xml = xform2.toXml(relationships);
    zip2.append(xml, { name: "xl/_rels/workbook.xml.rels" });
  }
  async addSharedStrings(zip2, model) {
    if (model.sharedStrings && model.sharedStrings.count) {
      zip2.append(model.sharedStrings.xml, { name: "xl/sharedStrings.xml" });
    }
  }
  async addStyles(zip2, model) {
    const { xml } = model.styles;
    if (xml) {
      zip2.append(xml, { name: "xl/styles.xml" });
    }
  }
  async addWorkbook(zip2, model) {
    const xform2 = new WorkbookXform$2();
    zip2.append(xform2.toXml(model), { name: "xl/workbook.xml" });
  }
  async addWorksheets(zip2, model) {
    const worksheetXform2 = new WorksheetXform2();
    const relationshipsXform2 = new RelationshipsXform$2();
    const commentsXform2 = new CommentsXform();
    const vmlNotesXform2 = new VmlNotesXform2();
    model.worksheets.forEach((worksheet2) => {
      let xmlStream2 = new XmlStream$1();
      worksheetXform2.render(xmlStream2, worksheet2);
      zip2.append(xmlStream2.xml, { name: `xl/worksheets/sheet${worksheet2.id}.xml` });
      if (worksheet2.rels && worksheet2.rels.length) {
        xmlStream2 = new XmlStream$1();
        relationshipsXform2.render(xmlStream2, worksheet2.rels);
        zip2.append(xmlStream2.xml, { name: `xl/worksheets/_rels/sheet${worksheet2.id}.xml.rels` });
      }
      if (worksheet2.comments.length > 0) {
        xmlStream2 = new XmlStream$1();
        commentsXform2.render(xmlStream2, worksheet2);
        zip2.append(xmlStream2.xml, { name: `xl/comments${worksheet2.id}.xml` });
        xmlStream2 = new XmlStream$1();
        vmlNotesXform2.render(xmlStream2, worksheet2);
        zip2.append(xmlStream2.xml, { name: `xl/drawings/vmlDrawing${worksheet2.id}.vml` });
      }
    });
  }
  _finalize(zip2) {
    return new Promise((resolve2, reject2) => {
      zip2.on("finish", () => {
        resolve2(this);
      });
      zip2.on("error", reject2);
      zip2.finalize();
    });
  }
  prepareModel(model, options) {
    model.creator = model.creator || "ExcelJS";
    model.lastModifiedBy = model.lastModifiedBy || "ExcelJS";
    model.created = model.created || /* @__PURE__ */ new Date();
    model.modified = model.modified || /* @__PURE__ */ new Date();
    model.useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : true;
    model.useStyles = options.useStyles !== void 0 ? options.useStyles : true;
    model.sharedStrings = new SharedStringsXform$1();
    model.styles = model.useStyles ? new StylesXform$1(true) : new StylesXform$1.Mock();
    const workbookXform2 = new WorkbookXform$2();
    const worksheetXform2 = new WorksheetXform2();
    workbookXform2.prepare(model);
    const worksheetOptions = {
      sharedStrings: model.sharedStrings,
      styles: model.styles,
      date1904: model.properties.date1904,
      drawingsCount: 0,
      media: model.media
    };
    worksheetOptions.drawings = model.drawings = [];
    worksheetOptions.commentRefs = model.commentRefs = [];
    let tableCount = 0;
    model.tables = [];
    model.worksheets.forEach((worksheet2) => {
      worksheet2.tables.forEach((table2) => {
        tableCount++;
        table2.target = `table${tableCount}.xml`;
        table2.id = tableCount;
        model.tables.push(table2);
      });
      worksheetXform2.prepare(worksheet2, worksheetOptions);
    });
  }
  async write(stream2, options) {
    options = options || {};
    const { model } = this.workbook;
    const zip2 = new ZipStream$1.ZipWriter(options.zip);
    zip2.pipe(stream2);
    this.prepareModel(model, options);
    await this.addContentTypes(zip2, model);
    await this.addOfficeRels(zip2, model);
    await this.addWorkbookRels(zip2, model);
    await this.addWorksheets(zip2, model);
    await this.addSharedStrings(zip2, model);
    await this.addDrawings(zip2, model);
    await this.addTables(zip2, model);
    await Promise.all([this.addThemes(zip2, model), this.addStyles(zip2, model)]);
    await this.addMedia(zip2, model);
    await Promise.all([this.addApp(zip2, model), this.addCore(zip2, model)]);
    await this.addWorkbook(zip2, model);
    return this._finalize(zip2);
  }
  writeFile(filename, options) {
    const stream2 = fs$g.createWriteStream(filename);
    return new Promise((resolve2, reject2) => {
      stream2.on("finish", () => {
        resolve2();
      });
      stream2.on("error", (error2) => {
        reject2(error2);
      });
      this.write(stream2, options).then(() => {
        stream2.end();
      }).catch((err2) => {
        reject2(err2);
      });
    });
  }
  async writeBuffer(options) {
    const stream2 = new StreamBuf$2();
    await this.write(stream2, options);
    return stream2.read();
  }
};
XLSX$2.RelType = relType;
var xlsx = XLSX$2;
var src$2 = {};
var src$1 = {};
var FormatterOptions$1 = {};
Object.defineProperty(FormatterOptions$1, "__esModule", { value: true });
FormatterOptions$1.FormatterOptions = void 0;
class FormatterOptions {
  constructor(opts = {}) {
    var _a;
    this.objectMode = true;
    this.delimiter = ",";
    this.rowDelimiter = "\n";
    this.quote = '"';
    this.escape = this.quote;
    this.quoteColumns = false;
    this.quoteHeaders = this.quoteColumns;
    this.headers = null;
    this.includeEndRowDelimiter = false;
    this.writeBOM = false;
    this.BOM = "\uFEFF";
    this.alwaysWriteHeaders = false;
    Object.assign(this, opts || {});
    if (typeof (opts === null || opts === void 0 ? void 0 : opts.quoteHeaders) === "undefined") {
      this.quoteHeaders = this.quoteColumns;
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.quote) === true) {
      this.quote = '"';
    } else if ((opts === null || opts === void 0 ? void 0 : opts.quote) === false) {
      this.quote = "";
    }
    if (typeof (opts === null || opts === void 0 ? void 0 : opts.escape) !== "string") {
      this.escape = this.quote;
    }
    this.shouldWriteHeaders = !!this.headers && ((_a = opts.writeHeaders) !== null && _a !== void 0 ? _a : true);
    this.headers = Array.isArray(this.headers) ? this.headers : null;
    this.escapedQuote = `${this.escape}${this.quote}`;
  }
}
FormatterOptions$1.FormatterOptions = FormatterOptions;
var CsvFormatterStream$1 = {};
var formatter = {};
var RowFormatter$1 = {};
var asyncTag = "[object AsyncFunction]", funcTag$5 = "[object Function]", genTag$5 = "[object GeneratorFunction]", nullTag = "[object Null]", proxyTag = "[object Proxy]", undefinedTag = "[object Undefined]";
var freeGlobal$5 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$5 = typeof self == "object" && self && self.Object === Object && self;
var root$5 = freeGlobal$5 || freeSelf$5 || Function("return this")();
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
var nativeObjectToString = objectProto$8.toString;
var Symbol$5 = root$5.Symbol, symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$8(value);
}
function getRawTag(value) {
  var isOwn = hasOwnProperty$6.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function objectToString$8(value) {
  return nativeObjectToString.call(value);
}
function isFunction$5(value) {
  if (!isObject$5(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$5 || tag == genTag$5 || tag == asyncTag || tag == proxyTag;
}
function isObject$5(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var lodash_isfunction = isFunction$5;
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE2 = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag2 = "[object Arguments]", arrayTag = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value, index2, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush2(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index2 = -1, length = array == null ? 0 : array.length;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes2(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas2(cache, key) {
    return cache.has(key);
  }
  function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function mapToArray(map3) {
    var index2 = -1, result = Array(map3.size);
    map3.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function overArg2(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  function setToArray2(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString2 = objectProto2.toString;
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg2(Object.keys, Object);
  var DataView = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString = toSource2(DataView), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function SetCache2(values) {
    var index2 = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache2();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd2(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  function setCacheHas2(value) {
    return this.__data__.has(value);
  }
  SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
  SetCache2.prototype.has = setCacheHas2;
  function Stack(entries) {
    var data = this.__data__ = new ListCache2(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys2(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value.length, String) : [], length = result.length;
    for (var key in value) {
      if (hasOwnProperty2.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray2(object2) ? result : arrayPush2(result, symbolsFunc(object2));
  }
  function baseGetTag2(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag2 : nullTag2;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag2(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag2 ? objectTag2 : objTag;
    othTag = othTag == argsTag2 ? objectTag2 : othTag;
    var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object2)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag2(value)];
  }
  function baseKeys(object2) {
    if (!isPrototype2(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache2() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag2:
      case dateTag:
      case numberTag:
        return eq2(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray2);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object2);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys, getSymbols);
  }
  function getMapData2(map3, key) {
    var data = map3.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative2(object2, key) {
    var value = getValue2(object2, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag2(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
    try {
      value[symToStringTag2] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString2.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag2] = tag;
      } else {
        delete value[symToStringTag2];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol2) {
      return propertyIsEnumerable2.call(object2, symbol2);
    });
  };
  var getTag = baseGetTag2;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag2(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex2(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString2.call(value);
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments2 = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag2(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
  }
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object2) {
    return isArrayLike2(object2) ? arrayLikeKeys2(object2) : baseKeys(object2);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
var FieldFormatter$1 = {};
var boolTag = "[object Boolean]";
var objectProto$7 = Object.prototype;
var objectToString$7 = objectProto$7.toString;
function isBoolean(value) {
  return value === true || value === false || isObjectLike$6(value) && objectToString$7.call(value) == boolTag;
}
function isObjectLike$6(value) {
  return !!value && typeof value == "object";
}
var lodash_isboolean = isBoolean;
function isNil(value) {
  return value == null;
}
var lodash_isnil = isNil;
var symbolTag = "[object Symbol]";
var reRegExpChar$3 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar$3.source);
var freeGlobal$4 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$4 = typeof self == "object" && self && self.Object === Object && self;
var root$4 = freeGlobal$4 || freeSelf$4 || Function("return this")();
var objectProto$6 = Object.prototype;
var objectToString$6 = objectProto$6.toString;
var Symbol$4 = root$4.Symbol;
var symbolProto = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function isObjectLike$5(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike$5(value) && objectToString$6.call(value) == symbolTag;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function escapeRegExp(string) {
  string = toString(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar$3, "\\$&") : string;
}
var lodash_escaperegexp = escapeRegExp;
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(FieldFormatter$1, "__esModule", { value: true });
FieldFormatter$1.FieldFormatter = void 0;
const lodash_isboolean_1 = __importDefault$4(lodash_isboolean);
const lodash_isnil_1$1 = __importDefault$4(lodash_isnil);
const lodash_escaperegexp_1$1 = __importDefault$4(lodash_escaperegexp);
class FieldFormatter {
  constructor(formatterOptions) {
    this._headers = null;
    this.formatterOptions = formatterOptions;
    if (formatterOptions.headers !== null) {
      this.headers = formatterOptions.headers;
    }
    this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, "g");
    const escapePattern = `[${formatterOptions.delimiter}${lodash_escaperegexp_1$1.default(formatterOptions.rowDelimiter)}|\r|
]`;
    this.ESCAPE_REGEXP = new RegExp(escapePattern);
  }
  set headers(headers2) {
    this._headers = headers2;
  }
  shouldQuote(fieldIndex, isHeader) {
    const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
    if (lodash_isboolean_1.default(quoteConfig)) {
      return quoteConfig;
    }
    if (Array.isArray(quoteConfig)) {
      return quoteConfig[fieldIndex];
    }
    if (this._headers !== null) {
      return quoteConfig[this._headers[fieldIndex]];
    }
    return false;
  }
  format(field, fieldIndex, isHeader) {
    const preparedField = `${lodash_isnil_1$1.default(field) ? "" : field}`.replace(/\0/g, "");
    const { formatterOptions } = this;
    if (formatterOptions.quote !== "") {
      const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;
      if (shouldEscape) {
        return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));
      }
    }
    const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;
    if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {
      return this.quoteField(preparedField);
    }
    return preparedField;
  }
  quoteField(field) {
    const { quote } = this.formatterOptions;
    return `${quote}${field}${quote}`;
  }
}
FieldFormatter$1.FieldFormatter = FieldFormatter;
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.isSyncTransform = void 0;
types$1.isSyncTransform = (transform2) => transform2.length === 1;
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(RowFormatter$1, "__esModule", { value: true });
RowFormatter$1.RowFormatter = void 0;
const lodash_isfunction_1$2 = __importDefault$3(lodash_isfunction);
const lodash_isequal_1 = __importDefault$3(lodash_isequalExports);
const FieldFormatter_1 = FieldFormatter$1;
const types_1$1 = types$1;
class RowFormatter {
  constructor(formatterOptions) {
    this.rowCount = 0;
    this.formatterOptions = formatterOptions;
    this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);
    this.headers = formatterOptions.headers;
    this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;
    this.hasWrittenHeaders = false;
    if (this.headers !== null) {
      this.fieldFormatter.headers = this.headers;
    }
    if (formatterOptions.transform) {
      this.rowTransform = formatterOptions.transform;
    }
  }
  static isRowHashArray(row2) {
    if (Array.isArray(row2)) {
      return Array.isArray(row2[0]) && row2[0].length === 2;
    }
    return false;
  }
  static isRowArray(row2) {
    return Array.isArray(row2) && !this.isRowHashArray(row2);
  }
  // get headers from a row item
  static gatherHeaders(row2) {
    if (RowFormatter.isRowHashArray(row2)) {
      return row2.map((it) => it[0]);
    }
    if (Array.isArray(row2)) {
      return row2;
    }
    return Object.keys(row2);
  }
  // eslint-disable-next-line @typescript-eslint/no-shadow
  static createTransform(transformFunction) {
    if (types_1$1.isSyncTransform(transformFunction)) {
      return (row2, cb) => {
        let transformedRow = null;
        try {
          transformedRow = transformFunction(row2);
        } catch (e) {
          return cb(e);
        }
        return cb(null, transformedRow);
      };
    }
    return (row2, cb) => {
      transformFunction(row2, cb);
    };
  }
  set rowTransform(transformFunction) {
    if (!lodash_isfunction_1$2.default(transformFunction)) {
      throw new TypeError("The transform should be a function");
    }
    this._rowTransform = RowFormatter.createTransform(transformFunction);
  }
  format(row2, cb) {
    this.callTransformer(row2, (err2, transformedRow) => {
      if (err2) {
        return cb(err2);
      }
      if (!row2) {
        return cb(null);
      }
      const rows = [];
      if (transformedRow) {
        const { shouldFormatColumns, headers: headers2 } = this.checkHeaders(transformedRow);
        if (this.shouldWriteHeaders && headers2 && !this.hasWrittenHeaders) {
          rows.push(this.formatColumns(headers2, true));
          this.hasWrittenHeaders = true;
        }
        if (shouldFormatColumns) {
          const columns = this.gatherColumns(transformedRow);
          rows.push(this.formatColumns(columns, false));
        }
      }
      return cb(null, rows);
    });
  }
  finish(cb) {
    const rows = [];
    if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
      if (!this.headers) {
        return cb(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
      }
      rows.push(this.formatColumns(this.headers, true));
    }
    if (this.formatterOptions.includeEndRowDelimiter) {
      rows.push(this.formatterOptions.rowDelimiter);
    }
    return cb(null, rows);
  }
  // check if we need to write header return true if we should also write a row
  // could be false if headers is true and the header row(first item) is passed in
  checkHeaders(row2) {
    if (this.headers) {
      return { shouldFormatColumns: true, headers: this.headers };
    }
    const headers2 = RowFormatter.gatherHeaders(row2);
    this.headers = headers2;
    this.fieldFormatter.headers = headers2;
    if (!this.shouldWriteHeaders) {
      return { shouldFormatColumns: true, headers: null };
    }
    return { shouldFormatColumns: !lodash_isequal_1.default(headers2, row2), headers: headers2 };
  }
  // todo change this method to unknown[]
  gatherColumns(row2) {
    if (this.headers === null) {
      throw new Error("Headers is currently null");
    }
    if (!Array.isArray(row2)) {
      return this.headers.map((header) => row2[header]);
    }
    if (RowFormatter.isRowHashArray(row2)) {
      return this.headers.map((header, i) => {
        const col = row2[i];
        if (col) {
          return col[1];
        }
        return "";
      });
    }
    if (RowFormatter.isRowArray(row2) && !this.shouldWriteHeaders) {
      return row2;
    }
    return this.headers.map((header, i) => row2[i]);
  }
  callTransformer(row2, cb) {
    if (!this._rowTransform) {
      return cb(null, row2);
    }
    return this._rowTransform(row2, cb);
  }
  formatColumns(columns, isHeadersRow) {
    const formattedCols = columns.map((field, i) => this.fieldFormatter.format(field, i, isHeadersRow)).join(this.formatterOptions.delimiter);
    const { rowCount } = this;
    this.rowCount += 1;
    if (rowCount) {
      return [this.formatterOptions.rowDelimiter, formattedCols].join("");
    }
    return formattedCols;
  }
}
RowFormatter$1.RowFormatter = RowFormatter;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FieldFormatter = exports.RowFormatter = void 0;
  var RowFormatter_1 = RowFormatter$1;
  Object.defineProperty(exports, "RowFormatter", { enumerable: true, get: function() {
    return RowFormatter_1.RowFormatter;
  } });
  var FieldFormatter_12 = FieldFormatter$1;
  Object.defineProperty(exports, "FieldFormatter", { enumerable: true, get: function() {
    return FieldFormatter_12.FieldFormatter;
  } });
})(formatter);
Object.defineProperty(CsvFormatterStream$1, "__esModule", { value: true });
CsvFormatterStream$1.CsvFormatterStream = void 0;
const stream_1$1 = require$$0$1;
const formatter_1 = formatter;
class CsvFormatterStream extends stream_1$1.Transform {
  constructor(formatterOptions) {
    super({ writableObjectMode: formatterOptions.objectMode });
    this.hasWrittenBOM = false;
    this.formatterOptions = formatterOptions;
    this.rowFormatter = new formatter_1.RowFormatter(formatterOptions);
    this.hasWrittenBOM = !formatterOptions.writeBOM;
  }
  transform(transformFunction) {
    this.rowFormatter.rowTransform = transformFunction;
    return this;
  }
  _transform(row2, encoding, cb) {
    let cbCalled = false;
    try {
      if (!this.hasWrittenBOM) {
        this.push(this.formatterOptions.BOM);
        this.hasWrittenBOM = true;
      }
      this.rowFormatter.format(row2, (err2, rows) => {
        if (err2) {
          cbCalled = true;
          return cb(err2);
        }
        if (rows) {
          rows.forEach((r) => {
            this.push(Buffer.from(r, "utf8"));
          });
        }
        cbCalled = true;
        return cb();
      });
    } catch (e) {
      if (cbCalled) {
        throw e;
      }
      cb(e);
    }
  }
  _flush(cb) {
    this.rowFormatter.finish((err2, rows) => {
      if (err2) {
        return cb(err2);
      }
      if (rows) {
        rows.forEach((r) => {
          this.push(Buffer.from(r, "utf8"));
        });
      }
      return cb();
    });
  }
}
CsvFormatterStream$1.CsvFormatterStream = CsvFormatterStream;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = exports.FormatterOptions = exports.CsvFormatterStream = void 0;
  const util_1 = require$$0$4;
  const stream_12 = require$$0$1;
  const fs2 = __importStar(require$$0$2);
  const FormatterOptions_1 = FormatterOptions$1;
  const CsvFormatterStream_1 = CsvFormatterStream$1;
  __exportStar(types$1, exports);
  var CsvFormatterStream_2 = CsvFormatterStream$1;
  Object.defineProperty(exports, "CsvFormatterStream", { enumerable: true, get: function() {
    return CsvFormatterStream_2.CsvFormatterStream;
  } });
  var FormatterOptions_2 = FormatterOptions$1;
  Object.defineProperty(exports, "FormatterOptions", { enumerable: true, get: function() {
    return FormatterOptions_2.FormatterOptions;
  } });
  exports.format = (options) => new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));
  exports.write = (rows, options) => {
    const csvStream = exports.format(options);
    const promiseWrite = util_1.promisify((row2, cb) => {
      csvStream.write(row2, void 0, cb);
    });
    rows.reduce((prev, row2) => prev.then(() => promiseWrite(row2)), Promise.resolve()).then(() => csvStream.end()).catch((err2) => {
      csvStream.emit("error", err2);
    });
    return csvStream;
  };
  exports.writeToStream = (ws, rows, options) => exports.write(rows, options).pipe(ws);
  exports.writeToBuffer = (rows, opts = {}) => {
    const buffers2 = [];
    const ws = new stream_12.Writable({
      write(data, enc, writeCb) {
        buffers2.push(data);
        writeCb();
      }
    });
    return new Promise((res, rej) => {
      ws.on("error", rej).on("finish", () => res(Buffer.concat(buffers2)));
      exports.write(rows, opts).pipe(ws);
    });
  };
  exports.writeToString = (rows, options) => exports.writeToBuffer(rows, options).then((buffer) => buffer.toString());
  exports.writeToPath = (path2, rows, options) => {
    const stream2 = fs2.createWriteStream(path2, { encoding: "utf8" });
    return exports.write(rows, options).pipe(stream2);
  };
})(src$1);
var src = {};
var ParserOptions$1 = {};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ParserOptions$1, "__esModule", { value: true });
ParserOptions$1.ParserOptions = void 0;
const lodash_escaperegexp_1 = __importDefault$2(lodash_escaperegexp);
const lodash_isnil_1 = __importDefault$2(lodash_isnil);
class ParserOptions {
  constructor(opts) {
    var _a;
    this.objectMode = true;
    this.delimiter = ",";
    this.ignoreEmpty = false;
    this.quote = '"';
    this.escape = null;
    this.escapeChar = this.quote;
    this.comment = null;
    this.supportsComments = false;
    this.ltrim = false;
    this.rtrim = false;
    this.trim = false;
    this.headers = null;
    this.renameHeaders = false;
    this.strictColumnHandling = false;
    this.discardUnmappedColumns = false;
    this.carriageReturn = "\r";
    this.encoding = "utf8";
    this.limitRows = false;
    this.maxRows = 0;
    this.skipLines = 0;
    this.skipRows = 0;
    Object.assign(this, opts || {});
    if (this.delimiter.length > 1) {
      throw new Error("delimiter option must be one character long");
    }
    this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);
    this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;
    this.supportsComments = !lodash_isnil_1.default(this.comment);
    this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\s]|\\r\\n|\\n|\\r|${this.escapedDelimiter})`);
    if (this.maxRows > 0) {
      this.limitRows = true;
    }
  }
}
ParserOptions$1.ParserOptions = ParserOptions;
var CsvParserStream$1 = {};
var transforms = {};
var RowTransformerValidator$1 = {};
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
types.isSyncValidate = types.isSyncTransform = void 0;
types.isSyncTransform = (transform2) => transform2.length === 1;
types.isSyncValidate = (validate2) => validate2.length === 1;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(RowTransformerValidator$1, "__esModule", { value: true });
RowTransformerValidator$1.RowTransformerValidator = void 0;
const lodash_isfunction_1$1 = __importDefault$1(lodash_isfunction);
const types_1 = types;
class RowTransformerValidator {
  constructor() {
    this._rowTransform = null;
    this._rowValidator = null;
  }
  // eslint-disable-next-line @typescript-eslint/no-shadow
  static createTransform(transformFunction) {
    if (types_1.isSyncTransform(transformFunction)) {
      return (row2, cb) => {
        let transformed = null;
        try {
          transformed = transformFunction(row2);
        } catch (e) {
          return cb(e);
        }
        return cb(null, transformed);
      };
    }
    return transformFunction;
  }
  static createValidator(validateFunction) {
    if (types_1.isSyncValidate(validateFunction)) {
      return (row2, cb) => {
        cb(null, { row: row2, isValid: validateFunction(row2) });
      };
    }
    return (row2, cb) => {
      validateFunction(row2, (err2, isValid, reason) => {
        if (err2) {
          return cb(err2);
        }
        if (isValid) {
          return cb(null, { row: row2, isValid, reason });
        }
        return cb(null, { row: row2, isValid: false, reason });
      });
    };
  }
  set rowTransform(transformFunction) {
    if (!lodash_isfunction_1$1.default(transformFunction)) {
      throw new TypeError("The transform should be a function");
    }
    this._rowTransform = RowTransformerValidator.createTransform(transformFunction);
  }
  set rowValidator(validateFunction) {
    if (!lodash_isfunction_1$1.default(validateFunction)) {
      throw new TypeError("The validate should be a function");
    }
    this._rowValidator = RowTransformerValidator.createValidator(validateFunction);
  }
  transformAndValidate(row2, cb) {
    return this.callTransformer(row2, (transformErr, transformedRow) => {
      if (transformErr) {
        return cb(transformErr);
      }
      if (!transformedRow) {
        return cb(null, { row: null, isValid: true });
      }
      return this.callValidator(transformedRow, (validateErr, validationResult) => {
        if (validateErr) {
          return cb(validateErr);
        }
        if (validationResult && !validationResult.isValid) {
          return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });
        }
        return cb(null, { row: transformedRow, isValid: true });
      });
    });
  }
  callTransformer(row2, cb) {
    if (!this._rowTransform) {
      return cb(null, row2);
    }
    return this._rowTransform(row2, cb);
  }
  callValidator(row2, cb) {
    if (!this._rowValidator) {
      return cb(null, { row: row2, isValid: true });
    }
    return this._rowValidator(row2, cb);
  }
}
RowTransformerValidator$1.RowTransformerValidator = RowTransformerValidator;
var HeaderTransformer$1 = {};
function isUndefined(value) {
  return value === void 0;
}
var lodash_isundefined = isUndefined;
var LARGE_ARRAY_SIZE$2 = 200;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var INFINITY$1 = 1 / 0;
var funcTag$4 = "[object Function]", genTag$4 = "[object GeneratorFunction]";
var reRegExpChar$2 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;
var freeGlobal$3 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$3 = typeof self == "object" && self && self.Object === Object && self;
var root$3 = freeGlobal$3 || freeSelf$3 || Function("return this")();
function arrayIncludes$2(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf$2(array, value, 0) > -1;
}
function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + -1;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf$2(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex$2(array, baseIsNaN$2, fromIndex);
  }
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN$2(value) {
  return value !== value;
}
function cacheHas$2(cache, key) {
  return cache.has(key);
}
function getValue$2(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function isHostObject$3(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var arrayProto$2 = Array.prototype, funcProto$3 = Function.prototype, objectProto$5 = Object.prototype;
var coreJsData$2 = root$3["__core-js_shared__"];
var maskSrcKey$2 = function() {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString$3 = funcProto$3.toString;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
var objectToString$5 = objectProto$5.toString;
var reIsNative$2 = RegExp(
  "^" + funcToString$3.call(hasOwnProperty$5).replace(reRegExpChar$2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var splice$2 = arrayProto$2.splice;
var Map$3 = getNative$2(root$3, "Map"), Set$2 = getNative$2(root$3, "Set"), nativeCreate$2 = getNative$2(Object, "create");
function Hash$2(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear$2() {
  this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
}
function hashDelete$2(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
}
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$2 ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
function hashSet$2(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$2 : value;
  return this;
}
Hash$2.prototype.clear = hashClear$2;
Hash$2.prototype["delete"] = hashDelete$2;
Hash$2.prototype.get = hashGet$2;
Hash$2.prototype.has = hashHas$2;
Hash$2.prototype.set = hashSet$2;
function ListCache$2(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear$2() {
  this.__data__ = [];
}
function listCacheDelete$2(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$2.call(data, index2, 1);
  }
  return true;
}
function listCacheGet$2(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}
function listCacheSet$2(key, value) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache$2.prototype.clear = listCacheClear$2;
ListCache$2.prototype["delete"] = listCacheDelete$2;
ListCache$2.prototype.get = listCacheGet$2;
ListCache$2.prototype.has = listCacheHas$2;
ListCache$2.prototype.set = listCacheSet$2;
function MapCache$2(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear$2() {
  this.__data__ = {
    "hash": new Hash$2(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash$2()
  };
}
function mapCacheDelete$2(key) {
  return getMapData$2(this, key)["delete"](key);
}
function mapCacheGet$2(key) {
  return getMapData$2(this, key).get(key);
}
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}
function mapCacheSet$2(key, value) {
  getMapData$2(this, key).set(key, value);
  return this;
}
MapCache$2.prototype.clear = mapCacheClear$2;
MapCache$2.prototype["delete"] = mapCacheDelete$2;
MapCache$2.prototype.get = mapCacheGet$2;
MapCache$2.prototype.has = mapCacheHas$2;
MapCache$2.prototype.set = mapCacheSet$2;
function SetCache$2(values) {
  var index2 = -1, length = values ? values.length : 0;
  this.__data__ = new MapCache$2();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
function setCacheAdd$2(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}
function setCacheHas$2(value) {
  return this.__data__.has(value);
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$2;
SetCache$2.prototype.has = setCacheHas$2;
function assocIndexOf$2(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseIsNative$2(value) {
  if (!isObject$4(value) || isMasked$2(value)) {
    return false;
  }
  var pattern = isFunction$4(value) || isHostObject$3(value) ? reIsNative$2 : reIsHostCtor$2;
  return pattern.test(toSource$2(value));
}
function baseUniq$1(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes$2, length = array.length, isCommon = true, result = [], seen = result;
  if (length >= LARGE_ARRAY_SIZE$2) {
    var set2 = createSet$1(array);
    if (set2) {
      return setToArray$1(set2);
    }
    isCommon = false;
    includes = cacheHas$2;
    seen = new SetCache$2();
  } else {
    seen = result;
  }
  outer:
    while (++index2 < length) {
      var value = array[index2], computed = value;
      value = value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var createSet$1 = !(Set$2 && 1 / setToArray$1(new Set$2([, -0]))[1] == INFINITY$1) ? noop$5 : function(values) {
  return new Set$2(values);
};
function getMapData$2(map3, key) {
  var data = map3.__data__;
  return isKeyable$2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative$2(object2, key) {
  var value = getValue$2(object2, key);
  return baseIsNative$2(value) ? value : void 0;
}
function isKeyable$2(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked$2(func) {
  return !!maskSrcKey$2 && maskSrcKey$2 in func;
}
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$3.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
function uniq(array) {
  return array && array.length ? baseUniq$1(array) : [];
}
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
function isFunction$4(value) {
  var tag = isObject$4(value) ? objectToString$5.call(value) : "";
  return tag == funcTag$4 || tag == genTag$4;
}
function isObject$4(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function noop$5() {
}
var lodash_uniq = uniq;
var lodash_groupby = { exports: {} };
lodash_groupby.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE2 = 200;
  var FUNC_ERROR_TEXT = "Expected a function";
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag2 = "[object Arguments]", arrayTag = "[object Array]", boolTag2 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag2 = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index2 = -1, length = array ? array.length : 0;
    while (++index2 < length) {
      var value = array[index2];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }
  function arraySome(array, predicate) {
    var index2 = -1, length = array ? array.length : 0;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  function baseProperty(key) {
    return function(object2) {
      return object2 == null ? void 0 : object2[key];
    };
  }
  function baseTimes2(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function isHostObject2(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function mapToArray(map3) {
    var index2 = -1, result = Array(map3.size);
    map3.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function overArg2(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  function setToArray2(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectToString2 = objectProto2.toString;
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice;
  var nativeKeys = overArg2(Object.keys, Object);
  var DataView = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString = toSource2(DataView), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0, symbolToString2 = symbolProto2 ? symbolProto2.toString : void 0;
  function Hash2(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
  }
  function hashDelete2(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet2(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
  }
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    return true;
  }
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    return getMapData2(this, key)["delete"](key);
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    getMapData2(this, key).set(key, value);
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function SetCache2(values) {
    var index2 = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache2();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd2(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  function setCacheHas2(value) {
    return this.__data__.has(value);
  }
  SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
  SetCache2.prototype.has = setCacheHas2;
  function Stack(entries) {
    this.__data__ = new ListCache2(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache2();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache2) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache2(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys2(value, inherited) {
    var result = isArray2(value) || isArguments2(value) ? baseTimes2(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if (hasOwnProperty2.call(value, key) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach(collection, function(value, key, collection2) {
      setter(accumulator, value, iteratee(value), collection2);
    });
    return accumulator;
  }
  var baseEach = createBaseEach(baseForOwn);
  var baseFor = createBaseFor();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor(object2, iteratee, keys);
  }
  function baseGet(object2, path2) {
    path2 = isKey(path2, object2) ? [path2] : castPath(path2);
    var index2 = 0, length = path2.length;
    while (object2 != null && index2 < length) {
      object2 = object2[toKey(path2[index2++])];
    }
    return index2 && index2 == length ? object2 : void 0;
  }
  function baseGetTag2(value) {
    return objectToString2.call(value);
  }
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
  }
  function baseIsEqualDeep(object2, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
      objTag = getTag(object2);
      objTag = objTag == argsTag2 ? objectTag2 : objTag;
    }
    if (!othIsArr) {
      othTag = getTag(other);
      othTag = othTag == argsTag2 ? objectTag2 : othTag;
    }
    var objIsObj = objTag == objectTag2 && !isHostObject2(object2), othIsObj = othTag == objectTag2 && !isHostObject2(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, equalFunc, customizer, bitmask, stack) : equalByTag(object2, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object2, other, equalFunc, customizer, bitmask, stack);
  }
  function baseIsMatch(object2, source, matchData, customizer) {
    var index2 = matchData.length, length = index2;
    if (object2 == null) {
      return !length;
    }
    object2 = Object(object2);
    while (index2--) {
      var data = matchData[index2];
      if (data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
        return false;
      }
    }
    while (++index2 < length) {
      data = matchData[index2];
      var key = data[0], objValue = object2[key], srcValue = data[1];
      if (data[2]) {
        if (objValue === void 0 && !(key in object2)) {
          return false;
        }
      } else {
        var stack = new Stack();
        var result;
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[objectToString2.call(value)];
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  function baseKeys(object2) {
    if (!isPrototype2(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object2) {
      return object2 === source || baseIsMatch(object2, source, matchData);
    };
  }
  function baseMatchesProperty(path2, srcValue) {
    if (isKey(path2) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path2), srcValue);
    }
    return function(object2) {
      var objValue = get3(object2, path2);
      return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
  }
  function basePropertyDeep(path2) {
    return function(object2) {
      return baseGet(object2, path2);
    };
  }
  function baseToString2(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol2(value)) {
      return symbolToString2 ? symbolToString2.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function castPath(value) {
    return isArray2(value) ? value : stringToPath(value);
  }
  function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
      var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = {};
      return func(collection, setter, baseIteratee(iteratee), accumulator);
    };
  }
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike2(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index2 = -1, iterable = Object(collection);
      while (++index2 < length) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props2 = keysFunc(object2), length = props2.length;
      while (length--) {
        var key = props2[++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index2 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache2() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
            return seen.add(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object2, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag2:
      case dateTag:
      case numberTag:
        return eq2(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray2);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), equalFunc, customizer, bitmask, stack);
        stack["delete"](object2);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object2, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object2), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  function getMapData2(map3, key) {
    var data = map3.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getMatchData(object2) {
    var result = keys(object2), length = result.length;
    while (length--) {
      var key = result[length], value = object2[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  function getNative2(object2, key) {
    var value = getValue2(object2, key);
    return baseIsNative2(value) ? value : void 0;
  }
  var getTag = baseGetTag2;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString2.call(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function hasPath(object2, path2, hasFunc) {
    path2 = isKey(path2, object2) ? [path2] : castPath(path2);
    var result, index2 = -1, length = path2.length;
    while (++index2 < length) {
      var key = toKey(path2[index2]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result) {
      return result;
    }
    var length = object2 ? object2.length : 0;
    return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object2) || isArguments2(object2));
  }
  function isIndex2(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKey(value, object2) {
    if (isArray2(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  function isKeyable2(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function isStrictComparable(value) {
    return value === value && !isObject2(value);
  }
  function matchesStrictComparable(key, srcValue) {
    return function(object2) {
      if (object2 == null) {
        return false;
      }
      return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
    };
  }
  var stringToPath = memoize2(function(string) {
    string = toString3(string);
    var result = [];
    if (reLeadingDot.test(string)) {
      result.push("");
    }
    string.replace(rePropName, function(match2, number, quote, string2) {
      result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match2);
    });
    return result;
  });
  function toKey(value) {
    if (typeof value == "string" || isSymbol2(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var groupBy2 = createAggregator(function(result, value, key) {
    if (hasOwnProperty2.call(result, key)) {
      result[key].push(value);
    } else {
      result[key] = [value];
    }
  });
  function memoize2(func, resolver) {
    if (typeof func != "function" || resolver && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };
    memoized.cache = new (memoize2.Cache || MapCache2)();
    return memoized;
  }
  memoize2.Cache = MapCache2;
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments2(value) {
    return isArrayLikeObject2(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable2.call(value, "callee") || objectToString2.call(value) == argsTag2);
  }
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject2(value) {
    return isObjectLike2(value) && isArrayLike2(value);
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString2.call(value) : "";
    return tag == funcTag2 || tag == genTag2;
  }
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike2(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol2(value) {
    return typeof value == "symbol" || isObjectLike2(value) && objectToString2.call(value) == symbolTag2;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toString3(value) {
    return value == null ? "" : baseToString2(value);
  }
  function get3(object2, path2, defaultValue) {
    var result = object2 == null ? void 0 : baseGet(object2, path2);
    return result === void 0 ? defaultValue : result;
  }
  function hasIn(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHasIn);
  }
  function keys(object2) {
    return isArrayLike2(object2) ? arrayLikeKeys2(object2) : baseKeys(object2);
  }
  function identity(value) {
    return value;
  }
  function property(path2) {
    return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
  }
  module.exports = groupBy2;
})(lodash_groupby, lodash_groupby.exports);
var lodash_groupbyExports = lodash_groupby.exports;
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(HeaderTransformer$1, "__esModule", { value: true });
HeaderTransformer$1.HeaderTransformer = void 0;
const lodash_isundefined_1 = __importDefault(lodash_isundefined);
const lodash_isfunction_1 = __importDefault(lodash_isfunction);
const lodash_uniq_1 = __importDefault(lodash_uniq);
const lodash_groupby_1 = __importDefault(lodash_groupbyExports);
class HeaderTransformer {
  constructor(parserOptions) {
    this.headers = null;
    this.receivedHeaders = false;
    this.shouldUseFirstRow = false;
    this.processedFirstRow = false;
    this.headersLength = 0;
    this.parserOptions = parserOptions;
    if (parserOptions.headers === true) {
      this.shouldUseFirstRow = true;
    } else if (Array.isArray(parserOptions.headers)) {
      this.setHeaders(parserOptions.headers);
    } else if (lodash_isfunction_1.default(parserOptions.headers)) {
      this.headersTransform = parserOptions.headers;
    }
  }
  transform(row2, cb) {
    if (!this.shouldMapRow(row2)) {
      return cb(null, { row: null, isValid: true });
    }
    return cb(null, this.processRow(row2));
  }
  shouldMapRow(row2) {
    const { parserOptions } = this;
    if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {
      if (!this.receivedHeaders) {
        throw new Error("Error renaming headers: new headers must be provided in an array");
      }
      this.processedFirstRow = true;
      return false;
    }
    if (!this.receivedHeaders && Array.isArray(row2)) {
      if (this.headersTransform) {
        this.setHeaders(this.headersTransform(row2));
      } else if (this.shouldUseFirstRow) {
        this.setHeaders(row2);
      } else {
        return true;
      }
      return false;
    }
    return true;
  }
  processRow(row2) {
    if (!this.headers) {
      return { row: row2, isValid: true };
    }
    const { parserOptions } = this;
    if (!parserOptions.discardUnmappedColumns && row2.length > this.headersLength) {
      if (!parserOptions.strictColumnHandling) {
        throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row2.length}`);
      }
      return {
        row: row2,
        isValid: false,
        reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row2.length}`
      };
    }
    if (parserOptions.strictColumnHandling && row2.length < this.headersLength) {
      return {
        row: row2,
        isValid: false,
        reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row2.length}`
      };
    }
    return { row: this.mapHeaders(row2), isValid: true };
  }
  mapHeaders(row2) {
    const rowMap = {};
    const { headers: headers2, headersLength } = this;
    for (let i = 0; i < headersLength; i += 1) {
      const header = headers2[i];
      if (!lodash_isundefined_1.default(header)) {
        const val = row2[i];
        if (lodash_isundefined_1.default(val)) {
          rowMap[header] = "";
        } else {
          rowMap[header] = val;
        }
      }
    }
    return rowMap;
  }
  setHeaders(headers2) {
    var _a;
    const filteredHeaders = headers2.filter((h) => !!h);
    if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {
      const grouped = lodash_groupby_1.default(filteredHeaders);
      const duplicates = Object.keys(grouped).filter((dup) => grouped[dup].length > 1);
      throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);
    }
    this.headers = headers2;
    this.receivedHeaders = true;
    this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;
  }
}
HeaderTransformer$1.HeaderTransformer = HeaderTransformer;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HeaderTransformer = exports.RowTransformerValidator = void 0;
  var RowTransformerValidator_1 = RowTransformerValidator$1;
  Object.defineProperty(exports, "RowTransformerValidator", { enumerable: true, get: function() {
    return RowTransformerValidator_1.RowTransformerValidator;
  } });
  var HeaderTransformer_1 = HeaderTransformer$1;
  Object.defineProperty(exports, "HeaderTransformer", { enumerable: true, get: function() {
    return HeaderTransformer_1.HeaderTransformer;
  } });
})(transforms);
var parser = {};
var Parser$1 = {};
var Scanner$1 = {};
var Token$1 = {};
Object.defineProperty(Token$1, "__esModule", { value: true });
Token$1.Token = void 0;
class Token {
  constructor(tokenArgs) {
    this.token = tokenArgs.token;
    this.startCursor = tokenArgs.startCursor;
    this.endCursor = tokenArgs.endCursor;
  }
  static isTokenRowDelimiter(token) {
    const content = token.token;
    return content === "\r" || content === "\n" || content === "\r\n";
  }
  static isTokenCarriageReturn(token, parserOptions) {
    return token.token === parserOptions.carriageReturn;
  }
  static isTokenComment(token, parserOptions) {
    return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;
  }
  static isTokenEscapeCharacter(token, parserOptions) {
    return token.token === parserOptions.escapeChar;
  }
  static isTokenQuote(token, parserOptions) {
    return token.token === parserOptions.quote;
  }
  static isTokenDelimiter(token, parserOptions) {
    return token.token === parserOptions.delimiter;
  }
}
Token$1.Token = Token;
Object.defineProperty(Scanner$1, "__esModule", { value: true });
Scanner$1.Scanner = void 0;
const Token_1$5 = Token$1;
const ROW_DELIMITER = /((?:\r\n)|\n|\r)/;
class Scanner {
  constructor(args) {
    this.cursor = 0;
    this.line = args.line;
    this.lineLength = this.line.length;
    this.parserOptions = args.parserOptions;
    this.hasMoreData = args.hasMoreData;
    this.cursor = args.cursor || 0;
  }
  get hasMoreCharacters() {
    return this.lineLength > this.cursor;
  }
  get nextNonSpaceToken() {
    const { lineFromCursor } = this;
    const regex = this.parserOptions.NEXT_TOKEN_REGEXP;
    if (lineFromCursor.search(regex) === -1) {
      return null;
    }
    const match2 = regex.exec(lineFromCursor);
    if (match2 == null) {
      return null;
    }
    const token = match2[1];
    const startCursor = this.cursor + (match2.index || 0);
    return new Token_1$5.Token({
      token,
      startCursor,
      endCursor: startCursor + token.length - 1
    });
  }
  get nextCharacterToken() {
    const { cursor, lineLength } = this;
    if (lineLength <= cursor) {
      return null;
    }
    return new Token_1$5.Token({
      token: this.line[cursor],
      startCursor: cursor,
      endCursor: cursor
    });
  }
  get lineFromCursor() {
    return this.line.substr(this.cursor);
  }
  advancePastLine() {
    const match2 = ROW_DELIMITER.exec(this.lineFromCursor);
    if (!match2) {
      if (this.hasMoreData) {
        return null;
      }
      this.cursor = this.lineLength;
      return this;
    }
    this.cursor += (match2.index || 0) + match2[0].length;
    return this;
  }
  advanceTo(cursor) {
    this.cursor = cursor;
    return this;
  }
  advanceToToken(token) {
    this.cursor = token.startCursor;
    return this;
  }
  advancePastToken(token) {
    this.cursor = token.endCursor + 1;
    return this;
  }
  truncateToCursor() {
    this.line = this.lineFromCursor;
    this.lineLength = this.line.length;
    this.cursor = 0;
    return this;
  }
}
Scanner$1.Scanner = Scanner;
var RowParser$1 = {};
var column = {};
var ColumnParser$1 = {};
var NonQuotedColumnParser$1 = {};
var ColumnFormatter$1 = {};
Object.defineProperty(ColumnFormatter$1, "__esModule", { value: true });
ColumnFormatter$1.ColumnFormatter = void 0;
class ColumnFormatter {
  constructor(parserOptions) {
    if (parserOptions.trim) {
      this.format = (col) => col.trim();
    } else if (parserOptions.ltrim) {
      this.format = (col) => col.trimLeft();
    } else if (parserOptions.rtrim) {
      this.format = (col) => col.trimRight();
    } else {
      this.format = (col) => col;
    }
  }
}
ColumnFormatter$1.ColumnFormatter = ColumnFormatter;
Object.defineProperty(NonQuotedColumnParser$1, "__esModule", { value: true });
NonQuotedColumnParser$1.NonQuotedColumnParser = void 0;
const ColumnFormatter_1$1 = ColumnFormatter$1;
const Token_1$4 = Token$1;
class NonQuotedColumnParser {
  constructor(parserOptions) {
    this.parserOptions = parserOptions;
    this.columnFormatter = new ColumnFormatter_1$1.ColumnFormatter(parserOptions);
  }
  parse(scanner) {
    if (!scanner.hasMoreCharacters) {
      return null;
    }
    const { parserOptions } = this;
    const characters = [];
    let nextToken = scanner.nextCharacterToken;
    for (; nextToken; nextToken = scanner.nextCharacterToken) {
      if (Token_1$4.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1$4.Token.isTokenRowDelimiter(nextToken)) {
        break;
      }
      characters.push(nextToken.token);
      scanner.advancePastToken(nextToken);
    }
    return this.columnFormatter.format(characters.join(""));
  }
}
NonQuotedColumnParser$1.NonQuotedColumnParser = NonQuotedColumnParser;
var QuotedColumnParser$1 = {};
Object.defineProperty(QuotedColumnParser$1, "__esModule", { value: true });
QuotedColumnParser$1.QuotedColumnParser = void 0;
const ColumnFormatter_1 = ColumnFormatter$1;
const Token_1$3 = Token$1;
class QuotedColumnParser {
  constructor(parserOptions) {
    this.parserOptions = parserOptions;
    this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
  }
  parse(scanner) {
    if (!scanner.hasMoreCharacters) {
      return null;
    }
    const originalCursor = scanner.cursor;
    const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);
    if (!foundClosingQuote) {
      scanner.advanceTo(originalCursor);
      if (!scanner.hasMoreData) {
        throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ""}' in line: at '${scanner.lineFromCursor.replace(/[\r\n]/g, "\\n'")}'`);
      }
      return null;
    }
    this.checkForMalformedColumn(scanner);
    return col;
  }
  gatherDataBetweenQuotes(scanner) {
    const { parserOptions } = this;
    let foundStartingQuote = false;
    let foundClosingQuote = false;
    const characters = [];
    let nextToken = scanner.nextCharacterToken;
    for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {
      const isQuote2 = Token_1$3.Token.isTokenQuote(nextToken, parserOptions);
      if (!foundStartingQuote && isQuote2) {
        foundStartingQuote = true;
      } else if (foundStartingQuote) {
        if (Token_1$3.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {
          scanner.advancePastToken(nextToken);
          const tokenFollowingEscape = scanner.nextCharacterToken;
          if (tokenFollowingEscape !== null && (Token_1$3.Token.isTokenQuote(tokenFollowingEscape, parserOptions) || Token_1$3.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {
            characters.push(tokenFollowingEscape.token);
            nextToken = tokenFollowingEscape;
          } else if (isQuote2) {
            foundClosingQuote = true;
          } else {
            characters.push(nextToken.token);
          }
        } else if (isQuote2) {
          foundClosingQuote = true;
        } else {
          characters.push(nextToken.token);
        }
      }
      scanner.advancePastToken(nextToken);
    }
    return { col: this.columnFormatter.format(characters.join("")), foundClosingQuote };
  }
  checkForMalformedColumn(scanner) {
    const { parserOptions } = this;
    const { nextNonSpaceToken } = scanner;
    if (nextNonSpaceToken) {
      const isNextTokenADelimiter = Token_1$3.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);
      const isNextTokenARowDelimiter = Token_1$3.Token.isTokenRowDelimiter(nextNonSpaceToken);
      if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {
        const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
        throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);
      }
      scanner.advanceToToken(nextNonSpaceToken);
    } else if (!scanner.hasMoreData) {
      scanner.advancePastLine();
    }
  }
}
QuotedColumnParser$1.QuotedColumnParser = QuotedColumnParser;
Object.defineProperty(ColumnParser$1, "__esModule", { value: true });
ColumnParser$1.ColumnParser = void 0;
const NonQuotedColumnParser_1 = NonQuotedColumnParser$1;
const QuotedColumnParser_1 = QuotedColumnParser$1;
const Token_1$2 = Token$1;
class ColumnParser {
  constructor(parserOptions) {
    this.parserOptions = parserOptions;
    this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);
    this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);
  }
  parse(scanner) {
    const { nextNonSpaceToken } = scanner;
    if (nextNonSpaceToken !== null && Token_1$2.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {
      scanner.advanceToToken(nextNonSpaceToken);
      return this.quotedColumnParser.parse(scanner);
    }
    return this.nonQuotedColumnParser.parse(scanner);
  }
}
ColumnParser$1.ColumnParser = ColumnParser;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ColumnFormatter = exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = void 0;
  var ColumnParser_1 = ColumnParser$1;
  Object.defineProperty(exports, "ColumnParser", { enumerable: true, get: function() {
    return ColumnParser_1.ColumnParser;
  } });
  var NonQuotedColumnParser_12 = NonQuotedColumnParser$1;
  Object.defineProperty(exports, "NonQuotedColumnParser", { enumerable: true, get: function() {
    return NonQuotedColumnParser_12.NonQuotedColumnParser;
  } });
  var QuotedColumnParser_12 = QuotedColumnParser$1;
  Object.defineProperty(exports, "QuotedColumnParser", { enumerable: true, get: function() {
    return QuotedColumnParser_12.QuotedColumnParser;
  } });
  var ColumnFormatter_12 = ColumnFormatter$1;
  Object.defineProperty(exports, "ColumnFormatter", { enumerable: true, get: function() {
    return ColumnFormatter_12.ColumnFormatter;
  } });
})(column);
Object.defineProperty(RowParser$1, "__esModule", { value: true });
RowParser$1.RowParser = void 0;
const column_1 = column;
const Token_1$1 = Token$1;
const EMPTY_STRING = "";
class RowParser {
  constructor(parserOptions) {
    this.parserOptions = parserOptions;
    this.columnParser = new column_1.ColumnParser(parserOptions);
  }
  static isEmptyRow(row2) {
    return row2.join(EMPTY_STRING).replace(/\s+/g, EMPTY_STRING) === EMPTY_STRING;
  }
  parse(scanner) {
    const { parserOptions } = this;
    const { hasMoreData } = scanner;
    const currentScanner = scanner;
    const columns = [];
    let currentToken = this.getStartToken(currentScanner, columns);
    while (currentToken) {
      if (Token_1$1.Token.isTokenRowDelimiter(currentToken)) {
        currentScanner.advancePastToken(currentToken);
        if (!currentScanner.hasMoreCharacters && Token_1$1.Token.isTokenCarriageReturn(currentToken, parserOptions) && hasMoreData) {
          return null;
        }
        currentScanner.truncateToCursor();
        return columns;
      }
      if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {
        const item = this.columnParser.parse(currentScanner);
        if (item === null) {
          return null;
        }
        columns.push(item);
      }
      currentToken = currentScanner.nextNonSpaceToken;
    }
    if (!hasMoreData) {
      currentScanner.truncateToCursor();
      return columns;
    }
    return null;
  }
  getStartToken(scanner, columns) {
    const currentToken = scanner.nextNonSpaceToken;
    if (currentToken !== null && Token_1$1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {
      columns.push("");
      return scanner.nextNonSpaceToken;
    }
    return currentToken;
  }
  shouldSkipColumnParse(scanner, currentToken, columns) {
    const { parserOptions } = this;
    if (Token_1$1.Token.isTokenDelimiter(currentToken, parserOptions)) {
      scanner.advancePastToken(currentToken);
      const nextToken = scanner.nextCharacterToken;
      if (!scanner.hasMoreCharacters || nextToken !== null && Token_1$1.Token.isTokenRowDelimiter(nextToken)) {
        columns.push("");
        return true;
      }
      if (nextToken !== null && Token_1$1.Token.isTokenDelimiter(nextToken, parserOptions)) {
        columns.push("");
        return true;
      }
    }
    return false;
  }
}
RowParser$1.RowParser = RowParser;
Object.defineProperty(Parser$1, "__esModule", { value: true });
Parser$1.Parser = void 0;
const Scanner_1 = Scanner$1;
const RowParser_1 = RowParser$1;
const Token_1 = Token$1;
class Parser {
  constructor(parserOptions) {
    this.parserOptions = parserOptions;
    this.rowParser = new RowParser_1.RowParser(this.parserOptions);
  }
  static removeBOM(line) {
    if (line && line.charCodeAt(0) === 65279) {
      return line.slice(1);
    }
    return line;
  }
  parse(line, hasMoreData) {
    const scanner = new Scanner_1.Scanner({
      line: Parser.removeBOM(line),
      parserOptions: this.parserOptions,
      hasMoreData
    });
    if (this.parserOptions.supportsComments) {
      return this.parseWithComments(scanner);
    }
    return this.parseWithoutComments(scanner);
  }
  parseWithoutComments(scanner) {
    const rows = [];
    let shouldContinue = true;
    while (shouldContinue) {
      shouldContinue = this.parseRow(scanner, rows);
    }
    return { line: scanner.line, rows };
  }
  parseWithComments(scanner) {
    const { parserOptions } = this;
    const rows = [];
    for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {
      if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {
        const cursor = scanner.advancePastLine();
        if (cursor === null) {
          return { line: scanner.lineFromCursor, rows };
        }
        if (!scanner.hasMoreCharacters) {
          return { line: scanner.lineFromCursor, rows };
        }
        scanner.truncateToCursor();
      } else if (!this.parseRow(scanner, rows)) {
        break;
      }
    }
    return { line: scanner.line, rows };
  }
  parseRow(scanner, rows) {
    const nextToken = scanner.nextNonSpaceToken;
    if (!nextToken) {
      return false;
    }
    const row2 = this.rowParser.parse(scanner);
    if (row2 === null) {
      return false;
    }
    if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row2)) {
      return true;
    }
    rows.push(row2);
    return true;
  }
}
Parser$1.Parser = Parser;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = exports.Token = exports.Scanner = exports.RowParser = exports.Parser = void 0;
  var Parser_1 = Parser$1;
  Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
    return Parser_1.Parser;
  } });
  var RowParser_12 = RowParser$1;
  Object.defineProperty(exports, "RowParser", { enumerable: true, get: function() {
    return RowParser_12.RowParser;
  } });
  var Scanner_12 = Scanner$1;
  Object.defineProperty(exports, "Scanner", { enumerable: true, get: function() {
    return Scanner_12.Scanner;
  } });
  var Token_12 = Token$1;
  Object.defineProperty(exports, "Token", { enumerable: true, get: function() {
    return Token_12.Token;
  } });
  var column_12 = column;
  Object.defineProperty(exports, "ColumnParser", { enumerable: true, get: function() {
    return column_12.ColumnParser;
  } });
  Object.defineProperty(exports, "NonQuotedColumnParser", { enumerable: true, get: function() {
    return column_12.NonQuotedColumnParser;
  } });
  Object.defineProperty(exports, "QuotedColumnParser", { enumerable: true, get: function() {
    return column_12.QuotedColumnParser;
  } });
})(parser);
Object.defineProperty(CsvParserStream$1, "__esModule", { value: true });
CsvParserStream$1.CsvParserStream = void 0;
const string_decoder_1 = require$$0$5;
const stream_1 = require$$0$1;
const transforms_1 = transforms;
const parser_1 = parser;
class CsvParserStream extends stream_1.Transform {
  constructor(parserOptions) {
    super({ objectMode: parserOptions.objectMode });
    this.lines = "";
    this.rowCount = 0;
    this.parsedRowCount = 0;
    this.parsedLineCount = 0;
    this.endEmitted = false;
    this.headersEmitted = false;
    this.parserOptions = parserOptions;
    this.parser = new parser_1.Parser(parserOptions);
    this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);
    this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);
    this.rowTransformerValidator = new transforms_1.RowTransformerValidator();
  }
  get hasHitRowLimit() {
    return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
  }
  get shouldEmitRows() {
    return this.parsedRowCount > this.parserOptions.skipRows;
  }
  get shouldSkipLine() {
    return this.parsedLineCount <= this.parserOptions.skipLines;
  }
  transform(transformFunction) {
    this.rowTransformerValidator.rowTransform = transformFunction;
    return this;
  }
  validate(validateFunction) {
    this.rowTransformerValidator.rowValidator = validateFunction;
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  emit(event, ...rest) {
    if (event === "end") {
      if (!this.endEmitted) {
        this.endEmitted = true;
        super.emit("end", this.rowCount);
      }
      return false;
    }
    return super.emit(event, ...rest);
  }
  _transform(data, encoding, done) {
    if (this.hasHitRowLimit) {
      return done();
    }
    const wrappedCallback = CsvParserStream.wrapDoneCallback(done);
    try {
      const { lines } = this;
      const newLine = lines + this.decoder.write(data);
      const rows = this.parse(newLine, true);
      return this.processRows(rows, wrappedCallback);
    } catch (e) {
      return wrappedCallback(e);
    }
  }
  _flush(done) {
    const wrappedCallback = CsvParserStream.wrapDoneCallback(done);
    if (this.hasHitRowLimit) {
      return wrappedCallback();
    }
    try {
      const newLine = this.lines + this.decoder.end();
      const rows = this.parse(newLine, false);
      return this.processRows(rows, wrappedCallback);
    } catch (e) {
      return wrappedCallback(e);
    }
  }
  parse(data, hasMoreData) {
    if (!data) {
      return [];
    }
    const { line, rows } = this.parser.parse(data, hasMoreData);
    this.lines = line;
    return rows;
  }
  processRows(rows, cb) {
    const rowsLength = rows.length;
    const iterate = (i) => {
      const callNext = (err2) => {
        if (err2) {
          return cb(err2);
        }
        if (i % 100 === 0) {
          setImmediate(() => iterate(i + 1));
          return void 0;
        }
        return iterate(i + 1);
      };
      this.checkAndEmitHeaders();
      if (i >= rowsLength || this.hasHitRowLimit) {
        return cb();
      }
      this.parsedLineCount += 1;
      if (this.shouldSkipLine) {
        return callNext();
      }
      const row2 = rows[i];
      this.rowCount += 1;
      this.parsedRowCount += 1;
      const nextRowCount = this.rowCount;
      return this.transformRow(row2, (err2, transformResult) => {
        if (err2) {
          this.rowCount -= 1;
          return callNext(err2);
        }
        if (!transformResult) {
          return callNext(new Error("expected transform result"));
        }
        if (!transformResult.isValid) {
          this.emit("data-invalid", transformResult.row, nextRowCount, transformResult.reason);
        } else if (transformResult.row) {
          return this.pushRow(transformResult.row, callNext);
        }
        return callNext();
      });
    };
    iterate(0);
  }
  transformRow(parsedRow, cb) {
    try {
      this.headerTransformer.transform(parsedRow, (err2, withHeaders) => {
        if (err2) {
          return cb(err2);
        }
        if (!withHeaders) {
          return cb(new Error("Expected result from header transform"));
        }
        if (!withHeaders.isValid) {
          if (this.shouldEmitRows) {
            return cb(null, { isValid: false, row: parsedRow });
          }
          return this.skipRow(cb);
        }
        if (withHeaders.row) {
          if (this.shouldEmitRows) {
            return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);
          }
          return this.skipRow(cb);
        }
        this.rowCount -= 1;
        this.parsedRowCount -= 1;
        return cb(null, { row: null, isValid: true });
      });
    } catch (e) {
      cb(e);
    }
  }
  checkAndEmitHeaders() {
    if (!this.headersEmitted && this.headerTransformer.headers) {
      this.headersEmitted = true;
      this.emit("headers", this.headerTransformer.headers);
    }
  }
  skipRow(cb) {
    this.rowCount -= 1;
    return cb(null, { row: null, isValid: true });
  }
  pushRow(row2, cb) {
    try {
      if (!this.parserOptions.objectMode) {
        this.push(JSON.stringify(row2));
      } else {
        this.push(row2);
      }
      cb();
    } catch (e) {
      cb(e);
    }
  }
  static wrapDoneCallback(done) {
    let errorCalled = false;
    return (err2, ...args) => {
      if (err2) {
        if (errorCalled) {
          throw err2;
        }
        errorCalled = true;
        done(err2);
        return;
      }
      done(...args);
    };
  }
}
CsvParserStream$1.CsvParserStream = CsvParserStream;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseString = exports.parseFile = exports.parseStream = exports.parse = exports.ParserOptions = exports.CsvParserStream = void 0;
  const fs2 = __importStar(require$$0$2);
  const stream_12 = require$$0$1;
  const ParserOptions_1 = ParserOptions$1;
  const CsvParserStream_1 = CsvParserStream$1;
  __exportStar(types, exports);
  var CsvParserStream_2 = CsvParserStream$1;
  Object.defineProperty(exports, "CsvParserStream", { enumerable: true, get: function() {
    return CsvParserStream_2.CsvParserStream;
  } });
  var ParserOptions_2 = ParserOptions$1;
  Object.defineProperty(exports, "ParserOptions", { enumerable: true, get: function() {
    return ParserOptions_2.ParserOptions;
  } });
  exports.parse = (args) => new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));
  exports.parseStream = (stream2, options) => stream2.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
  exports.parseFile = (location, options = {}) => fs2.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
  exports.parseString = (string, options) => {
    const rs = new stream_12.Readable();
    rs.push(string);
    rs.push(null);
    return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
  };
})(src);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CsvParserStream = exports.ParserOptions = exports.parseFile = exports.parseStream = exports.parseString = exports.parse = exports.FormatterOptions = exports.CsvFormatterStream = exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = void 0;
  var format_1 = src$1;
  Object.defineProperty(exports, "format", { enumerable: true, get: function() {
    return format_1.format;
  } });
  Object.defineProperty(exports, "write", { enumerable: true, get: function() {
    return format_1.write;
  } });
  Object.defineProperty(exports, "writeToStream", { enumerable: true, get: function() {
    return format_1.writeToStream;
  } });
  Object.defineProperty(exports, "writeToBuffer", { enumerable: true, get: function() {
    return format_1.writeToBuffer;
  } });
  Object.defineProperty(exports, "writeToString", { enumerable: true, get: function() {
    return format_1.writeToString;
  } });
  Object.defineProperty(exports, "writeToPath", { enumerable: true, get: function() {
    return format_1.writeToPath;
  } });
  Object.defineProperty(exports, "CsvFormatterStream", { enumerable: true, get: function() {
    return format_1.CsvFormatterStream;
  } });
  Object.defineProperty(exports, "FormatterOptions", { enumerable: true, get: function() {
    return format_1.FormatterOptions;
  } });
  var parse_1 = src;
  Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
    return parse_1.parse;
  } });
  Object.defineProperty(exports, "parseString", { enumerable: true, get: function() {
    return parse_1.parseString;
  } });
  Object.defineProperty(exports, "parseStream", { enumerable: true, get: function() {
    return parse_1.parseStream;
  } });
  Object.defineProperty(exports, "parseFile", { enumerable: true, get: function() {
    return parse_1.parseFile;
  } });
  Object.defineProperty(exports, "ParserOptions", { enumerable: true, get: function() {
    return parse_1.ParserOptions;
  } });
  Object.defineProperty(exports, "CsvParserStream", { enumerable: true, get: function() {
    return parse_1.CsvParserStream;
  } });
})(src$2);
var customParseFormat$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
      return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
    };
    var f = function(e2) {
      return function(t2) {
        this[e2] = +t2;
      };
    }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
      (this.zone || (this.zone = {})).offset = function(e3) {
        if (!e3) return 0;
        if ("Z" === e3) return 0;
        var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
        return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
      }(e2);
    }], u = function(e2) {
      var t2 = s[e2];
      return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
    }, d = function(e2, t2) {
      var n2, r2 = s.meridiem;
      if (r2) {
        for (var i2 = 1; i2 <= 24; i2 += 1) if (e2.indexOf(r2(i2, 0, t2)) > -1) {
          n2 = i2 > 12;
          break;
        }
      } else n2 = e2 === (t2 ? "pm" : "PM");
      return n2;
    }, c2 = { A: [o, function(e2) {
      this.afternoon = d(e2, false);
    }], a: [o, function(e2) {
      this.afternoon = d(e2, true);
    }], Q: [n, function(e2) {
      this.month = 3 * (e2 - 1) + 1;
    }], S: [n, function(e2) {
      this.milliseconds = 100 * +e2;
    }], SS: [r, function(e2) {
      this.milliseconds = 10 * +e2;
    }], SSS: [/\d{3}/, function(e2) {
      this.milliseconds = +e2;
    }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
      var t2 = s.ordinal, n2 = e2.match(/\d+/);
      if (this.day = n2[0], t2) for (var r2 = 1; r2 <= 31; r2 += 1) t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
    }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
      var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
        return e3.slice(0, 3);
      })).indexOf(e2) + 1;
      if (n2 < 1) throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [o, function(e2) {
      var t2 = u("months").indexOf(e2) + 1;
      if (t2 < 1) throw new Error();
      this.month = t2 % 12 || t2;
    }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
      this.year = a(e2);
    }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
    function l(n2) {
      var r2, i2;
      r2 = n2, i2 = s && s.formats;
      for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
        var o3 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
          return t3 || n4.slice(1);
        });
      })).match(t), a2 = o2.length, f2 = 0; f2 < a2; f2 += 1) {
        var h2 = o2[f2], u2 = c2[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
        o2[f2] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
      }
      return function(e2) {
        for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
          var i3 = o2[n3];
          if ("string" == typeof i3) r3 += i3.length;
          else {
            var s2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
            f3.call(t2, u3), e2 = e2.replace(u3, "");
          }
        }
        return function(e3) {
          var t3 = e3.afternoon;
          if (void 0 !== t3) {
            var n4 = e3.hours;
            t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
          }
        }(t2), t2;
      };
    }
    return function(e2, t2, n2) {
      n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
      var r2 = t2.prototype, i2 = r2.parse;
      r2.parse = function(e3) {
        var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
        this.$u = r3;
        var a2 = o2[1];
        if ("string" == typeof a2) {
          var f2 = true === o2[2], h2 = true === o2[3], u2 = f2 || h2, d2 = o2[2];
          h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
            try {
              if (["x", "X"].indexOf(t4) > -1) return new Date(("X" === t4 ? 1e3 : 1) * e4);
              var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c4 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
              o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
              var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
              return c4 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c4.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
            } catch (e5) {
              return /* @__PURE__ */ new Date("");
            }
          }(t3, a2, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
        } else if (a2 instanceof Array) for (var c3 = a2.length, m = 1; m <= c3; m += 1) {
          o2[1] = a2[m - 1];
          var M = n2.apply(this, o2);
          if (M.isValid()) {
            this.$d = M.$d, this.$L = M.$L, this.init();
            break;
          }
          m === c3 && (this.$d = /* @__PURE__ */ new Date(""));
        }
        else i2.call(this, e3);
      };
    };
  });
})(customParseFormat$1);
var customParseFormatExports = customParseFormat$1.exports;
var utc$1 = { exports: {} };
(function(module, exports) {
  !function(t, i) {
    module.exports = i();
  }(commonjsGlobal, function() {
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
      var u = f.prototype;
      n.utc = function(t2) {
        var i2 = { date: t2, utc: true, args: arguments };
        return new f(i2);
      }, u.utc = function(i2) {
        var e2 = n(this.toDate(), { locale: this.$L, utc: true });
        return i2 ? e2.add(this.utcOffset(), t) : e2;
      }, u.local = function() {
        return n(this.toDate(), { locale: this.$L, utc: false });
      };
      var o = u.parse;
      u.parse = function(t2) {
        t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
      };
      var r = u.init;
      u.init = function() {
        if (this.$u) {
          var t2 = this.$d;
          this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
        } else r.call(this);
      };
      var a = u.utcOffset;
      u.utcOffset = function(s2, f2) {
        var n2 = this.$utils().u;
        if (n2(s2)) return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
        if ("string" == typeof s2 && (s2 = function(t2) {
          void 0 === t2 && (t2 = "");
          var s3 = t2.match(i);
          if (!s3) return null;
          var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
          return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
        }(s2), null === s2)) return this;
        var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
        if (f2) return o2.$offset = u2, o2.$u = 0 === s2, o2;
        if (0 !== s2) {
          var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
        } else o2 = this.utc();
        return o2;
      };
      var h = u.format;
      u.format = function(t2) {
        var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h.call(this, i2);
      }, u.valueOf = function() {
        var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * t2;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var l = u.toDate;
      u.toDate = function(t2) {
        return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
      };
      var c2 = u.diff;
      u.diff = function(t2, i2, e2) {
        if (t2 && this.$u === t2.$u) return c2.call(this, t2, i2, e2);
        var s2 = this.local(), f2 = n(t2).local();
        return c2.call(s2, f2, i2, e2);
      };
    };
  });
})(utc$1);
var utcExports = utc$1.exports;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c2 = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date()) return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c2), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c2);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c2, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return void 0 === t2;
    } }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t2) {
      return t2 instanceof _2 || !(!t2 || !t2[p]);
    }, w = function t2(e2, n2, r2) {
      var i2;
      if (!e2) return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1) return t2(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t2, e2) {
      if (S(t2)) return t2.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _2(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t2, e2) {
      return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _2 = function() {
      function M2(t2) {
        this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (null === e2) return /* @__PURE__ */ new Date(NaN);
          if (b.u(e2)) return /* @__PURE__ */ new Date();
          if (e2 instanceof Date) return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = O(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return O(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < O(t2);
      }, m2.$g = function(t2, e2, n2) {
        return b.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t3, e3) {
          return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c2:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c2] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c2 || o2 === h) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[b.p(t2)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = b.p(f2), y2 = function(t2) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($2 === c2) return this.set(c2, this.$M + r2);
        if ($2 === h) return this.set(h, this.$y + r2);
        if ($2 === a) return y2(1);
        if ($2 === o) return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid()) return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c3 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t3) {
          return b.s(s2 % 12 || 12, t3, "0");
        }, $2 = f2 || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t3, r3) {
          return r3 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h2(n2.monthsShort, a2, c3, 3);
              case "MMMM":
                return h2(c3, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h2(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h2(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $2(s2, u2, true);
              case "A":
                return $2(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h:
            $2 = D2() / 12;
            break;
          case c2:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
          case o:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a:
            $2 = (g2 - v2) / 864e5;
            break;
          case u:
            $2 = g2 / n;
            break;
          case s:
            $2 = g2 / e;
            break;
          case i:
            $2 = g2 / t;
            break;
          default:
            $2 = g2;
        }
        return l2 ? $2 : b.a($2);
      }, m2.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2) return this.$L;
        var n2 = this.clone(), r2 = w(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _2.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c2], ["$y", h], ["$D", d]].forEach(function(t2) {
      k[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), O.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _2, O), t2.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
      return O(1e3 * t2);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const fs$f = require$$0$2;
const fastCsv = src$2;
const customParseFormat = customParseFormatExports;
const utc = utcExports;
const dayjs = dayjs_minExports.extend(customParseFormat).extend(utc);
const StreamBuf$1 = streamBuf;
const {
  fs: { exists }
} = utils_1;
const SpecialValues = {
  true: true,
  false: false,
  "#N/A": { error: "#N/A" },
  "#REF!": { error: "#REF!" },
  "#NAME?": { error: "#NAME?" },
  "#DIV/0!": { error: "#DIV/0!" },
  "#NULL!": { error: "#NULL!" },
  "#VALUE!": { error: "#VALUE!" },
  "#NUM!": { error: "#NUM!" }
};
let CSV$1 = class CSV {
  constructor(workbook2) {
    this.workbook = workbook2;
    this.worksheet = null;
  }
  async readFile(filename, options) {
    options = options || {};
    if (!await exists(filename)) {
      throw new Error(`File not found: ${filename}`);
    }
    const stream2 = fs$f.createReadStream(filename);
    const worksheet2 = await this.read(stream2, options);
    stream2.close();
    return worksheet2;
  }
  read(stream2, options) {
    options = options || {};
    return new Promise((resolve2, reject2) => {
      const worksheet2 = this.workbook.addWorksheet(options.sheetName);
      const dateFormats = options.dateFormats || [
        "YYYY-MM-DD[T]HH:mm:ssZ",
        "YYYY-MM-DD[T]HH:mm:ss",
        "MM-DD-YYYY",
        "YYYY-MM-DD"
      ];
      const map3 = options.map || function(datum) {
        if (datum === "") {
          return null;
        }
        const datumNumber = Number(datum);
        if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {
          return datumNumber;
        }
        const dt = dateFormats.reduce((matchingDate, currentDateFormat) => {
          if (matchingDate) {
            return matchingDate;
          }
          const dayjsObj = dayjs(datum, currentDateFormat, true);
          if (dayjsObj.isValid()) {
            return dayjsObj;
          }
          return null;
        }, null);
        if (dt) {
          return new Date(dt.valueOf());
        }
        const special = SpecialValues[datum];
        if (special !== void 0) {
          return special;
        }
        return datum;
      };
      const csvStream = fastCsv.parse(options.parserOptions).on("data", (data) => {
        worksheet2.addRow(data.map(map3));
      }).on("end", () => {
        csvStream.emit("worksheet", worksheet2);
      });
      csvStream.on("worksheet", resolve2).on("error", reject2);
      stream2.pipe(csvStream);
    });
  }
  /**
   * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
   */
  createInputStream() {
    throw new Error(
      "`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md"
    );
  }
  write(stream2, options) {
    return new Promise((resolve2, reject2) => {
      options = options || {};
      const worksheet2 = this.workbook.getWorksheet(options.sheetName || options.sheetId);
      const csvStream = fastCsv.format(options.formatterOptions);
      stream2.on("finish", () => {
        resolve2();
      });
      csvStream.on("error", reject2);
      csvStream.pipe(stream2);
      const { dateFormat, dateUTC } = options;
      const map3 = options.map || ((value) => {
        if (value) {
          if (value.text || value.hyperlink) {
            return value.hyperlink || value.text || "";
          }
          if (value.formula || value.result) {
            return value.result || "";
          }
          if (value instanceof Date) {
            if (dateFormat) {
              return dateUTC ? dayjs.utc(value).format(dateFormat) : dayjs(value).format(dateFormat);
            }
            return dateUTC ? dayjs.utc(value).format() : dayjs(value).format();
          }
          if (value.error) {
            return value.error;
          }
          if (typeof value === "object") {
            return JSON.stringify(value);
          }
        }
        return value;
      });
      const includeEmptyRows = options.includeEmptyRows === void 0 || options.includeEmptyRows;
      let lastRow = 1;
      if (worksheet2) {
        worksheet2.eachRow((row2, rowNumber) => {
          if (includeEmptyRows) {
            while (lastRow++ < rowNumber - 1) {
              csvStream.write([]);
            }
          }
          const { values } = row2;
          values.shift();
          csvStream.write(values.map(map3));
          lastRow = rowNumber;
        });
      }
      csvStream.end();
    });
  }
  writeFile(filename, options) {
    options = options || {};
    const streamOptions = {
      encoding: options.encoding || "utf8"
    };
    const stream2 = fs$f.createWriteStream(filename, streamOptions);
    return this.write(stream2, options);
  }
  async writeBuffer(options) {
    const stream2 = new StreamBuf$1();
    await this.write(stream2, options);
    return stream2.read();
  }
};
var csv = CSV$1;
const Worksheet2 = worksheet;
const DefinedNames$1 = definedNames;
const XLSX$1 = xlsx;
const CSV2 = csv;
class Workbook {
  constructor() {
    this.category = "";
    this.company = "";
    this.created = /* @__PURE__ */ new Date();
    this.description = "";
    this.keywords = "";
    this.manager = "";
    this.modified = this.created;
    this.properties = {};
    this.calcProperties = {};
    this._worksheets = [];
    this.subject = "";
    this.title = "";
    this.views = [];
    this.media = [];
    this._definedNames = new DefinedNames$1();
  }
  get xlsx() {
    if (!this._xlsx) this._xlsx = new XLSX$1(this);
    return this._xlsx;
  }
  get csv() {
    if (!this._csv) this._csv = new CSV2(this);
    return this._csv;
  }
  get nextId() {
    for (let i = 1; i < this._worksheets.length; i++) {
      if (!this._worksheets[i]) {
        return i;
      }
    }
    return this._worksheets.length || 1;
  }
  addWorksheet(name, options) {
    const id = this.nextId;
    if (options) {
      if (typeof options === "string") {
        console.trace(
          'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }'
        );
        options = {
          properties: {
            tabColor: { argb: options }
          }
        };
      } else if (options.argb || options.theme || options.indexed) {
        console.trace(
          "tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }"
        );
        options = {
          properties: {
            tabColor: options
          }
        };
      }
    }
    const lastOrderNo = this._worksheets.reduce((acc, ws) => (ws && ws.orderNo) > acc ? ws.orderNo : acc, 0);
    const worksheetOptions = Object.assign({}, options, {
      id,
      name,
      orderNo: lastOrderNo + 1,
      workbook: this
    });
    const worksheet2 = new Worksheet2(worksheetOptions);
    this._worksheets[id] = worksheet2;
    return worksheet2;
  }
  removeWorksheetEx(worksheet2) {
    delete this._worksheets[worksheet2.id];
  }
  removeWorksheet(id) {
    const worksheet2 = this.getWorksheet(id);
    if (worksheet2) {
      worksheet2.destroy();
    }
  }
  getWorksheet(id) {
    if (id === void 0) {
      return this._worksheets.find(Boolean);
    }
    if (typeof id === "number") {
      return this._worksheets[id];
    }
    if (typeof id === "string") {
      return this._worksheets.find((worksheet2) => worksheet2 && worksheet2.name === id);
    }
    return void 0;
  }
  get worksheets() {
    return this._worksheets.slice(1).sort((a, b) => a.orderNo - b.orderNo).filter(Boolean);
  }
  eachSheet(iteratee) {
    this.worksheets.forEach((sheet) => {
      iteratee(sheet, sheet.id);
    });
  }
  get definedNames() {
    return this._definedNames;
  }
  clearThemes() {
    this._themes = void 0;
  }
  addImage(image2) {
    const id = this.media.length;
    this.media.push(Object.assign({}, image2, { type: "image" }));
    return id;
  }
  getImage(id) {
    return this.media[id];
  }
  get model() {
    return {
      creator: this.creator || "Unknown",
      lastModifiedBy: this.lastModifiedBy || "Unknown",
      lastPrinted: this.lastPrinted,
      created: this.created,
      modified: this.modified,
      properties: this.properties,
      worksheets: this.worksheets.map((worksheet2) => worksheet2.model),
      sheets: this.worksheets.map((ws) => ws.model).filter(Boolean),
      definedNames: this._definedNames.model,
      views: this.views,
      company: this.company,
      manager: this.manager,
      title: this.title,
      subject: this.subject,
      keywords: this.keywords,
      category: this.category,
      description: this.description,
      language: this.language,
      revision: this.revision,
      contentStatus: this.contentStatus,
      themes: this._themes,
      media: this.media,
      calcProperties: this.calcProperties
    };
  }
  set model(value) {
    this.creator = value.creator;
    this.lastModifiedBy = value.lastModifiedBy;
    this.lastPrinted = value.lastPrinted;
    this.created = value.created;
    this.modified = value.modified;
    this.company = value.company;
    this.manager = value.manager;
    this.title = value.title;
    this.subject = value.subject;
    this.keywords = value.keywords;
    this.category = value.category;
    this.description = value.description;
    this.language = value.language;
    this.revision = value.revision;
    this.contentStatus = value.contentStatus;
    this.properties = value.properties;
    this.calcProperties = value.calcProperties;
    this._worksheets = [];
    value.worksheets.forEach((worksheetModel) => {
      const { id, name, state: state2 } = worksheetModel;
      const orderNo = value.sheets && value.sheets.findIndex((ws) => ws.id === id);
      const worksheet2 = this._worksheets[id] = new Worksheet2({
        id,
        name,
        orderNo,
        state: state2,
        workbook: this
      });
      worksheet2.model = worksheetModel;
    });
    this._definedNames.model = value.definedNames;
    this.views = value.views;
    this._themes = value.themes;
    this.media = value.media || [];
  }
}
var workbook = Workbook;
const XLSX2 = xlsx;
class ModelContainer {
  constructor(model) {
    this.model = model;
  }
  get xlsx() {
    if (!this._xlsx) {
      this._xlsx = new XLSX2(this);
    }
    return this._xlsx;
  }
}
var modelcontainer = ModelContainer;
const isWindows$2 = typeof process === "object" && process && process.platform === "win32";
var path$c = isWindows$2 ? { sep: "\\" } : { sep: "/" };
var balancedMatch = balanced$2;
function balanced$2(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);
  var r = range$1(a, b, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}
balanced$2.range = range$1;
function range$1(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
var balanced$1 = balancedMatch;
var braceExpansion$1 = expandTop$1;
var escSlash$1 = "\0SLASH" + Math.random() + "\0";
var escOpen$1 = "\0OPEN" + Math.random() + "\0";
var escClose$1 = "\0CLOSE" + Math.random() + "\0";
var escComma$1 = "\0COMMA" + Math.random() + "\0";
var escPeriod$1 = "\0PERIOD" + Math.random() + "\0";
function numeric$1(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces$1(str) {
  return str.split("\\\\").join(escSlash$1).split("\\{").join(escOpen$1).split("\\}").join(escClose$1).split("\\,").join(escComma$1).split("\\.").join(escPeriod$1);
}
function unescapeBraces$1(str) {
  return str.split(escSlash$1).join("\\").split(escOpen$1).join("{").split(escClose$1).join("}").split(escComma$1).join(",").split(escPeriod$1).join(".");
}
function parseCommaParts$1(str) {
  if (!str)
    return [""];
  var parts = [];
  var m = balanced$1("{", "}", str);
  if (!m)
    return str.split(",");
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts$1(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop$1(str) {
  if (!str)
    return [];
  if (str.substr(0, 2) === "{}") {
    str = "\\{\\}" + str.substr(2);
  }
  return expand$3(escapeBraces$1(str), true).map(unescapeBraces$1);
}
function embrace$1(str) {
  return "{" + str + "}";
}
function isPadded$1(el) {
  return /^-?0\d/.test(el);
}
function lte$1(i, y) {
  return i <= y;
}
function gte$1(i, y) {
  return i >= y;
}
function expand$3(str, isTop) {
  var expansions = [];
  var m = balanced$1("{", "}", str);
  if (!m) return [str];
  var pre = m.pre;
  var post = m.post.length ? expand$3(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose$1 + m.post;
        return expand$3(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts$1(m.body);
      if (n.length === 1) {
        n = expand$3(n[0], false).map(embrace$1);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var N;
    if (isSequence) {
      var x = numeric$1(n[0]);
      var y = numeric$1(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric$1(n[2])) : 1;
      var test = lte$1;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte$1;
      }
      var pad = n.some(isPadded$1);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i);
          if (c2 === "\\")
            c2 = "";
        } else {
          c2 = String(i);
          if (pad) {
            var need = width - c2.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c2 = "-" + z + c2.slice(1);
              else
                c2 = z + c2;
            }
          }
        }
        N.push(c2);
      }
    } else {
      N = [];
      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand$3(n[j], false));
      }
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }
  return expansions;
}
const minimatch$2 = minimatch_1$1 = (p, pattern, options = {}) => {
  assertValidPattern$1(pattern);
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch$3(pattern, options).match(p);
};
var minimatch_1$1 = minimatch$2;
const path$b = path$c;
minimatch$2.sep = path$b.sep;
const GLOBSTAR$1 = Symbol("globstar **");
minimatch$2.GLOBSTAR = GLOBSTAR$1;
const expand$2 = braceExpansion$1;
const plTypes$1 = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
const qmark$1 = "[^/]";
const star$1 = qmark$1 + "*?";
const twoStarDot$1 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
const twoStarNoDot$1 = "(?:(?!(?:\\/|^)\\.).)*?";
const charSet$1 = (s) => s.split("").reduce((set2, c2) => {
  set2[c2] = true;
  return set2;
}, {});
const reSpecials$1 = charSet$1("().*{}+?[]^$\\!");
const addPatternStartSet = charSet$1("[.(");
const slashSplit$1 = /\/+/;
minimatch$2.filter = (pattern, options = {}) => (p, i, list) => minimatch$2(p, pattern, options);
const ext$1 = (a, b = {}) => {
  const t = {};
  Object.keys(a).forEach((k) => t[k] = a[k]);
  Object.keys(b).forEach((k) => t[k] = b[k]);
  return t;
};
minimatch$2.defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch$2;
  }
  const orig = minimatch$2;
  const m = (p, pattern, options) => orig(p, pattern, ext$1(def, options));
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor(pattern, options) {
      super(pattern, ext$1(def, options));
    }
  };
  m.Minimatch.defaults = (options) => orig.defaults(ext$1(def, options)).Minimatch;
  m.filter = (pattern, options) => orig.filter(pattern, ext$1(def, options));
  m.defaults = (options) => orig.defaults(ext$1(def, options));
  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext$1(def, options));
  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext$1(def, options));
  m.match = (list, pattern, options) => orig.match(list, pattern, ext$1(def, options));
  return m;
};
minimatch$2.braceExpand = (pattern, options) => braceExpand$1(pattern, options);
const braceExpand$1 = (pattern, options = {}) => {
  assertValidPattern$1(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand$2(pattern);
};
const MAX_PATTERN_LENGTH$1 = 1024 * 64;
const assertValidPattern$1 = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH$1) {
    throw new TypeError("pattern is too long");
  }
};
const SUBPARSE$1 = Symbol("subparse");
minimatch$2.makeRe = (pattern, options) => new Minimatch$3(pattern, options || {}).makeRe();
minimatch$2.match = (list, pattern, options = {}) => {
  const mm = new Minimatch$3(pattern, options);
  list = list.filter((f) => mm.match(f));
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
const globUnescape$1 = (s) => s.replace(/\\(.)/g, "$1");
const charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
const regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
const braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
let Minimatch$3 = class Minimatch {
  constructor(pattern, options) {
    assertValidPattern$1(pattern);
    if (!options) options = {};
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.make();
  }
  debug() {
  }
  make() {
    const pattern = this.pattern;
    const options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    let set2 = this.globSet = this.braceExpand();
    if (options.debug) this.debug = (...args) => console.error(...args);
    this.debug(this.pattern, set2);
    set2 = this.globParts = set2.map((s) => s.split(slashSplit$1));
    this.debug(this.pattern, set2);
    set2 = set2.map((s, si, set3) => s.map(this.parse, this));
    this.debug(this.pattern, set2);
    set2 = set2.filter((s) => s.indexOf(false) === -1);
    this.debug(this.pattern, set2);
    this.set = set2;
  }
  parseNegate() {
    if (this.options.nonegate) return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file2, pattern, partial) {
    var options = this.options;
    this.debug(
      "matchOne",
      { "this": this, file: file2, pattern }
    );
    this.debug("matchOne", file2.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file2[fi];
      this.debug(pattern, p, f);
      if (p === false) return false;
      if (p === GLOBSTAR$1) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file2[fi] === "." || file2[fi] === ".." || !options.dot && file2[fi].charAt(0) === ".") return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file2[fr];
          this.debug("\nglobstar while", file2, fr, pattern, pr, swallowee);
          if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file2, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file2, fr, pattern, pr);
          if (fr === fl) return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit) return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file2[fi] === "";
    }
    throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand$1(this.pattern, this.options);
  }
  parse(pattern, isSub) {
    assertValidPattern$1(pattern);
    const options = this.options;
    if (pattern === "**") {
      if (!options.noglobstar)
        return GLOBSTAR$1;
      else
        pattern = "*";
    }
    if (pattern === "") return "";
    let re = "";
    let hasMagic = false;
    let escaping = false;
    const patternListStack = [];
    const negativeLists = [];
    let stateChar;
    let inClass = false;
    let reClassStart = -1;
    let classStart = -1;
    let cs;
    let pl;
    let sp;
    let dotTravAllowed = pattern.charAt(0) === ".";
    let dotFileAllowed = options.dot || dotTravAllowed;
    const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const clearStateChar = () => {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star$1;
            hasMagic = true;
            break;
          case "?":
            re += qmark$1;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        this.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    };
    for (let i = 0, c2; i < pattern.length && (c2 = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c2);
      if (escaping) {
        if (c2 === "/") {
          return false;
        }
        if (reSpecials$1[c2]) {
          re += "\\";
        }
        re += c2;
        escaping = false;
        continue;
      }
      switch (c2) {
        case "/": {
          return false;
        }
        case "\\":
          if (inClass && pattern.charAt(i + 1) === "-") {
            re += c2;
            continue;
          }
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c2);
          if (inClass) {
            this.debug("  in class");
            if (c2 === "!" && i === classStart + 1) c2 = "^";
            re += c2;
            continue;
          }
          this.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c2;
          if (options.noext) clearStateChar();
          continue;
        case "(": {
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          const plEntry = {
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes$1[stateChar].open,
            close: plTypes$1[stateChar].close
          };
          this.debug(this.pattern, "	", plEntry);
          patternListStack.push(plEntry);
          re += plEntry.open;
          if (plEntry.start === 0 && plEntry.type !== "!") {
            dotTravAllowed = true;
            re += subPatternStart(pattern.slice(i + 1));
          }
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        }
        case ")": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (inClass || !plEntry) {
            re += "\\)";
            continue;
          }
          patternListStack.pop();
          clearStateChar();
          hasMagic = true;
          pl = plEntry;
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(Object.assign(pl, { reEnd: re.length }));
          }
          continue;
        }
        case "|": {
          const plEntry = patternListStack[patternListStack.length - 1];
          if (inClass || !plEntry) {
            re += "\\|";
            continue;
          }
          clearStateChar();
          re += "|";
          if (plEntry.start === 0 && plEntry.type !== "!") {
            dotTravAllowed = true;
            re += subPatternStart(pattern.slice(i + 1));
          }
          continue;
        }
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c2;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c2;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c2;
            continue;
          }
          cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
            re += c2;
          } catch (er) {
            re = re.substring(0, reClassStart) + "(?:$.)";
          }
          hasMagic = true;
          inClass = false;
          continue;
        default:
          clearStateChar();
          if (reSpecials$1[c2] && !(c2 === "^" && inClass)) {
            re += "\\";
          }
          re += c2;
          break;
      }
    }
    if (inClass) {
      cs = pattern.slice(classStart + 1);
      sp = this.parse(cs, SUBPARSE$1);
      re = re.substring(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail;
      tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      const t = pl.type === "*" ? star$1 : pl.type === "?" ? qmark$1 : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    const addPatternStart = addPatternStartSet[re.charAt(0)];
    for (let n = negativeLists.length - 1; n > -1; n--) {
      const nl = negativeLists[n];
      const nlBefore = re.slice(0, nl.reStart);
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      let nlAfter = re.slice(nl.reEnd);
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
      const closeParensBefore = nlBefore.split(")").length;
      const openParensBefore = nlBefore.split("(").length - closeParensBefore;
      let cleanAfter = nlAfter;
      for (let i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      const dollar = nlAfter === "" && isSub !== SUBPARSE$1 ? "(?:$|\\/)" : "";
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart() + re;
    }
    if (isSub === SUBPARSE$1) {
      return [re, hasMagic];
    }
    if (options.nocase && !hasMagic) {
      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
    }
    if (!hasMagic) {
      return globUnescape$1(pattern);
    }
    const flags = options.nocase ? "i" : "";
    try {
      return Object.assign(new RegExp("^" + re + "$", flags), {
        _glob: pattern,
        _src: re
      });
    } catch (er) {
      return new RegExp("$.");
    }
  }
  makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    const set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options = this.options;
    const twoStar = options.noglobstar ? star$1 : options.dot ? twoStarDot$1 : twoStarNoDot$1;
    const flags = options.nocase ? "i" : "";
    let re = set2.map((pattern) => {
      pattern = pattern.map(
        (p) => typeof p === "string" ? regExpEscape$1(p) : p === GLOBSTAR$1 ? GLOBSTAR$1 : p._src
      ).reduce((set3, p) => {
        if (!(set3[set3.length - 1] === GLOBSTAR$1 && p === GLOBSTAR$1)) {
          set3.push(p);
        }
        return set3;
      }, []);
      pattern.forEach((p, i) => {
        if (p !== GLOBSTAR$1 || pattern[i - 1] === GLOBSTAR$1) {
          return;
        }
        if (i === 0) {
          if (pattern.length > 1) {
            pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
          } else {
            pattern[i] = twoStar;
          }
        } else if (i === pattern.length - 1) {
          pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
        } else {
          pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
          pattern[i + 1] = GLOBSTAR$1;
        }
      });
      return pattern.filter((p) => p !== GLOBSTAR$1).join("/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate) re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  match(f, partial = this.partial) {
    this.debug("match", f, this.pattern);
    if (this.comment) return false;
    if (this.empty) return f === "";
    if (f === "/" && partial) return true;
    const options = this.options;
    if (path$b.sep !== "/") {
      f = f.split(path$b.sep).join("/");
    }
    f = f.split(slashSplit$1);
    this.debug(this.pattern, "split", f);
    const set2 = this.set;
    this.debug(this.pattern, "set", set2);
    let filename;
    for (let i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename) break;
    }
    for (let i = 0; i < set2.length; i++) {
      const pattern = set2[i];
      let file2 = f;
      if (options.matchBase && pattern.length === 1) {
        file2 = [filename];
      }
      const hit = this.matchOne(file2, pattern, partial);
      if (hit) {
        if (options.flipNegate) return true;
        return !this.negate;
      }
    }
    if (options.flipNegate) return false;
    return this.negate;
  }
  static defaults(def) {
    return minimatch$2.defaults(def).Minimatch;
  }
};
minimatch$2.Minimatch = Minimatch$3;
var readdirGlob_1 = readdirGlob;
const fs$e = require$$0$2;
const { EventEmitter: EventEmitter$4 } = require$$2$1;
const { Minimatch: Minimatch$2 } = minimatch_1$1;
const { resolve } = require$$1;
function readdir(dir2, strict) {
  return new Promise((resolve2, reject2) => {
    fs$e.readdir(dir2, { withFileTypes: true }, (err2, files) => {
      if (err2) {
        switch (err2.code) {
          case "ENOTDIR":
            if (strict) {
              reject2(err2);
            } else {
              resolve2([]);
            }
            break;
          case "ENOTSUP":
          case "ENOENT":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            resolve2([]);
            break;
          case "ELOOP":
          default:
            reject2(err2);
            break;
        }
      } else {
        resolve2(files);
      }
    });
  });
}
function stat(file2, followSymlinks) {
  return new Promise((resolve2, reject2) => {
    const statFunc = followSymlinks ? fs$e.stat : fs$e.lstat;
    statFunc(file2, (err2, stats) => {
      if (err2) {
        switch (err2.code) {
          case "ENOENT":
            if (followSymlinks) {
              resolve2(stat(file2, false));
            } else {
              resolve2(null);
            }
            break;
          default:
            resolve2(null);
            break;
        }
      } else {
        resolve2(stats);
      }
    });
  });
}
async function* exploreWalkAsync(dir2, path2, followSymlinks, useStat, shouldSkip, strict) {
  let files = await readdir(path2 + dir2, strict);
  for (const file2 of files) {
    let name = file2.name;
    if (name === void 0) {
      name = file2;
      useStat = true;
    }
    const filename = dir2 + "/" + name;
    const relative = filename.slice(1);
    const absolute = path2 + "/" + relative;
    let stats = null;
    if (useStat || followSymlinks) {
      stats = await stat(absolute, followSymlinks);
    }
    if (!stats && file2.name !== void 0) {
      stats = file2;
    }
    if (stats === null) {
      stats = { isDirectory: () => false };
    }
    if (stats.isDirectory()) {
      if (!shouldSkip(relative)) {
        yield { relative, absolute, stats };
        yield* exploreWalkAsync(filename, path2, followSymlinks, useStat, shouldSkip, false);
      }
    } else {
      yield { relative, absolute, stats };
    }
  }
}
async function* explore(path2, followSymlinks, useStat, shouldSkip) {
  yield* exploreWalkAsync("", path2, followSymlinks, useStat, shouldSkip, true);
}
function readOptions(options) {
  return {
    pattern: options.pattern,
    dot: !!options.dot,
    noglobstar: !!options.noglobstar,
    matchBase: !!options.matchBase,
    nocase: !!options.nocase,
    ignore: options.ignore,
    skip: options.skip,
    follow: !!options.follow,
    stat: !!options.stat,
    nodir: !!options.nodir,
    mark: !!options.mark,
    silent: !!options.silent,
    absolute: !!options.absolute
  };
}
class ReaddirGlob extends EventEmitter$4 {
  constructor(cwd2, options, cb) {
    super();
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    this.options = readOptions(options || {});
    this.matchers = [];
    if (this.options.pattern) {
      const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
      this.matchers = matchers.map(
        (m) => new Minimatch$2(m, {
          dot: this.options.dot,
          noglobstar: this.options.noglobstar,
          matchBase: this.options.matchBase,
          nocase: this.options.nocase
        })
      );
    }
    this.ignoreMatchers = [];
    if (this.options.ignore) {
      const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
      this.ignoreMatchers = ignorePatterns.map(
        (ignore) => new Minimatch$2(ignore, { dot: true })
      );
    }
    this.skipMatchers = [];
    if (this.options.skip) {
      const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
      this.skipMatchers = skipPatterns.map(
        (skip) => new Minimatch$2(skip, { dot: true })
      );
    }
    this.iterator = explore(resolve(cwd2 || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
    this.paused = false;
    this.inactive = false;
    this.aborted = false;
    if (cb) {
      this._matches = [];
      this.on("match", (match2) => this._matches.push(this.options.absolute ? match2.absolute : match2.relative));
      this.on("error", (err2) => cb(err2));
      this.on("end", () => cb(null, this._matches));
    }
    setTimeout(() => this._next(), 0);
  }
  _shouldSkipDirectory(relative) {
    return this.skipMatchers.some((m) => m.match(relative));
  }
  _fileMatches(relative, isDirectory) {
    const file2 = relative + (isDirectory ? "/" : "");
    return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file2))) && !this.ignoreMatchers.some((m) => m.match(file2)) && (!this.options.nodir || !isDirectory);
  }
  _next() {
    if (!this.paused && !this.aborted) {
      this.iterator.next().then((obj) => {
        if (!obj.done) {
          const isDirectory = obj.value.stats.isDirectory();
          if (this._fileMatches(obj.value.relative, isDirectory)) {
            let relative = obj.value.relative;
            let absolute = obj.value.absolute;
            if (this.options.mark && isDirectory) {
              relative += "/";
              absolute += "/";
            }
            if (this.options.stat) {
              this.emit("match", { relative, absolute, stat: obj.value.stats });
            } else {
              this.emit("match", { relative, absolute });
            }
          }
          this._next(this.iterator);
        } else {
          this.emit("end");
        }
      }).catch((err2) => {
        this.abort();
        this.emit("error", err2);
        if (!err2.code && !this.options.silent) {
          console.error(err2);
        }
      });
    } else {
      this.inactive = true;
    }
  }
  abort() {
    this.aborted = true;
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
    if (this.inactive) {
      this.inactive = false;
      this._next();
    }
  }
}
function readdirGlob(pattern, options, cb) {
  return new ReaddirGlob(pattern, options, cb);
}
readdirGlob.ReaddirGlob = ReaddirGlob;
function apply$3(fn, ...args) {
  return (...callArgs) => fn(...args, ...callArgs);
}
function initialParams(fn) {
  return function(...args) {
    var callback = args.pop();
    return fn.call(this, args, callback);
  };
}
var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
function fallback(fn) {
  setTimeout(fn, 0);
}
function wrap(defer) {
  return (fn, ...args) => defer(() => fn(...args));
}
var _defer$1;
if (hasQueueMicrotask) {
  _defer$1 = queueMicrotask;
} else if (hasSetImmediate) {
  _defer$1 = setImmediate;
} else if (hasNextTick) {
  _defer$1 = process.nextTick;
} else {
  _defer$1 = fallback;
}
var setImmediate$1 = wrap(_defer$1);
function asyncify(func) {
  if (isAsync(func)) {
    return function(...args) {
      const callback = args.pop();
      const promise2 = func.apply(this, args);
      return handlePromise(promise2, callback);
    };
  }
  return initialParams(function(args, callback) {
    var result;
    try {
      result = func.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result && typeof result.then === "function") {
      return handlePromise(result, callback);
    } else {
      callback(null, result);
    }
  });
}
function handlePromise(promise2, callback) {
  return promise2.then((value) => {
    invokeCallback(callback, null, value);
  }, (err2) => {
    invokeCallback(callback, err2 && (err2 instanceof Error || err2.message) ? err2 : new Error(err2));
  });
}
function invokeCallback(callback, error2, value) {
  try {
    callback(error2, value);
  } catch (err2) {
    setImmediate$1((e) => {
      throw e;
    }, err2);
  }
}
function isAsync(fn) {
  return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
  return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function") throw new Error("expected a function");
  return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
function awaitify(asyncFn, arity) {
  if (!arity) arity = asyncFn.length;
  if (!arity) throw new Error("arity is undefined");
  function awaitable(...args) {
    if (typeof args[arity - 1] === "function") {
      return asyncFn.apply(this, args);
    }
    return new Promise((resolve2, reject2) => {
      args[arity - 1] = (err2, ...cbArgs) => {
        if (err2) return reject2(err2);
        resolve2(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
      };
      asyncFn.apply(this, args);
    });
  }
  return awaitable;
}
function applyEach$1(eachfn) {
  return function applyEach2(fns, ...callArgs) {
    const go = awaitify(function(callback) {
      var that = this;
      return eachfn(fns, (fn, cb) => {
        wrapAsync(fn).apply(that, callArgs.concat(cb));
      }, callback);
    });
    return go;
  };
}
function _asyncMap(eachfn, arr, iteratee, callback) {
  arr = arr || [];
  var results = [];
  var counter = 0;
  var _iteratee = wrapAsync(iteratee);
  return eachfn(arr, (value, _2, iterCb) => {
    var index2 = counter++;
    _iteratee(value, (err2, v) => {
      results[index2] = v;
      iterCb(err2);
    });
  }, (err2) => {
    callback(err2, results);
  });
}
function isArrayLike$4(value) {
  return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
}
const breakLoop = {};
function once$5(fn) {
  function wrapper(...args) {
    if (fn === null) return;
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  }
  Object.assign(wrapper, fn);
  return wrapper;
}
function getIterator(coll) {
  return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
function createArrayIterator(coll) {
  var i = -1;
  var len = coll.length;
  return function next() {
    return ++i < len ? { value: coll[i], key: i } : null;
  };
}
function createES2015Iterator(iterator) {
  var i = -1;
  return function next() {
    var item = iterator.next();
    if (item.done)
      return null;
    i++;
    return { value: item.value, key: i };
  };
}
function createObjectIterator(obj) {
  var okeys = obj ? Object.keys(obj) : [];
  var i = -1;
  var len = okeys.length;
  return function next() {
    var key = okeys[++i];
    if (key === "__proto__") {
      return next();
    }
    return i < len ? { value: obj[key], key } : null;
  };
}
function createIterator(coll) {
  if (isArrayLike$4(coll)) {
    return createArrayIterator(coll);
  }
  var iterator = getIterator(coll);
  return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
function onlyOnce(fn) {
  return function(...args) {
    if (fn === null) throw new Error("Callback was already called.");
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
function asyncEachOfLimit(generator, limit, iteratee, callback) {
  let done = false;
  let canceled = false;
  let awaiting = false;
  let running = 0;
  let idx = 0;
  function replenish() {
    if (running >= limit || awaiting || done) return;
    awaiting = true;
    generator.next().then(({ value, done: iterDone }) => {
      if (canceled || done) return;
      awaiting = false;
      if (iterDone) {
        done = true;
        if (running <= 0) {
          callback(null);
        }
        return;
      }
      running++;
      iteratee(value, idx, iterateeCallback);
      idx++;
      replenish();
    }).catch(handleError);
  }
  function iterateeCallback(err2, result) {
    running -= 1;
    if (canceled) return;
    if (err2) return handleError(err2);
    if (err2 === false) {
      done = true;
      canceled = true;
      return;
    }
    if (result === breakLoop || done && running <= 0) {
      done = true;
      return callback(null);
    }
    replenish();
  }
  function handleError(err2) {
    if (canceled) return;
    awaiting = false;
    done = true;
    callback(err2);
  }
  replenish();
}
var eachOfLimit$2 = (limit) => {
  return (obj, iteratee, callback) => {
    callback = once$5(callback);
    if (limit <= 0) {
      throw new RangeError("concurrency limit cannot be less than 1");
    }
    if (!obj) {
      return callback(null);
    }
    if (isAsyncGenerator(obj)) {
      return asyncEachOfLimit(obj, limit, iteratee, callback);
    }
    if (isAsyncIterable(obj)) {
      return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
    }
    var nextElem = createIterator(obj);
    var done = false;
    var canceled = false;
    var running = 0;
    var looping = false;
    function iterateeCallback(err2, value) {
      if (canceled) return;
      running -= 1;
      if (err2) {
        done = true;
        callback(err2);
      } else if (err2 === false) {
        done = true;
        canceled = true;
      } else if (value === breakLoop || done && running <= 0) {
        done = true;
        return callback(null);
      } else if (!looping) {
        replenish();
      }
    }
    function replenish() {
      looping = true;
      while (running < limit && !done) {
        var elem = nextElem();
        if (elem === null) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running += 1;
        iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
      }
      looping = false;
    }
    replenish();
  };
};
function eachOfLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
}
var eachOfLimit$1 = awaitify(eachOfLimit, 4);
function eachOfArrayLike(coll, iteratee, callback) {
  callback = once$5(callback);
  var index2 = 0, completed = 0, { length } = coll, canceled = false;
  if (length === 0) {
    callback(null);
  }
  function iteratorCallback(err2, value) {
    if (err2 === false) {
      canceled = true;
    }
    if (canceled === true) return;
    if (err2) {
      callback(err2);
    } else if (++completed === length || value === breakLoop) {
      callback(null);
    }
  }
  for (; index2 < length; index2++) {
    iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
  }
}
function eachOfGeneric(coll, iteratee, callback) {
  return eachOfLimit$1(coll, Infinity, iteratee, callback);
}
function eachOf(coll, iteratee, callback) {
  var eachOfImplementation = isArrayLike$4(coll) ? eachOfArrayLike : eachOfGeneric;
  return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}
var eachOf$1 = awaitify(eachOf, 3);
function map$1(coll, iteratee, callback) {
  return _asyncMap(eachOf$1, coll, iteratee, callback);
}
var map$1$1 = awaitify(map$1, 3);
var applyEach = applyEach$1(map$1$1);
function eachOfSeries(coll, iteratee, callback) {
  return eachOfLimit$1(coll, 1, iteratee, callback);
}
var eachOfSeries$1 = awaitify(eachOfSeries, 3);
function mapSeries(coll, iteratee, callback) {
  return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
var mapSeries$1 = awaitify(mapSeries, 3);
var applyEachSeries = applyEach$1(mapSeries$1);
const PROMISE_SYMBOL = Symbol("promiseCallback");
function promiseCallback() {
  let resolve2, reject2;
  function callback(err2, ...args) {
    if (err2) return reject2(err2);
    resolve2(args.length > 1 ? args : args[0]);
  }
  callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
    resolve2 = res, reject2 = rej;
  });
  return callback;
}
function auto(tasks, concurrency, callback) {
  if (typeof concurrency !== "number") {
    callback = concurrency;
    concurrency = null;
  }
  callback = once$5(callback || promiseCallback());
  var numTasks = Object.keys(tasks).length;
  if (!numTasks) {
    return callback(null);
  }
  if (!concurrency) {
    concurrency = numTasks;
  }
  var results = {};
  var runningTasks = 0;
  var canceled = false;
  var hasError = false;
  var listeners = /* @__PURE__ */ Object.create(null);
  var readyTasks = [];
  var readyToCheck = [];
  var uncheckedDependencies = {};
  Object.keys(tasks).forEach((key) => {
    var task = tasks[key];
    if (!Array.isArray(task)) {
      enqueueTask(key, [task]);
      readyToCheck.push(key);
      return;
    }
    var dependencies = task.slice(0, task.length - 1);
    var remainingDependencies = dependencies.length;
    if (remainingDependencies === 0) {
      enqueueTask(key, task);
      readyToCheck.push(key);
      return;
    }
    uncheckedDependencies[key] = remainingDependencies;
    dependencies.forEach((dependencyName) => {
      if (!tasks[dependencyName]) {
        throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
      }
      addListener(dependencyName, () => {
        remainingDependencies--;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
        }
      });
    });
  });
  checkForDeadlocks();
  processQueue();
  function enqueueTask(key, task) {
    readyTasks.push(() => runTask(key, task));
  }
  function processQueue() {
    if (canceled) return;
    if (readyTasks.length === 0 && runningTasks === 0) {
      return callback(null, results);
    }
    while (readyTasks.length && runningTasks < concurrency) {
      var run = readyTasks.shift();
      run();
    }
  }
  function addListener(taskName, fn) {
    var taskListeners = listeners[taskName];
    if (!taskListeners) {
      taskListeners = listeners[taskName] = [];
    }
    taskListeners.push(fn);
  }
  function taskComplete(taskName) {
    var taskListeners = listeners[taskName] || [];
    taskListeners.forEach((fn) => fn());
    processQueue();
  }
  function runTask(key, task) {
    if (hasError) return;
    var taskCallback = onlyOnce((err2, ...result) => {
      runningTasks--;
      if (err2 === false) {
        canceled = true;
        return;
      }
      if (result.length < 2) {
        [result] = result;
      }
      if (err2) {
        var safeResults = {};
        Object.keys(results).forEach((rkey) => {
          safeResults[rkey] = results[rkey];
        });
        safeResults[key] = result;
        hasError = true;
        listeners = /* @__PURE__ */ Object.create(null);
        if (canceled) return;
        callback(err2, safeResults);
      } else {
        results[key] = result;
        taskComplete(key);
      }
    });
    runningTasks++;
    var taskFn = wrapAsync(task[task.length - 1]);
    if (task.length > 1) {
      taskFn(results, taskCallback);
    } else {
      taskFn(taskCallback);
    }
  }
  function checkForDeadlocks() {
    var currentTask;
    var counter = 0;
    while (readyToCheck.length) {
      currentTask = readyToCheck.pop();
      counter++;
      getDependents(currentTask).forEach((dependent) => {
        if (--uncheckedDependencies[dependent] === 0) {
          readyToCheck.push(dependent);
        }
      });
    }
    if (counter !== numTasks) {
      throw new Error(
        "async.auto cannot execute tasks due to a recursive dependency"
      );
    }
  }
  function getDependents(taskName) {
    var result = [];
    Object.keys(tasks).forEach((key) => {
      const task = tasks[key];
      if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
        result.push(key);
      }
    });
    return result;
  }
  return callback[PROMISE_SYMBOL];
}
var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;
function stripComments(string) {
  let stripped = "";
  let index2 = 0;
  let endBlockComment = string.indexOf("*/");
  while (index2 < string.length) {
    if (string[index2] === "/" && string[index2 + 1] === "/") {
      let endIndex = string.indexOf("\n", index2);
      index2 = endIndex === -1 ? string.length : endIndex;
    } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
      let endIndex = string.indexOf("*/", index2);
      if (endIndex !== -1) {
        index2 = endIndex + 2;
        endBlockComment = string.indexOf("*/", index2);
      } else {
        stripped += string[index2];
        index2++;
      }
    } else {
      stripped += string[index2];
      index2++;
    }
  }
  return stripped;
}
function parseParams(func) {
  const src2 = stripComments(func.toString());
  let match2 = src2.match(FN_ARGS);
  if (!match2) {
    match2 = src2.match(ARROW_FN_ARGS);
  }
  if (!match2) throw new Error("could not parse args in autoInject\nSource:\n" + src2);
  let [, args] = match2;
  return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
}
function autoInject(tasks, callback) {
  var newTasks = {};
  Object.keys(tasks).forEach((key) => {
    var taskFn = tasks[key];
    var params;
    var fnIsAsync = isAsync(taskFn);
    var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
    if (Array.isArray(taskFn)) {
      params = [...taskFn];
      taskFn = params.pop();
      newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
    } else if (hasNoDeps) {
      newTasks[key] = taskFn;
    } else {
      params = parseParams(taskFn);
      if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
        throw new Error("autoInject task functions require explicit parameters.");
      }
      if (!fnIsAsync) params.pop();
      newTasks[key] = params.concat(newTask);
    }
    function newTask(results, taskCb) {
      var newArgs = params.map((name) => results[name]);
      newArgs.push(taskCb);
      wrapAsync(taskFn)(...newArgs);
    }
  });
  return auto(newTasks, callback);
}
class DLL {
  constructor() {
    this.head = this.tail = null;
    this.length = 0;
  }
  removeLink(node2) {
    if (node2.prev) node2.prev.next = node2.next;
    else this.head = node2.next;
    if (node2.next) node2.next.prev = node2.prev;
    else this.tail = node2.prev;
    node2.prev = node2.next = null;
    this.length -= 1;
    return node2;
  }
  empty() {
    while (this.head) this.shift();
    return this;
  }
  insertAfter(node2, newNode) {
    newNode.prev = node2;
    newNode.next = node2.next;
    if (node2.next) node2.next.prev = newNode;
    else this.tail = newNode;
    node2.next = newNode;
    this.length += 1;
  }
  insertBefore(node2, newNode) {
    newNode.prev = node2.prev;
    newNode.next = node2;
    if (node2.prev) node2.prev.next = newNode;
    else this.head = newNode;
    node2.prev = newNode;
    this.length += 1;
  }
  unshift(node2) {
    if (this.head) this.insertBefore(this.head, node2);
    else setInitial(this, node2);
  }
  push(node2) {
    if (this.tail) this.insertAfter(this.tail, node2);
    else setInitial(this, node2);
  }
  shift() {
    return this.head && this.removeLink(this.head);
  }
  pop() {
    return this.tail && this.removeLink(this.tail);
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    var cur = this.head;
    while (cur) {
      yield cur.data;
      cur = cur.next;
    }
  }
  remove(testFn) {
    var curr = this.head;
    while (curr) {
      var { next } = curr;
      if (testFn(curr)) {
        this.removeLink(curr);
      }
      curr = next;
    }
    return this;
  }
}
function setInitial(dll, node2) {
  dll.length = 1;
  dll.head = dll.tail = node2;
}
function queue$1$1(worker, concurrency, payload) {
  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new RangeError("Concurrency must not be zero");
  }
  var _worker = wrapAsync(worker);
  var numRunning = 0;
  var workersList = [];
  const events2 = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };
  function on(event, handler) {
    events2[event].push(handler);
  }
  function once2(event, handler) {
    const handleAndRemove = (...args) => {
      off(event, handleAndRemove);
      handler(...args);
    };
    events2[event].push(handleAndRemove);
  }
  function off(event, handler) {
    if (!event) return Object.keys(events2).forEach((ev) => events2[ev] = []);
    if (!handler) return events2[event] = [];
    events2[event] = events2[event].filter((ev) => ev !== handler);
  }
  function trigger(event, ...args) {
    events2[event].forEach((handler) => handler(...args));
  }
  var processingScheduled = false;
  function _insert(data, insertAtFront, rejectOnError, callback) {
    if (callback != null && typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    var res, rej;
    function promiseCallback2(err2, ...args) {
      if (err2) return rejectOnError ? rej(err2) : res();
      if (args.length <= 1) return res(args[0]);
      res(args);
    }
    var item = q._createTaskItem(
      data,
      rejectOnError ? promiseCallback2 : callback || promiseCallback2
    );
    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }
    if (!processingScheduled) {
      processingScheduled = true;
      setImmediate$1(() => {
        processingScheduled = false;
        q.process();
      });
    }
    if (rejectOnError || !callback) {
      return new Promise((resolve2, reject2) => {
        res = resolve2;
        rej = reject2;
      });
    }
  }
  function _createCB(tasks) {
    return function(err2, ...args) {
      numRunning -= 1;
      for (var i = 0, l = tasks.length; i < l; i++) {
        var task = tasks[i];
        var index2 = workersList.indexOf(task);
        if (index2 === 0) {
          workersList.shift();
        } else if (index2 > 0) {
          workersList.splice(index2, 1);
        }
        task.callback(err2, ...args);
        if (err2 != null) {
          trigger("error", err2, task.data);
        }
      }
      if (numRunning <= q.concurrency - q.buffer) {
        trigger("unsaturated");
      }
      if (q.idle()) {
        trigger("drain");
      }
      q.process();
    };
  }
  function _maybeDrain(data) {
    if (data.length === 0 && q.idle()) {
      setImmediate$1(() => trigger("drain"));
      return true;
    }
    return false;
  }
  const eventMethod = (name) => (handler) => {
    if (!handler) {
      return new Promise((resolve2, reject2) => {
        once2(name, (err2, data) => {
          if (err2) return reject2(err2);
          resolve2(data);
        });
      });
    }
    off(name);
    on(name, handler);
  };
  var isProcessing = false;
  var q = {
    _tasks: new DLL(),
    _createTaskItem(data, callback) {
      return {
        data,
        callback
      };
    },
    *[Symbol.iterator]() {
      yield* q._tasks[Symbol.iterator]();
    },
    concurrency,
    payload,
    buffer: concurrency / 4,
    started: false,
    paused: false,
    push(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, false, false, callback));
      }
      return _insert(data, false, false, callback);
    },
    pushAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, false, true, callback));
      }
      return _insert(data, false, true, callback);
    },
    kill() {
      off();
      q._tasks.empty();
    },
    unshift(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, true, false, callback));
      }
      return _insert(data, true, false, callback);
    },
    unshiftAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data)) return;
        return data.map((datum) => _insert(datum, true, true, callback));
      }
      return _insert(data, true, true, callback);
    },
    remove(testFn) {
      q._tasks.remove(testFn);
    },
    process() {
      if (isProcessing) {
        return;
      }
      isProcessing = true;
      while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
        var tasks = [], data = [];
        var l = q._tasks.length;
        if (q.payload) l = Math.min(l, q.payload);
        for (var i = 0; i < l; i++) {
          var node2 = q._tasks.shift();
          tasks.push(node2);
          workersList.push(node2);
          data.push(node2.data);
        }
        numRunning += 1;
        if (q._tasks.length === 0) {
          trigger("empty");
        }
        if (numRunning === q.concurrency) {
          trigger("saturated");
        }
        var cb = onlyOnce(_createCB(tasks));
        _worker(data, cb);
      }
      isProcessing = false;
    },
    length() {
      return q._tasks.length;
    },
    running() {
      return numRunning;
    },
    workersList() {
      return workersList;
    },
    idle() {
      return q._tasks.length + numRunning === 0;
    },
    pause() {
      q.paused = true;
    },
    resume() {
      if (q.paused === false) {
        return;
      }
      q.paused = false;
      setImmediate$1(q.process);
    }
  };
  Object.defineProperties(q, {
    saturated: {
      writable: false,
      value: eventMethod("saturated")
    },
    unsaturated: {
      writable: false,
      value: eventMethod("unsaturated")
    },
    empty: {
      writable: false,
      value: eventMethod("empty")
    },
    drain: {
      writable: false,
      value: eventMethod("drain")
    },
    error: {
      writable: false,
      value: eventMethod("error")
    }
  });
  return q;
}
function cargo$1(worker, payload) {
  return queue$1$1(worker, 1, payload);
}
function cargo(worker, concurrency, payload) {
  return queue$1$1(worker, concurrency, payload);
}
function reduce$1(coll, memo, iteratee, callback) {
  callback = once$5(callback);
  var _iteratee = wrapAsync(iteratee);
  return eachOfSeries$1(coll, (x, i, iterCb) => {
    _iteratee(memo, x, (err2, v) => {
      memo = v;
      iterCb(err2);
    });
  }, (err2) => callback(err2, memo));
}
var reduce$1$1 = awaitify(reduce$1, 4);
function seq(...functions) {
  var _functions = functions.map(wrapAsync);
  return function(...args) {
    var that = this;
    var cb = args[args.length - 1];
    if (typeof cb == "function") {
      args.pop();
    } else {
      cb = promiseCallback();
    }
    reduce$1$1(
      _functions,
      args,
      (newargs, fn, iterCb) => {
        fn.apply(that, newargs.concat((err2, ...nextargs) => {
          iterCb(err2, nextargs);
        }));
      },
      (err2, results) => cb(err2, ...results)
    );
    return cb[PROMISE_SYMBOL];
  };
}
function compose(...args) {
  return seq(...args.reverse());
}
function mapLimit(coll, limit, iteratee, callback) {
  return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
}
var mapLimit$1 = awaitify(mapLimit, 4);
function concatLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err2, ...args) => {
      if (err2) return iterCb(err2);
      return iterCb(err2, args);
    });
  }, (err2, mapResults) => {
    var result = [];
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        result = result.concat(...mapResults[i]);
      }
    }
    return callback(err2, result);
  });
}
var concatLimit$1 = awaitify(concatLimit, 4);
function concat(coll, iteratee, callback) {
  return concatLimit$1(coll, Infinity, iteratee, callback);
}
var concat$1 = awaitify(concat, 3);
function concatSeries(coll, iteratee, callback) {
  return concatLimit$1(coll, 1, iteratee, callback);
}
var concatSeries$1 = awaitify(concatSeries, 3);
function constant$1(...args) {
  return function(...ignoredArgs) {
    var callback = ignoredArgs.pop();
    return callback(null, ...args);
  };
}
function _createTester(check, getResult) {
  return (eachfn, arr, _iteratee, cb) => {
    var testPassed = false;
    var testResult;
    const iteratee = wrapAsync(_iteratee);
    eachfn(arr, (value, _2, callback) => {
      iteratee(value, (err2, result) => {
        if (err2 || err2 === false) return callback(err2);
        if (check(result) && !testResult) {
          testPassed = true;
          testResult = getResult(true, value);
          return callback(null, breakLoop);
        }
        callback();
      });
    }, (err2) => {
      if (err2) return cb(err2);
      cb(null, testPassed ? testResult : getResult(false));
    });
  };
}
function detect(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
var detect$1 = awaitify(detect, 3);
function detectLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var detectLimit$1 = awaitify(detectLimit, 4);
function detectSeries(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
}
var detectSeries$1 = awaitify(detectSeries, 3);
function consoleFunc(name) {
  return (fn, ...args) => wrapAsync(fn)(...args, (err2, ...resultArgs) => {
    if (typeof console === "object") {
      if (err2) {
        if (console.error) {
          console.error(err2);
        }
      } else if (console[name]) {
        resultArgs.forEach((x) => console[name](x));
      }
    }
  });
}
var dir = consoleFunc("dir");
function doWhilst(iteratee, test, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results;
  function next(err2, ...args) {
    if (err2) return callback(err2);
    if (err2 === false) return;
    results = args;
    _test(...args, check);
  }
  function check(err2, truth) {
    if (err2) return callback(err2);
    if (err2 === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next);
  }
  return check(null, true);
}
var doWhilst$1 = awaitify(doWhilst, 3);
function doUntil(iteratee, test, callback) {
  const _test = wrapAsync(test);
  return doWhilst$1(iteratee, (...args) => {
    const cb = args.pop();
    _test(...args, (err2, truth) => cb(err2, !truth));
  }, callback);
}
function _withoutIndex(iteratee) {
  return (value, index2, callback) => iteratee(value, callback);
}
function eachLimit$2(coll, iteratee, callback) {
  return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var each$1 = awaitify(eachLimit$2, 3);
function eachLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var eachLimit$1 = awaitify(eachLimit, 4);
function eachSeries(coll, iteratee, callback) {
  return eachLimit$1(coll, 1, iteratee, callback);
}
var eachSeries$1 = awaitify(eachSeries, 3);
function ensureAsync(fn) {
  if (isAsync(fn)) return fn;
  return function(...args) {
    var callback = args.pop();
    var sync3 = true;
    args.push((...innerArgs) => {
      if (sync3) {
        setImmediate$1(() => callback(...innerArgs));
      } else {
        callback(...innerArgs);
      }
    });
    fn.apply(this, args);
    sync3 = false;
  };
}
function every2(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
var every$1 = awaitify(every2, 3);
function everyLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var everyLimit$1 = awaitify(everyLimit, 4);
function everySeries(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
var everySeries$1 = awaitify(everySeries, 3);
function filterArray(eachfn, arr, iteratee, callback) {
  var truthValues = new Array(arr.length);
  eachfn(arr, (x, index2, iterCb) => {
    iteratee(x, (err2, v) => {
      truthValues[index2] = !!v;
      iterCb(err2);
    });
  }, (err2) => {
    if (err2) return callback(err2);
    var results = [];
    for (var i = 0; i < arr.length; i++) {
      if (truthValues[i]) results.push(arr[i]);
    }
    callback(null, results);
  });
}
function filterGeneric(eachfn, coll, iteratee, callback) {
  var results = [];
  eachfn(coll, (x, index2, iterCb) => {
    iteratee(x, (err2, v) => {
      if (err2) return iterCb(err2);
      if (v) {
        results.push({ index: index2, value: x });
      }
      iterCb(err2);
    });
  }, (err2) => {
    if (err2) return callback(err2);
    callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
  });
}
function _filter(eachfn, coll, iteratee, callback) {
  var filter2 = isArrayLike$4(coll) ? filterArray : filterGeneric;
  return filter2(eachfn, coll, wrapAsync(iteratee), callback);
}
function filter$2(coll, iteratee, callback) {
  return _filter(eachOf$1, coll, iteratee, callback);
}
var filter$1$1 = awaitify(filter$2, 3);
function filterLimit(coll, limit, iteratee, callback) {
  return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
}
var filterLimit$1 = awaitify(filterLimit, 4);
function filterSeries(coll, iteratee, callback) {
  return _filter(eachOfSeries$1, coll, iteratee, callback);
}
var filterSeries$1 = awaitify(filterSeries, 3);
function forever(fn, errback) {
  var done = onlyOnce(errback);
  var task = wrapAsync(ensureAsync(fn));
  function next(err2) {
    if (err2) return done(err2);
    if (err2 === false) return;
    task(next);
  }
  return next();
}
var forever$1 = awaitify(forever, 2);
function groupByLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err2, key) => {
      if (err2) return iterCb(err2);
      return iterCb(err2, { key, val });
    });
  }, (err2, mapResults) => {
    var result = {};
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        var { key } = mapResults[i];
        var { val } = mapResults[i];
        if (hasOwnProperty2.call(result, key)) {
          result[key].push(val);
        } else {
          result[key] = [val];
        }
      }
    }
    return callback(err2, result);
  });
}
var groupByLimit$1 = awaitify(groupByLimit, 4);
function groupBy(coll, iteratee, callback) {
  return groupByLimit$1(coll, Infinity, iteratee, callback);
}
function groupBySeries(coll, iteratee, callback) {
  return groupByLimit$1(coll, 1, iteratee, callback);
}
var log = consoleFunc("log");
function mapValuesLimit(obj, limit, iteratee, callback) {
  callback = once$5(callback);
  var newObj = {};
  var _iteratee = wrapAsync(iteratee);
  return eachOfLimit$2(limit)(obj, (val, key, next) => {
    _iteratee(val, key, (err2, result) => {
      if (err2) return next(err2);
      newObj[key] = result;
      next(err2);
    });
  }, (err2) => callback(err2, newObj));
}
var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
function mapValues(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, Infinity, iteratee, callback);
}
function mapValuesSeries(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, 1, iteratee, callback);
}
function memoize(fn, hasher = (v) => v) {
  var memo = /* @__PURE__ */ Object.create(null);
  var queues = /* @__PURE__ */ Object.create(null);
  var _fn = wrapAsync(fn);
  var memoized = initialParams((args, callback) => {
    var key = hasher(...args);
    if (key in memo) {
      setImmediate$1(() => callback(null, ...memo[key]));
    } else if (key in queues) {
      queues[key].push(callback);
    } else {
      queues[key] = [callback];
      _fn(...args, (err2, ...resultArgs) => {
        if (!err2) {
          memo[key] = resultArgs;
        }
        var q = queues[key];
        delete queues[key];
        for (var i = 0, l = q.length; i < l; i++) {
          q[i](err2, ...resultArgs);
        }
      });
    }
  });
  memoized.memo = memo;
  memoized.unmemoized = fn;
  return memoized;
}
var _defer;
if (hasNextTick) {
  _defer = process.nextTick;
} else if (hasSetImmediate) {
  _defer = setImmediate;
} else {
  _defer = fallback;
}
var nextTick = wrap(_defer);
var _parallel = awaitify((eachfn, tasks, callback) => {
  var results = isArrayLike$4(tasks) ? [] : {};
  eachfn(tasks, (task, key, taskCb) => {
    wrapAsync(task)((err2, ...result) => {
      if (result.length < 2) {
        [result] = result;
      }
      results[key] = result;
      taskCb(err2);
    });
  }, (err2) => callback(err2, results));
}, 3);
function parallel(tasks, callback) {
  return _parallel(eachOf$1, tasks, callback);
}
function parallelLimit(tasks, limit, callback) {
  return _parallel(eachOfLimit$2(limit), tasks, callback);
}
function queue$2(worker, concurrency) {
  var _worker = wrapAsync(worker);
  return queue$1$1((items, cb) => {
    _worker(items[0], cb);
  }, concurrency, 1);
}
class Heap {
  constructor() {
    this.heap = [];
    this.pushCount = Number.MIN_SAFE_INTEGER;
  }
  get length() {
    return this.heap.length;
  }
  empty() {
    this.heap = [];
    return this;
  }
  percUp(index2) {
    let p;
    while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
      let t = this.heap[index2];
      this.heap[index2] = this.heap[p];
      this.heap[p] = t;
      index2 = p;
    }
  }
  percDown(index2) {
    let l;
    while ((l = leftChi(index2)) < this.heap.length) {
      if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
        l = l + 1;
      }
      if (smaller(this.heap[index2], this.heap[l])) {
        break;
      }
      let t = this.heap[index2];
      this.heap[index2] = this.heap[l];
      this.heap[l] = t;
      index2 = l;
    }
  }
  push(node2) {
    node2.pushCount = ++this.pushCount;
    this.heap.push(node2);
    this.percUp(this.heap.length - 1);
  }
  unshift(node2) {
    return this.heap.push(node2);
  }
  shift() {
    let [top] = this.heap;
    this.heap[0] = this.heap[this.heap.length - 1];
    this.heap.pop();
    this.percDown(0);
    return top;
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.heap.length; i++) {
      yield this.heap[i].data;
    }
  }
  remove(testFn) {
    let j = 0;
    for (let i = 0; i < this.heap.length; i++) {
      if (!testFn(this.heap[i])) {
        this.heap[j] = this.heap[i];
        j++;
      }
    }
    this.heap.splice(j);
    for (let i = parent(this.heap.length - 1); i >= 0; i--) {
      this.percDown(i);
    }
    return this;
  }
}
function leftChi(i) {
  return (i << 1) + 1;
}
function parent(i) {
  return (i + 1 >> 1) - 1;
}
function smaller(x, y) {
  if (x.priority !== y.priority) {
    return x.priority < y.priority;
  } else {
    return x.pushCount < y.pushCount;
  }
}
function priorityQueue(worker, concurrency) {
  var q = queue$2(worker, concurrency);
  var {
    push,
    pushAsync
  } = q;
  q._tasks = new Heap();
  q._createTaskItem = ({ data, priority }, callback) => {
    return {
      data,
      priority,
      callback
    };
  };
  function createDataItems(tasks, priority) {
    if (!Array.isArray(tasks)) {
      return { data: tasks, priority };
    }
    return tasks.map((data) => {
      return { data, priority };
    });
  }
  q.push = function(data, priority = 0, callback) {
    return push(createDataItems(data, priority), callback);
  };
  q.pushAsync = function(data, priority = 0, callback) {
    return pushAsync(createDataItems(data, priority), callback);
  };
  delete q.unshift;
  delete q.unshiftAsync;
  return q;
}
function race$1(tasks, callback) {
  callback = once$5(callback);
  if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
  if (!tasks.length) return callback();
  for (var i = 0, l = tasks.length; i < l; i++) {
    wrapAsync(tasks[i])(callback);
  }
}
var race$1$1 = awaitify(race$1, 2);
function reduceRight(array, memo, iteratee, callback) {
  var reversed = [...array].reverse();
  return reduce$1$1(reversed, memo, iteratee, callback);
}
function reflect(fn) {
  var _fn = wrapAsync(fn);
  return initialParams(function reflectOn(args, reflectCallback) {
    args.push((error2, ...cbArgs) => {
      let retVal = {};
      if (error2) {
        retVal.error = error2;
      }
      if (cbArgs.length > 0) {
        var value = cbArgs;
        if (cbArgs.length <= 1) {
          [value] = cbArgs;
        }
        retVal.value = value;
      }
      reflectCallback(null, retVal);
    });
    return _fn.apply(this, args);
  });
}
function reflectAll(tasks) {
  var results;
  if (Array.isArray(tasks)) {
    results = tasks.map(reflect);
  } else {
    results = {};
    Object.keys(tasks).forEach((key) => {
      results[key] = reflect.call(this, tasks[key]);
    });
  }
  return results;
}
function reject$2(eachfn, arr, _iteratee, callback) {
  const iteratee = wrapAsync(_iteratee);
  return _filter(eachfn, arr, (value, cb) => {
    iteratee(value, (err2, v) => {
      cb(err2, !v);
    });
  }, callback);
}
function reject(coll, iteratee, callback) {
  return reject$2(eachOf$1, coll, iteratee, callback);
}
var reject$1 = awaitify(reject, 3);
function rejectLimit(coll, limit, iteratee, callback) {
  return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
}
var rejectLimit$1 = awaitify(rejectLimit, 4);
function rejectSeries(coll, iteratee, callback) {
  return reject$2(eachOfSeries$1, coll, iteratee, callback);
}
var rejectSeries$1 = awaitify(rejectSeries, 3);
function constant(value) {
  return function() {
    return value;
  };
}
const DEFAULT_TIMES = 5;
const DEFAULT_INTERVAL = 0;
function retry$1(opts, task, callback) {
  var options = {
    times: DEFAULT_TIMES,
    intervalFunc: constant(DEFAULT_INTERVAL)
  };
  if (arguments.length < 3 && typeof opts === "function") {
    callback = task || promiseCallback();
    task = opts;
  } else {
    parseTimes(options, opts);
    callback = callback || promiseCallback();
  }
  if (typeof task !== "function") {
    throw new Error("Invalid arguments for async.retry");
  }
  var _task = wrapAsync(task);
  var attempt = 1;
  function retryAttempt() {
    _task((err2, ...args) => {
      if (err2 === false) return;
      if (err2 && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err2))) {
        setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
      } else {
        callback(err2, ...args);
      }
    });
  }
  retryAttempt();
  return callback[PROMISE_SYMBOL];
}
function parseTimes(acc, t) {
  if (typeof t === "object") {
    acc.times = +t.times || DEFAULT_TIMES;
    acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
    acc.errorFilter = t.errorFilter;
  } else if (typeof t === "number" || typeof t === "string") {
    acc.times = +t || DEFAULT_TIMES;
  } else {
    throw new Error("Invalid arguments for async.retry");
  }
}
function retryable(opts, task) {
  if (!task) {
    task = opts;
    opts = null;
  }
  let arity = opts && opts.arity || task.length;
  if (isAsync(task)) {
    arity += 1;
  }
  var _task = wrapAsync(task);
  return initialParams((args, callback) => {
    if (args.length < arity - 1 || callback == null) {
      args.push(callback);
      callback = promiseCallback();
    }
    function taskFn(cb) {
      _task(...args, cb);
    }
    if (opts) retry$1(opts, taskFn, callback);
    else retry$1(taskFn, callback);
    return callback[PROMISE_SYMBOL];
  });
}
function series(tasks, callback) {
  return _parallel(eachOfSeries$1, tasks, callback);
}
function some$1(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
var some$1$1 = awaitify(some$1, 3);
function someLimit(coll, limit, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var someLimit$1 = awaitify(someLimit, 4);
function someSeries(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
var someSeries$1 = awaitify(someSeries, 3);
function sortBy(coll, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return map$1$1(coll, (x, iterCb) => {
    _iteratee(x, (err2, criteria) => {
      if (err2) return iterCb(err2);
      iterCb(err2, { value: x, criteria });
    });
  }, (err2, results) => {
    if (err2) return callback(err2);
    callback(null, results.sort(comparator).map((v) => v.value));
  });
  function comparator(left, right) {
    var a = left.criteria, b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }
}
var sortBy$1 = awaitify(sortBy, 3);
function timeout$1(asyncFn, milliseconds, info) {
  var fn = wrapAsync(asyncFn);
  return initialParams((args, callback) => {
    var timedOut = false;
    var timer;
    function timeoutCallback() {
      var name = asyncFn.name || "anonymous";
      var error2 = new Error('Callback function "' + name + '" timed out.');
      error2.code = "ETIMEDOUT";
      if (info) {
        error2.info = info;
      }
      timedOut = true;
      callback(error2);
    }
    args.push((...cbArgs) => {
      if (!timedOut) {
        callback(...cbArgs);
        clearTimeout(timer);
      }
    });
    timer = setTimeout(timeoutCallback, milliseconds);
    fn(...args);
  });
}
function range(size) {
  var result = Array(size);
  while (size--) {
    result[size] = size;
  }
  return result;
}
function timesLimit(count, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(range(count), limit, _iteratee, callback);
}
function times(n, iteratee, callback) {
  return timesLimit(n, Infinity, iteratee, callback);
}
function timesSeries(n, iteratee, callback) {
  return timesLimit(n, 1, iteratee, callback);
}
function transform(coll, accumulator, iteratee, callback) {
  if (arguments.length <= 3 && typeof accumulator === "function") {
    callback = iteratee;
    iteratee = accumulator;
    accumulator = Array.isArray(coll) ? [] : {};
  }
  callback = once$5(callback || promiseCallback());
  var _iteratee = wrapAsync(iteratee);
  eachOf$1(coll, (v, k, cb) => {
    _iteratee(accumulator, v, k, cb);
  }, (err2) => callback(err2, accumulator));
  return callback[PROMISE_SYMBOL];
}
function tryEach(tasks, callback) {
  var error2 = null;
  var result;
  return eachSeries$1(tasks, (task, taskCb) => {
    wrapAsync(task)((err2, ...args) => {
      if (err2 === false) return taskCb(err2);
      if (args.length < 2) {
        [result] = args;
      } else {
        result = args;
      }
      error2 = err2;
      taskCb(err2 ? null : {});
    });
  }, () => callback(error2, result));
}
var tryEach$1 = awaitify(tryEach);
function unmemoize(fn) {
  return (...args) => {
    return (fn.unmemoized || fn)(...args);
  };
}
function whilst(test, iteratee, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results = [];
  function next(err2, ...rest) {
    if (err2) return callback(err2);
    results = rest;
    if (err2 === false) return;
    _test(check);
  }
  function check(err2, truth) {
    if (err2) return callback(err2);
    if (err2 === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next);
  }
  return _test(check);
}
var whilst$1 = awaitify(whilst, 3);
function until(test, iteratee, callback) {
  const _test = wrapAsync(test);
  return whilst$1((cb) => _test((err2, truth) => cb(err2, !truth)), iteratee, callback);
}
function waterfall(tasks, callback) {
  callback = once$5(callback);
  if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
  if (!tasks.length) return callback();
  var taskIndex = 0;
  function nextTask(args) {
    var task = wrapAsync(tasks[taskIndex++]);
    task(...args, onlyOnce(next));
  }
  function next(err2, ...args) {
    if (err2 === false) return;
    if (err2 || taskIndex === tasks.length) {
      return callback(err2, ...args);
    }
    nextTask(args);
  }
  nextTask([]);
}
var waterfall$1 = awaitify(waterfall);
var index = {
  apply: apply$3,
  applyEach,
  applyEachSeries,
  asyncify,
  auto,
  autoInject,
  cargo: cargo$1,
  cargoQueue: cargo,
  compose,
  concat: concat$1,
  concatLimit: concatLimit$1,
  concatSeries: concatSeries$1,
  constant: constant$1,
  detect: detect$1,
  detectLimit: detectLimit$1,
  detectSeries: detectSeries$1,
  dir,
  doUntil,
  doWhilst: doWhilst$1,
  each: each$1,
  eachLimit: eachLimit$1,
  eachOf: eachOf$1,
  eachOfLimit: eachOfLimit$1,
  eachOfSeries: eachOfSeries$1,
  eachSeries: eachSeries$1,
  ensureAsync,
  every: every$1,
  everyLimit: everyLimit$1,
  everySeries: everySeries$1,
  filter: filter$1$1,
  filterLimit: filterLimit$1,
  filterSeries: filterSeries$1,
  forever: forever$1,
  groupBy,
  groupByLimit: groupByLimit$1,
  groupBySeries,
  log,
  map: map$1$1,
  mapLimit: mapLimit$1,
  mapSeries: mapSeries$1,
  mapValues,
  mapValuesLimit: mapValuesLimit$1,
  mapValuesSeries,
  memoize,
  nextTick,
  parallel,
  parallelLimit,
  priorityQueue,
  queue: queue$2,
  race: race$1$1,
  reduce: reduce$1$1,
  reduceRight,
  reflect,
  reflectAll,
  reject: reject$1,
  rejectLimit: rejectLimit$1,
  rejectSeries: rejectSeries$1,
  retry: retry$1,
  retryable,
  seq,
  series,
  setImmediate: setImmediate$1,
  some: some$1$1,
  someLimit: someLimit$1,
  someSeries: someSeries$1,
  sortBy: sortBy$1,
  timeout: timeout$1,
  times,
  timesLimit,
  timesSeries,
  transform,
  tryEach: tryEach$1,
  unmemoize,
  until,
  waterfall: waterfall$1,
  whilst: whilst$1,
  // aliases
  all: every$1,
  allLimit: everyLimit$1,
  allSeries: everySeries$1,
  any: some$1$1,
  anyLimit: someLimit$1,
  anySeries: someSeries$1,
  find: detect$1,
  findLimit: detectLimit$1,
  findSeries: detectSeries$1,
  flatMap: concat$1,
  flatMapLimit: concatLimit$1,
  flatMapSeries: concatSeries$1,
  forEach: each$1,
  forEachSeries: eachSeries$1,
  forEachLimit: eachLimit$1,
  forEachOf: eachOf$1,
  forEachOfSeries: eachOfSeries$1,
  forEachOfLimit: eachOfLimit$1,
  inject: reduce$1$1,
  foldl: reduce$1$1,
  foldr: reduceRight,
  select: filter$1$1,
  selectLimit: filterLimit$1,
  selectSeries: filterSeries$1,
  wrapSync: asyncify,
  during: whilst$1,
  doDuring: doWhilst$1
};
const async$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  all: every$1,
  allLimit: everyLimit$1,
  allSeries: everySeries$1,
  any: some$1$1,
  anyLimit: someLimit$1,
  anySeries: someSeries$1,
  apply: apply$3,
  applyEach,
  applyEachSeries,
  asyncify,
  auto,
  autoInject,
  cargo: cargo$1,
  cargoQueue: cargo,
  compose,
  concat: concat$1,
  concatLimit: concatLimit$1,
  concatSeries: concatSeries$1,
  constant: constant$1,
  default: index,
  detect: detect$1,
  detectLimit: detectLimit$1,
  detectSeries: detectSeries$1,
  dir,
  doDuring: doWhilst$1,
  doUntil,
  doWhilst: doWhilst$1,
  during: whilst$1,
  each: each$1,
  eachLimit: eachLimit$1,
  eachOf: eachOf$1,
  eachOfLimit: eachOfLimit$1,
  eachOfSeries: eachOfSeries$1,
  eachSeries: eachSeries$1,
  ensureAsync,
  every: every$1,
  everyLimit: everyLimit$1,
  everySeries: everySeries$1,
  filter: filter$1$1,
  filterLimit: filterLimit$1,
  filterSeries: filterSeries$1,
  find: detect$1,
  findLimit: detectLimit$1,
  findSeries: detectSeries$1,
  flatMap: concat$1,
  flatMapLimit: concatLimit$1,
  flatMapSeries: concatSeries$1,
  foldl: reduce$1$1,
  foldr: reduceRight,
  forEach: each$1,
  forEachLimit: eachLimit$1,
  forEachOf: eachOf$1,
  forEachOfLimit: eachOfLimit$1,
  forEachOfSeries: eachOfSeries$1,
  forEachSeries: eachSeries$1,
  forever: forever$1,
  groupBy,
  groupByLimit: groupByLimit$1,
  groupBySeries,
  inject: reduce$1$1,
  log,
  map: map$1$1,
  mapLimit: mapLimit$1,
  mapSeries: mapSeries$1,
  mapValues,
  mapValuesLimit: mapValuesLimit$1,
  mapValuesSeries,
  memoize,
  nextTick,
  parallel,
  parallelLimit,
  priorityQueue,
  queue: queue$2,
  race: race$1$1,
  reduce: reduce$1$1,
  reduceRight,
  reflect,
  reflectAll,
  reject: reject$1,
  rejectLimit: rejectLimit$1,
  rejectSeries: rejectSeries$1,
  retry: retry$1,
  retryable,
  select: filter$1$1,
  selectLimit: filterLimit$1,
  selectSeries: filterSeries$1,
  seq,
  series,
  setImmediate: setImmediate$1,
  some: some$1$1,
  someLimit: someLimit$1,
  someSeries: someSeries$1,
  sortBy: sortBy$1,
  timeout: timeout$1,
  times,
  timesLimit,
  timesSeries,
  transform,
  tryEach: tryEach$1,
  unmemoize,
  until,
  waterfall: waterfall$1,
  whilst: whilst$1,
  wrapSync: asyncify
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(async$2);
var archiverUtils$1 = { exports: {} };
var constants$4 = require$$0$6;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$1;
function patch$1(fs2) {
  if (constants$4.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (fs2.chown && !fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
      function rename(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
      return rename;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _2, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs22) {
    fs22.lchmod = function(path2, mode, callback) {
      fs22.open(
        path2,
        constants$4.O_WRONLY | constants$4.O_SYMLINK,
        mode,
        function(err2, fd) {
          if (err2) {
            if (callback) callback(err2);
            return;
          }
          fs22.fchmod(fd, mode, function(err22) {
            fs22.close(fd, function(err222) {
              if (callback) callback(err22 || err222);
            });
          });
        }
      );
    };
    fs22.lchmodSync = function(path2, mode) {
      var fd = fs22.openSync(path2, constants$4.O_WRONLY | constants$4.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs22.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs22.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs22.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs22) {
    if (constants$4.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
      fs22.lutimes = function(path2, at, mt, cb) {
        fs22.open(path2, constants$4.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb) cb(er);
            return;
          }
          fs22.futimes(fd, at, mt, function(er2) {
            fs22.close(fd, function(er22) {
              if (cb) cb(er2 || er22);
            });
          });
        });
      };
      fs22.lutimesSync = function(path2, at, mt) {
        var fd = fs22.openSync(path2, constants$4.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs22.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    } else if (fs22.futimes) {
      fs22.lutimes = function(_a, _b, _c, cb) {
        if (cb) process.nextTick(cb);
      };
      fs22.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig) return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig) return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig) return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig) return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig) return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig) return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats) {
        if (stats.uid < 0) stats.uid += 4294967296;
        if (stats.gid < 0) stats.gid += 4294967296;
      }
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream$c = require$$0$1.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path2, options);
    Stream$c.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index2 = 0, length = keys.length; index2 < length; index2++) {
      var key = keys[index2];
      this[key] = options[key];
    }
    if (this.encoding) this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err2, fd) {
      if (err2) {
        self2.emit("error", err2);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path2, options);
    Stream$c.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index2 = 0, length = keys.length; index2 < length; index2++) {
      var key = keys[index2];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy3 = { __proto__: getPrototypeOf(obj) };
  else
    var copy3 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy3, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy3;
}
var fs$d = require$$0$2;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$g = require$$0$4;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop$4() {
}
function publishQueue(context2, queue2) {
  Object.defineProperty(context2, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug = noop$4;
if (util$g.debuglog)
  debug = util$g.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug = function() {
    var m = util$g.format.apply(util$g, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$d[gracefulQueue]) {
  var queue$1 = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$d, queue$1);
  fs$d.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$d, fd, function(err2) {
        if (!err2) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$d.close);
  fs$d.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$d, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$d.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug(fs$d[gracefulQueue]);
      require$$5.equal(fs$d[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$d[gracefulQueue]);
}
var gracefulFs = patch(clone(fs$d));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$d.__patched) {
  gracefulFs = patch(fs$d);
  fs$d.__patched = true;
}
function patch(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile;
  function readFile(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path22, options2, cb2, startTime) {
      return fs$readFile(path22, options2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$readFile, [path22, options2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile;
  function writeFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path22, data2, options2, cb2, startTime) {
      return fs$writeFile(path22, data2, options2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$writeFile, [path22, data2, options2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path22, data2, options2, cb2, startTime) {
      return fs$appendFile(path22, data2, options2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$appendFile, [path22, data2, options2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile;
  function copyFile(src2, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src22, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src22, dest2, flags2, function(err2) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$copyFile, [src22, dest2, flags2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir2;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    } : function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, options2, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options, cb);
    function fs$readdirCallback(path22, options2, cb2, startTime) {
      return function(err2, files) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([
            go$readdir,
            [path22, options2, cb2],
            err2,
            startTime || Date.now(),
            Date.now()
          ]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err2, files);
        }
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err2, fd) {
      if (err2) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err2);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err2, fd) {
      if (err2) {
        that.destroy();
        that.emit("error", err2);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path22, flags2, mode2, cb2, startTime) {
      return fs$open(path22, flags2, mode2, function(err2, fd) {
        if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
          enqueue([go$open, [path22, flags2, mode2, cb2], err2, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug("ENQUEUE", elem[0].name, elem[1]);
  fs$d[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i = 0; i < fs$d[gracefulQueue].length; ++i) {
    if (fs$d[gracefulQueue][i].length > 2) {
      fs$d[gracefulQueue][i][3] = now;
      fs$d[gracefulQueue][i][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$d[gracefulQueue].length === 0)
    return;
  var elem = fs$d[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err2 = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err2);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$d[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
var readable$3 = { exports: {} };
var stream$5;
var hasRequiredStream$3;
function requireStream$3() {
  if (hasRequiredStream$3) return stream$5;
  hasRequiredStream$3 = 1;
  stream$5 = require$$0$1;
  return stream$5;
}
var safeBuffer$3 = { exports: {} };
var hasRequiredSafeBuffer$3;
function requireSafeBuffer$3() {
  if (hasRequiredSafeBuffer$3) return safeBuffer$3.exports;
  hasRequiredSafeBuffer$3 = 1;
  (function(module, exports) {
    var buffer = require$$0$3;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$3, safeBuffer$3.exports);
  return safeBuffer$3.exports;
}
var BufferList$5 = { exports: {} };
var hasRequiredBufferList$3;
function requireBufferList$3() {
  if (hasRequiredBufferList$3) return BufferList$5.exports;
  hasRequiredBufferList$3 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$3().Buffer;
    var util2 = require$$0$4;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$5);
  return BufferList$5.exports;
}
var destroy_1$3;
var hasRequiredDestroy$3;
function requireDestroy$3() {
  if (hasRequiredDestroy$3) return destroy_1$3;
  hasRequiredDestroy$3 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err2, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err2);
      } else if (err2) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err2);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err2);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err2 || null, function(err3) {
      if (!cb && err3) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err3);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err3);
        }
      } else if (cb) {
        cb(err3);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err2) {
    self2.emit("error", err2);
  }
  destroy_1$3 = {
    destroy,
    undestroy
  };
  return destroy_1$3;
}
var _stream_writable$3;
var hasRequired_stream_writable$3;
function require_stream_writable$3() {
  if (hasRequired_stream_writable$3) return _stream_writable$3;
  hasRequired_stream_writable$3 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$3 = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream$3();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$3();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$3();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable2) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex$3();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
      return new Writable2(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync3) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err2) {
      state2.pendingcb--;
      if (err2) {
        stream2.emit("error", err2);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err2) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err2, cb) {
    this.end();
    cb(err2);
  };
  return _stream_writable$3;
}
var _stream_duplex$3;
var hasRequired_stream_duplex$3;
function require_stream_duplex$3() {
  if (hasRequired_stream_duplex$3) return _stream_duplex$3;
  hasRequired_stream_duplex$3 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$3 = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$3();
  var Writable2 = require_stream_writable$3();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable2.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err2, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err2);
  };
  return _stream_duplex$3;
}
var string_decoder$3 = {};
var hasRequiredString_decoder$3;
function requireString_decoder$3() {
  if (hasRequiredString_decoder$3) return string_decoder$3;
  hasRequiredString_decoder$3 = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$3.StringDecoder = StringDecoder2;
  function StringDecoder2(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder2.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder2.prototype.end = utf8End;
  StringDecoder2.prototype.text = utf8Text;
  StringDecoder2.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$3;
}
var _stream_readable$3;
var hasRequired_stream_readable$3;
function require_stream_readable$3() {
  if (hasRequired_stream_readable$3) return _stream_readable$3;
  hasRequired_stream_readable$3 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$3 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = requireStream$3();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$4;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList$3();
  var destroyImpl = requireDestroy$3();
  var StringDecoder2;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$3();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2) StringDecoder2 = requireString_decoder$3().StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$3();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err2, cb) {
    this.push(null);
    cb(err2);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder2) StringDecoder2 = requireString_decoder$3().StringDecoder;
    this._readableState.decoder = new StringDecoder2(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug2("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c2 = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c2 = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$3;
}
var _stream_transform$3;
var hasRequired_stream_transform$3;
function require_stream_transform$3() {
  if (hasRequired_stream_transform$3) return _stream_transform$3;
  hasRequired_stream_transform$3 = 1;
  _stream_transform$3 = Transform2;
  var Duplex = require_stream_duplex$3();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err2, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err2, function(err22) {
      cb(err22);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$3;
}
var _stream_passthrough$3;
var hasRequired_stream_passthrough$3;
function require_stream_passthrough$3() {
  if (hasRequired_stream_passthrough$3) return _stream_passthrough$3;
  hasRequired_stream_passthrough$3 = 1;
  _stream_passthrough$3 = PassThrough2;
  var Transform2 = require_stream_transform$3();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$3;
}
(function(module, exports) {
  var Stream2 = require$$0$1;
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module.exports = Stream2;
    exports = module.exports = Stream2.Readable;
    exports.Readable = Stream2.Readable;
    exports.Writable = Stream2.Writable;
    exports.Duplex = Stream2.Duplex;
    exports.Transform = Stream2.Transform;
    exports.PassThrough = Stream2.PassThrough;
    exports.Stream = Stream2;
  } else {
    exports = module.exports = require_stream_readable$3();
    exports.Stream = Stream2 || exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable$3();
    exports.Duplex = require_stream_duplex$3();
    exports.Transform = require_stream_transform$3();
    exports.PassThrough = require_stream_passthrough$3();
  }
})(readable$3, readable$3.exports);
var readableExports$2 = readable$3.exports;
var passthrough = readableExports$2.PassThrough;
var util$f = require$$0$4;
var PassThrough$5 = passthrough;
var lazystream$2 = {
  Readable: Readable$2
};
util$f.inherits(Readable$2, PassThrough$5);
util$f.inherits(Writable$2, PassThrough$5);
function beforeFirstCall(instance, method2, callback) {
  instance[method2] = function() {
    delete instance[method2];
    callback.apply(this, arguments);
    return this[method2].apply(this, arguments);
  };
}
function Readable$2(fn, options) {
  if (!(this instanceof Readable$2))
    return new Readable$2(fn, options);
  PassThrough$5.call(this, options);
  beforeFirstCall(this, "_read", function() {
    var source = fn.call(this, options);
    var emit = this.emit.bind(this, "error");
    source.on("error", emit);
    source.pipe(this);
  });
  this.emit("readable");
}
function Writable$2(fn, options) {
  if (!(this instanceof Writable$2))
    return new Writable$2(fn, options);
  PassThrough$5.call(this, options);
  beforeFirstCall(this, "_write", function() {
    var destination = fn.call(this, options);
    var emit = this.emit.bind(this, "error");
    destination.on("error", emit);
    this.pipe(destination);
  });
  this.emit("writable");
}
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var normalizePath$3 = function(path2, stripTrailing) {
  if (typeof path2 !== "string") {
    throw new TypeError("expected path to be a string");
  }
  if (path2 === "\\" || path2 === "/") return "/";
  var len = path2.length;
  if (len <= 1) return path2;
  var prefix = "";
  if (len > 4 && path2[3] === "\\") {
    var ch = path2[2];
    if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
      path2 = path2.slice(2);
      prefix = "//";
    }
  }
  var segs = path2.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === "") {
    segs.pop();
  }
  return prefix + segs.join("/");
};
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var argsTag$3 = "[object Arguments]", funcTag$3 = "[object Function]", genTag$3 = "[object GeneratorFunction]";
var reIsUint = /^(?:0|[1-9]\d*)$/;
function apply$2(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var objectToString$4 = objectProto$4.toString;
var propertyIsEnumerable$3 = objectProto$4.propertyIsEnumerable;
var nativeMax$2 = Math.max;
function arrayLikeKeys(value, inherited) {
  var result = isArray$4(value) || isArguments$3(value) ? baseTimes(value.length, String) : [];
  var length = result.length, skipIndexes = !!length;
  for (var key in value) {
    if (!(skipIndexes && (key == "length" || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function assignInDefaults(objValue, srcValue, key, object2) {
  if (objValue === void 0 || eq$2(objValue, objectProto$4[key]) && !hasOwnProperty$4.call(object2, key)) {
    return srcValue;
  }
  return objValue;
}
function assignValue(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty$4.call(object2, key) && eq$2(objValue, value)) || value === void 0 && !(key in object2)) {
    object2[key] = value;
  }
}
function baseKeysIn(object2) {
  if (!isObject$3(object2)) {
    return nativeKeysIn(object2);
  }
  var isProto = isPrototype(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
function baseRest$2(func, start) {
  start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$2(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = array;
    return apply$2(func, this, otherArgs);
  };
}
function copyObject(source, props2, object2, customizer) {
  object2 || (object2 = {});
  var index2 = -1, length = props2.length;
  while (++index2 < length) {
    var key = props2[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    assignValue(object2, key, newValue === void 0 ? source[key] : newValue);
  }
  return object2;
}
function createAssigner(assigner) {
  return baseRest$2(function(object2, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object2, source, index2, customizer);
      }
    }
    return object2;
  });
}
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isIterateeCall(value, index2, object2) {
  if (!isObject$3(object2)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$3(object2) && isIndex(index2, object2.length) : type == "string" && index2 in object2) {
    return eq$2(object2[index2], value);
  }
  return false;
}
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value === proto;
}
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
function isArguments$3(value) {
  return isArrayLikeObject$3(value) && hasOwnProperty$4.call(value, "callee") && (!propertyIsEnumerable$3.call(value, "callee") || objectToString$4.call(value) == argsTag$3);
}
var isArray$4 = Array.isArray;
function isArrayLike$3(value) {
  return value != null && isLength$3(value.length) && !isFunction$3(value);
}
function isArrayLikeObject$3(value) {
  return isObjectLike$4(value) && isArrayLike$3(value);
}
function isFunction$3(value) {
  var tag = isObject$3(value) ? objectToString$4.call(value) : "";
  return tag == funcTag$3 || tag == genTag$3;
}
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$3;
}
function isObject$3(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$4(value) {
  return !!value && typeof value == "object";
}
var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object2, customizer);
});
var defaults$3 = baseRest$2(function(args) {
  args.push(void 0, assignInDefaults);
  return apply$2(assignInWith, void 0, args);
});
function keysIn(object2) {
  return isArrayLike$3(object2) ? arrayLikeKeys(object2) : baseKeysIn(object2);
}
var lodash_defaults = defaults$3;
var readable$2 = { exports: {} };
var stream$4;
var hasRequiredStream$2;
function requireStream$2() {
  if (hasRequiredStream$2) return stream$4;
  hasRequiredStream$2 = 1;
  stream$4 = require$$0$1;
  return stream$4;
}
var safeBuffer$2 = { exports: {} };
var hasRequiredSafeBuffer$2;
function requireSafeBuffer$2() {
  if (hasRequiredSafeBuffer$2) return safeBuffer$2.exports;
  hasRequiredSafeBuffer$2 = 1;
  (function(module, exports) {
    var buffer = require$$0$3;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$2, safeBuffer$2.exports);
  return safeBuffer$2.exports;
}
var BufferList$4 = { exports: {} };
var hasRequiredBufferList$2;
function requireBufferList$2() {
  if (hasRequiredBufferList$2) return BufferList$4.exports;
  hasRequiredBufferList$2 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$2().Buffer;
    var util2 = require$$0$4;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$4);
  return BufferList$4.exports;
}
var destroy_1$2;
var hasRequiredDestroy$2;
function requireDestroy$2() {
  if (hasRequiredDestroy$2) return destroy_1$2;
  hasRequiredDestroy$2 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err2, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err2);
      } else if (err2) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err2);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err2);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err2 || null, function(err3) {
      if (!cb && err3) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err3);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err3);
        }
      } else if (cb) {
        cb(err3);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err2) {
    self2.emit("error", err2);
  }
  destroy_1$2 = {
    destroy,
    undestroy
  };
  return destroy_1$2;
}
var _stream_writable$2;
var hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2) return _stream_writable$2;
  hasRequired_stream_writable$2 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$2 = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream$2();
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$2();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$2();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable2) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex$2();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
      return new Writable2(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync3) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err2) {
      state2.pendingcb--;
      if (err2) {
        stream2.emit("error", err2);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err2) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err2, cb) {
    this.end();
    cb(err2);
  };
  return _stream_writable$2;
}
var _stream_duplex$2;
var hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2) return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$2 = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$2();
  var Writable2 = require_stream_writable$2();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable2.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err2, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err2);
  };
  return _stream_duplex$2;
}
var string_decoder$2 = {};
var hasRequiredString_decoder$2;
function requireString_decoder$2() {
  if (hasRequiredString_decoder$2) return string_decoder$2;
  hasRequiredString_decoder$2 = 1;
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$2.StringDecoder = StringDecoder2;
  function StringDecoder2(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder2.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder2.prototype.end = utf8End;
  StringDecoder2.prototype.text = utf8Text;
  StringDecoder2.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$2;
}
var _stream_readable$2;
var hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2) return _stream_readable$2;
  hasRequired_stream_readable$2 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$2 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = requireStream$2();
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$4;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList$2();
  var destroyImpl = requireDestroy$2();
  var StringDecoder2;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$2();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2) StringDecoder2 = requireString_decoder$2().StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$2();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err2, cb) {
    this.push(null);
    cb(err2);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder2) StringDecoder2 = requireString_decoder$2().StringDecoder;
    this._readableState.decoder = new StringDecoder2(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug2("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c2 = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c2 = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2;
var hasRequired_stream_transform$2;
function require_stream_transform$2() {
  if (hasRequired_stream_transform$2) return _stream_transform$2;
  hasRequired_stream_transform$2 = 1;
  _stream_transform$2 = Transform2;
  var Duplex = require_stream_duplex$2();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err2, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err2, function(err22) {
      cb(err22);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2;
var hasRequired_stream_passthrough$2;
function require_stream_passthrough$2() {
  if (hasRequired_stream_passthrough$2) return _stream_passthrough$2;
  hasRequired_stream_passthrough$2 = 1;
  _stream_passthrough$2 = PassThrough2;
  var Transform2 = require_stream_transform$2();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$2;
}
(function(module, exports) {
  var Stream2 = require$$0$1;
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module.exports = Stream2;
    exports = module.exports = Stream2.Readable;
    exports.Readable = Stream2.Readable;
    exports.Writable = Stream2.Writable;
    exports.Duplex = Stream2.Duplex;
    exports.Transform = Stream2.Transform;
    exports.PassThrough = Stream2.PassThrough;
    exports.Stream = Stream2;
  } else {
    exports = module.exports = require_stream_readable$2();
    exports.Stream = Stream2 || exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable$2();
    exports.Duplex = require_stream_duplex$2();
    exports.Transform = require_stream_transform$2();
    exports.PassThrough = require_stream_passthrough$2();
  }
})(readable$2, readable$2.exports);
var readableExports$1 = readable$2.exports;
var file$3 = { exports: {} };
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var argsTag$2 = "[object Arguments]", funcTag$2 = "[object Function]", genTag$2 = "[object GeneratorFunction]";
var freeGlobal$2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$2 = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal$2 || freeSelf$2 || Function("return this")();
function arrayPush$2(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
var objectToString$3 = objectProto$3.toString;
var Symbol$3 = root$2.Symbol, propertyIsEnumerable$2 = objectProto$3.propertyIsEnumerable, spreadableSymbol$2 = Symbol$3 ? Symbol$3.isConcatSpreadable : void 0;
function baseFlatten$2(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable$2);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value)) {
      {
        arrayPush$2(result, value);
      }
    } else {
      result[result.length] = value;
    }
  }
  return result;
}
function isFlattenable$2(value) {
  return isArray$3(value) || isArguments$2(value) || !!(spreadableSymbol$2 && value && value[spreadableSymbol$2]);
}
function flatten$2(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten$2(array) : [];
}
function isArguments$2(value) {
  return isArrayLikeObject$2(value) && hasOwnProperty$3.call(value, "callee") && (!propertyIsEnumerable$2.call(value, "callee") || objectToString$3.call(value) == argsTag$2);
}
var isArray$3 = Array.isArray;
function isArrayLike$2(value) {
  return value != null && isLength$2(value.length) && !isFunction$2(value);
}
function isArrayLikeObject$2(value) {
  return isObjectLike$3(value) && isArrayLike$2(value);
}
function isFunction$2(value) {
  var tag = isObject$2(value) ? objectToString$3.call(value) : "";
  return tag == funcTag$2 || tag == genTag$2;
}
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
function isObject$2(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$3(value) {
  return !!value && typeof value == "object";
}
var lodash_flatten = flatten$2;
var LARGE_ARRAY_SIZE$1 = 200;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var argsTag$1 = "[object Arguments]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]";
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf$1 || Function("return this")();
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function arrayIncludes$1(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf$1(array, value, 0) > -1;
}
function arrayPush$1(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + -1;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf$1(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex$1(array, baseIsNaN$1, fromIndex);
  }
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN$1(value) {
  return value !== value;
}
function cacheHas$1(cache, key) {
  return cache.has(key);
}
function getValue$1(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function isHostObject$2(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
var arrayProto$1 = Array.prototype, funcProto$2 = Function.prototype, objectProto$2 = Object.prototype;
var coreJsData$1 = root$1["__core-js_shared__"];
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
var objectToString$2 = objectProto$2.toString;
var reIsNative$1 = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$2).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var Symbol$2 = root$1.Symbol, propertyIsEnumerable$1 = objectProto$2.propertyIsEnumerable, splice$1 = arrayProto$1.splice, spreadableSymbol$1 = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
var nativeMax$1 = Math.max;
var Map$2 = getNative$1(root$1, "Map"), nativeCreate$1 = getNative$1(Object, "create");
function Hash$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear$1() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
}
function hashDelete$1(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$2.call(data, key) ? data[key] : void 0;
}
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);
}
function hashSet$1(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype["delete"] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;
function ListCache$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear$1() {
  this.__data__ = [];
}
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  return true;
}
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype["delete"] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;
function MapCache$1(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear$1() {
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$2 || ListCache$1)(),
    "string": new Hash$1()
  };
}
function mapCacheDelete$1(key) {
  return getMapData$1(this, key)["delete"](key);
}
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
function mapCacheSet$1(key, value) {
  getMapData$1(this, key).set(key, value);
  return this;
}
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype["delete"] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;
function SetCache$1(values) {
  var index2 = -1, length = values ? values.length : 0;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED$1);
  return this;
}
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd$1;
SetCache$1.prototype.has = setCacheHas$1;
function assocIndexOf$1(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseDifference(array, values, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes$1, isCommon = true, length = array.length, result = [], valuesLength = values.length;
  if (!length) {
    return result;
  }
  if (values.length >= LARGE_ARRAY_SIZE$1) {
    includes = cacheHas$1;
    isCommon = false;
    values = new SetCache$1(values);
  }
  outer:
    while (++index2 < length) {
      var value = array[index2], computed = value;
      value = value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }
  return result;
}
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable$1);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value)) {
      {
        arrayPush$1(result, value);
      }
    }
  }
  return result;
}
function baseIsNative$1(value) {
  if (!isObject$1(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$1(value) || isHostObject$2(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}
function baseRest$1(func, start) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = array;
    return apply$1(func, this, otherArgs);
  };
}
function getMapData$1(map3, key) {
  var data = map3.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative$1(object2, key) {
  var value = getValue$1(object2, key);
  return baseIsNative$1(value) ? value : void 0;
}
function isFlattenable$1(value) {
  return isArray$2(value) || isArguments$1(value) || !!(spreadableSymbol$1 && value && value[spreadableSymbol$1]);
}
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var difference$2 = baseRest$1(function(array, values) {
  return isArrayLikeObject$1(array) ? baseDifference(array, baseFlatten$1(values, 1, isArrayLikeObject$1)) : [];
});
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
function isArguments$1(value) {
  return isArrayLikeObject$1(value) && hasOwnProperty$2.call(value, "callee") && (!propertyIsEnumerable$1.call(value, "callee") || objectToString$2.call(value) == argsTag$1);
}
var isArray$2 = Array.isArray;
function isArrayLike$1(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
function isArrayLikeObject$1(value) {
  return isObjectLike$2(value) && isArrayLike$1(value);
}
function isFunction$1(value) {
  var tag = isObject$1(value) ? objectToString$2.call(value) : "";
  return tag == funcTag$1 || tag == genTag$1;
}
function isLength$1(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$2(value) {
  return !!value && typeof value == "object";
}
var lodash_difference = difference$2;
var LARGE_ARRAY_SIZE = 200;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + -1;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
function getValue(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function isHostObject$1(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var arrayProto = Array.prototype, funcProto$1 = Function.prototype, objectProto$1 = Object.prototype;
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var objectToString$1 = objectProto$1.toString;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var Symbol$1 = root.Symbol, propertyIsEnumerable = objectProto$1.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
var nativeMax = Math.max;
var Map$1 = getNative(root, "Map"), Set$1 = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
function Hash(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
}
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
}
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
}
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries ? entries.length : 0;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
function mapCacheClear() {
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function mapCacheDelete(key) {
  return getMapData(this, key)["delete"](key);
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function SetCache(values) {
  var index2 = -1, length = values ? values.length : 0;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value)) {
      {
        arrayPush(result, value);
      }
    }
  }
  return result;
}
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function baseRest(func, start) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}
function baseUniq(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
  if (length >= LARGE_ARRAY_SIZE) {
    var set2 = createSet(array);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = result;
  }
  outer:
    while (++index2 < length) {
      var value = array[index2], computed = value;
      value = value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop$3 : function(values) {
  return new Set$1(values);
};
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function getNative(object2, key) {
  var value = getValue(object2, key);
  return baseIsNative(value) ? value : void 0;
}
function isFlattenable(value) {
  return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var union$2 = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject));
});
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function isArguments(value) {
  return isArrayLikeObject(value) && hasOwnProperty$1.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString$1.call(value) == argsTag);
}
var isArray$1 = Array.isArray;
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike$1(value) && isArrayLike(value);
}
function isFunction(value) {
  var tag = isObject(value) ? objectToString$1.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function noop$3() {
}
var lodash_union = union$2;
var objectTag = "[object Object]";
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e) {
    }
  }
  return result;
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
var objectToString = objectProto.toString;
var getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isPlainObject$2(value) {
  if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$2;
var old$2 = {};
var pathModule = require$$1;
var isWindows$1 = process.platform === "win32";
var fs$c = require$$0$2;
var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
function rethrow() {
  var callback;
  if (DEBUG) {
    var backtrace = new Error();
    callback = debugCallback;
  } else
    callback = missingCallback;
  return callback;
  function debugCallback(err2) {
    if (err2) {
      backtrace.message = err2.message;
      err2 = backtrace;
      missingCallback(err2);
    }
  }
  function missingCallback(err2) {
    if (err2) {
      if (process.throwDeprecation)
        throw err2;
      else if (!process.noDeprecation) {
        var msg2 = "fs: missing callback " + (err2.stack || err2.message);
        if (process.traceDeprecation)
          console.trace(msg2);
        else
          console.error(msg2);
      }
    }
  }
}
function maybeCallback(cb) {
  return typeof cb === "function" ? cb : rethrow();
}
pathModule.normalize;
if (isWindows$1) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}
if (isWindows$1) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}
old$2.realpathSync = function realpathSync(p, cache) {
  p = pathModule.resolve(p);
  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }
  var original = p, seenLinks = {}, knownHard = {};
  var pos;
  var current;
  var base;
  var previous;
  start();
  function start() {
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = "";
    if (isWindows$1 && !knownHard[base]) {
      fs$c.lstatSync(base);
      knownHard[base] = true;
    }
  }
  while (pos < p.length) {
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;
    if (knownHard[base] || cache && cache[base] === base) {
      continue;
    }
    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      resolvedLink = cache[base];
    } else {
      var stat2 = fs$c.lstatSync(base);
      if (!stat2.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }
      var linkTarget = null;
      if (!isWindows$1) {
        var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs$c.statSync(base);
        linkTarget = fs$c.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      if (cache) cache[base] = resolvedLink;
      if (!isWindows$1) seenLinks[id] = linkTarget;
    }
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
  if (cache) cache[original] = p;
  return p;
};
old$2.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== "function") {
    cb = maybeCallback(cache);
    cache = null;
  }
  p = pathModule.resolve(p);
  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }
  var original = p, seenLinks = {}, knownHard = {};
  var pos;
  var current;
  var base;
  var previous;
  start();
  function start() {
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = "";
    if (isWindows$1 && !knownHard[base]) {
      fs$c.lstat(base, function(err2) {
        if (err2) return cb(err2);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }
  function LOOP() {
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;
    if (knownHard[base] || cache && cache[base] === base) {
      return process.nextTick(LOOP);
    }
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      return gotResolvedLink(cache[base]);
    }
    return fs$c.lstat(base, gotStat);
  }
  function gotStat(err2, stat2) {
    if (err2) return cb(err2);
    if (!stat2.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }
    if (!isWindows$1) {
      var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs$c.stat(base, function(err22) {
      if (err22) return cb(err22);
      fs$c.readlink(base, function(err3, target) {
        if (!isWindows$1) seenLinks[id] = target;
        gotTarget(err3, target);
      });
    });
  }
  function gotTarget(err2, target, base2) {
    if (err2) return cb(err2);
    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base2] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }
  function gotResolvedLink(resolvedLink) {
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};
var fs_realpath = realpath2;
realpath2.realpath = realpath2;
realpath2.sync = realpathSync2;
realpath2.realpathSync = realpathSync2;
realpath2.monkeypatch = monkeypatch;
realpath2.unmonkeypatch = unmonkeypatch;
var fs$b = require$$0$2;
var origRealpath = fs$b.realpath;
var origRealpathSync = fs$b.realpathSync;
var version = process.version;
var ok = /^v[0-5]\./.test(version);
var old$1 = old$2;
function newError(er) {
  return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
}
function realpath2(p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb);
  }
  if (typeof cache === "function") {
    cb = cache;
    cache = null;
  }
  origRealpath(p, cache, function(er, result) {
    if (newError(er)) {
      old$1.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}
function realpathSync2(p, cache) {
  if (ok) {
    return origRealpathSync(p, cache);
  }
  try {
    return origRealpathSync(p, cache);
  } catch (er) {
    if (newError(er)) {
      return old$1.realpathSync(p, cache);
    } else {
      throw er;
    }
  }
}
function monkeypatch() {
  fs$b.realpath = realpath2;
  fs$b.realpathSync = realpathSync2;
}
function unmonkeypatch() {
  fs$b.realpath = origRealpath;
  fs$b.realpathSync = origRealpathSync;
}
var concatMap$1 = function(xs, fn) {
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    var x = fn(xs[i], i);
    if (isArray(x)) res.push.apply(res, x);
    else res.push(x);
  }
  return res;
};
var isArray = Array.isArray || function(xs) {
  return Object.prototype.toString.call(xs) === "[object Array]";
};
var concatMap = concatMap$1;
var balanced = balancedMatch;
var braceExpansion = expandTop;
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str) {
  return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str) {
  if (!str)
    return [""];
  var parts = [];
  var m = balanced("{", "}", str);
  if (!m)
    return str.split(",");
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str) {
  if (!str)
    return [];
  if (str.substr(0, 2) === "{}") {
    str = "\\{\\}" + str.substr(2);
  }
  return expand$1(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand$1(str, isTop) {
  var expansions = [];
  var m = balanced("{", "}", str);
  if (!m || /\$$/.test(m.pre)) return [str];
  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(",") >= 0;
  if (!isSequence && !isOptions) {
    if (m.post.match(/,.*\}/)) {
      str = m.pre + "{" + m.body + escClose + m.post;
      return expand$1(str);
    }
    return [str];
  }
  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      n = expand$1(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length ? expand$1(m.post, false) : [""];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }
  var pre = m.pre;
  var post = m.post.length ? expand$1(m.post, false) : [""];
  var N;
  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);
    N = [];
    for (var i = x; test(i, y); i += incr) {
      var c2;
      if (isAlphaSequence) {
        c2 = String.fromCharCode(i);
        if (c2 === "\\")
          c2 = "";
      } else {
        c2 = String(i);
        if (pad) {
          var need = width - c2.length;
          if (need > 0) {
            var z = new Array(need + 1).join("0");
            if (i < 0)
              c2 = "-" + z + c2.slice(1);
            else
              c2 = z + c2;
          }
        }
      }
      N.push(c2);
    }
  } else {
    N = concatMap(n, function(el) {
      return expand$1(el, false);
    });
  }
  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }
  return expansions;
}
var minimatch_1 = minimatch$1;
minimatch$1.Minimatch = Minimatch$1;
var path$a = function() {
  try {
    return require("path");
  } catch (e) {
  }
}() || {
  sep: "/"
};
minimatch$1.sep = path$a.sep;
var GLOBSTAR = minimatch$1.GLOBSTAR = Minimatch$1.GLOBSTAR = {};
var expand = braceExpansion;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var reSpecials = charSet("().*{}+?[]^$\\!");
function charSet(s) {
  return s.split("").reduce(function(set2, c2) {
    set2[c2] = true;
    return set2;
  }, {});
}
var slashSplit = /\/+/;
minimatch$1.filter = filter$1;
function filter$1(pattern, options) {
  options = options || {};
  return function(p, i, list) {
    return minimatch$1(p, pattern, options);
  };
}
function ext(a, b) {
  b = b || {};
  var t = {};
  Object.keys(a).forEach(function(k) {
    t[k] = a[k];
  });
  Object.keys(b).forEach(function(k) {
    t[k] = b[k];
  });
  return t;
}
minimatch$1.defaults = function(def) {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch$1;
  }
  var orig = minimatch$1;
  var m = function minimatch2(p, pattern, options) {
    return orig(p, pattern, ext(def, options));
  };
  m.Minimatch = function Minimatch3(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options));
  };
  m.Minimatch.defaults = function defaults2(options) {
    return orig.defaults(ext(def, options)).Minimatch;
  };
  m.filter = function filter2(pattern, options) {
    return orig.filter(pattern, ext(def, options));
  };
  m.defaults = function defaults2(options) {
    return orig.defaults(ext(def, options));
  };
  m.makeRe = function makeRe2(pattern, options) {
    return orig.makeRe(pattern, ext(def, options));
  };
  m.braceExpand = function braceExpand2(pattern, options) {
    return orig.braceExpand(pattern, ext(def, options));
  };
  m.match = function(list, pattern, options) {
    return orig.match(list, pattern, ext(def, options));
  };
  return m;
};
Minimatch$1.defaults = function(def) {
  return minimatch$1.defaults(def).Minimatch;
};
function minimatch$1(p, pattern, options) {
  assertValidPattern(pattern);
  if (!options) options = {};
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch$1(pattern, options).match(p);
}
function Minimatch$1(pattern, options) {
  if (!(this instanceof Minimatch$1)) {
    return new Minimatch$1(pattern, options);
  }
  assertValidPattern(pattern);
  if (!options) options = {};
  pattern = pattern.trim();
  if (!options.allowWindowsEscape && path$a.sep !== "/") {
    pattern = pattern.split(path$a.sep).join("/");
  }
  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.partial = !!options.partial;
  this.make();
}
Minimatch$1.prototype.debug = function() {
};
Minimatch$1.prototype.make = make;
function make() {
  var pattern = this.pattern;
  var options = this.options;
  if (!options.nocomment && pattern.charAt(0) === "#") {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }
  this.parseNegate();
  var set2 = this.globSet = this.braceExpand();
  if (options.debug) this.debug = function debug2() {
    console.error.apply(console, arguments);
  };
  this.debug(this.pattern, set2);
  set2 = this.globParts = set2.map(function(s) {
    return s.split(slashSplit);
  });
  this.debug(this.pattern, set2);
  set2 = set2.map(function(s, si, set3) {
    return s.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set2);
  set2 = set2.filter(function(s) {
    return s.indexOf(false) === -1;
  });
  this.debug(this.pattern, set2);
  this.set = set2;
}
Minimatch$1.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate) return;
  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
    negate = !negate;
    negateOffset++;
  }
  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}
minimatch$1.braceExpand = function(pattern, options) {
  return braceExpand(pattern, options);
};
Minimatch$1.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof Minimatch$1) {
      options = this.options;
    } else {
      options = {};
    }
  }
  pattern = typeof pattern === "undefined" ? this.pattern : pattern;
  assertValidPattern(pattern);
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function(pattern) {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
Minimatch$1.prototype.parse = parse$1;
var SUBPARSE = {};
function parse$1(pattern, isSub) {
  assertValidPattern(pattern);
  var options = this.options;
  if (pattern === "**") {
    if (!options.noglobstar)
      return GLOBSTAR;
    else
      pattern = "*";
  }
  if (pattern === "") return "";
  var re = "";
  var hasMagic = !!options.nocase;
  var escaping = false;
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
  var self2 = this;
  function clearStateChar() {
    if (stateChar) {
      switch (stateChar) {
        case "*":
          re += star;
          hasMagic = true;
          break;
        case "?":
          re += qmark;
          hasMagic = true;
          break;
        default:
          re += "\\" + stateChar;
          break;
      }
      self2.debug("clearStateChar %j %j", stateChar, re);
      stateChar = false;
    }
  }
  for (var i = 0, len = pattern.length, c2; i < len && (c2 = pattern.charAt(i)); i++) {
    this.debug("%s	%s %s %j", pattern, i, re, c2);
    if (escaping && reSpecials[c2]) {
      re += "\\" + c2;
      escaping = false;
      continue;
    }
    switch (c2) {
      case "/": {
        return false;
      }
      case "\\":
        clearStateChar();
        escaping = true;
        continue;
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c2);
        if (inClass) {
          this.debug("  in class");
          if (c2 === "!" && i === classStart + 1) c2 = "^";
          re += c2;
          continue;
        }
        self2.debug("call clearStateChar %j", stateChar);
        clearStateChar();
        stateChar = c2;
        if (options.noext) clearStateChar();
        continue;
      case "(":
        if (inClass) {
          re += "(";
          continue;
        }
        if (!stateChar) {
          re += "\\(";
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
        this.debug("plType %j %j", stateChar, re);
        stateChar = false;
        continue;
      case ")":
        if (inClass || !patternListStack.length) {
          re += "\\)";
          continue;
        }
        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        re += pl.close;
        if (pl.type === "!") {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
        continue;
      case "|":
        if (inClass || !patternListStack.length || escaping) {
          re += "\\|";
          escaping = false;
          continue;
        }
        clearStateChar();
        re += "|";
        continue;
      case "[":
        clearStateChar();
        if (inClass) {
          re += "\\" + c2;
          continue;
        }
        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c2;
        continue;
      case "]":
        if (i === classStart + 1 || !inClass) {
          re += "\\" + c2;
          escaping = false;
          continue;
        }
        var cs = pattern.substring(classStart + 1, i);
        try {
          RegExp("[" + cs + "]");
        } catch (er) {
          var sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
          hasMagic = hasMagic || sp[1];
          inClass = false;
          continue;
        }
        hasMagic = true;
        inClass = false;
        re += c2;
        continue;
      default:
        clearStateChar();
        if (escaping) {
          escaping = false;
        } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
          re += "\\";
        }
        re += c2;
    }
  }
  if (inClass) {
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + "\\[" + sp[0];
    hasMagic = hasMagic || sp[1];
  }
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug("setting tail", re, pl);
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
      if (!$2) {
        $2 = "\\";
      }
      return $1 + $1 + $2 + "|";
    });
    this.debug("tail=%j\n   %s", tail, tail, pl, re);
    var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + "\\(" + tail;
  }
  clearStateChar();
  if (escaping) {
    re += "\\\\";
  }
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case "[":
    case ".":
    case "(":
      addPatternStart = true;
  }
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];
    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);
    nlLast += nlAfter;
    var openParensBefore = nlBefore.split("(").length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
    }
    nlAfter = cleanAfter;
    var dollar = "";
    if (nlAfter === "" && isSub !== SUBPARSE) {
      dollar = "$";
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }
  if (re !== "" && hasMagic) {
    re = "(?=.)" + re;
  }
  if (addPatternStart) {
    re = patternStart + re;
  }
  if (isSub === SUBPARSE) {
    return [re, hasMagic];
  }
  if (!hasMagic) {
    return globUnescape(pattern);
  }
  var flags = options.nocase ? "i" : "";
  try {
    var regExp = new RegExp("^" + re + "$", flags);
  } catch (er) {
    return new RegExp("$.");
  }
  regExp._glob = pattern;
  regExp._src = re;
  return regExp;
}
minimatch$1.makeRe = function(pattern, options) {
  return new Minimatch$1(pattern, options || {}).makeRe();
};
Minimatch$1.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;
  var set2 = this.set;
  if (!set2.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;
  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? "i" : "";
  var re = set2.map(function(pattern) {
    return pattern.map(function(p) {
      return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
    }).join("\\/");
  }).join("|");
  re = "^(?:" + re + ")$";
  if (this.negate) re = "^(?!" + re + ").*$";
  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp;
}
minimatch$1.match = function(list, pattern, options) {
  options = options || {};
  var mm = new Minimatch$1(pattern, options);
  list = list.filter(function(f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
Minimatch$1.prototype.match = function match(f, partial) {
  if (typeof partial === "undefined") partial = this.partial;
  this.debug("match", f, this.pattern);
  if (this.comment) return false;
  if (this.empty) return f === "";
  if (f === "/" && partial) return true;
  var options = this.options;
  if (path$a.sep !== "/") {
    f = f.split(path$a.sep).join("/");
  }
  f = f.split(slashSplit);
  this.debug(this.pattern, "split", f);
  var set2 = this.set;
  this.debug(this.pattern, "set", set2);
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }
  for (i = 0; i < set2.length; i++) {
    var pattern = set2[i];
    var file2 = f;
    if (options.matchBase && pattern.length === 1) {
      file2 = [filename];
    }
    var hit = this.matchOne(file2, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }
  if (options.flipNegate) return false;
  return this.negate;
};
Minimatch$1.prototype.matchOne = function(file2, pattern, partial) {
  var options = this.options;
  this.debug(
    "matchOne",
    { "this": this, file: file2, pattern }
  );
  this.debug("matchOne", file2.length, pattern.length);
  for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug("matchOne loop");
    var p = pattern[pi];
    var f = file2[fi];
    this.debug(pattern, p, f);
    if (p === false) return false;
    if (p === GLOBSTAR) {
      this.debug("GLOBSTAR", [pattern, p, f]);
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug("** at the end");
        for (; fi < fl; fi++) {
          if (file2[fi] === "." || file2[fi] === ".." || !options.dot && file2[fi].charAt(0) === ".") return false;
        }
        return true;
      }
      while (fr < fl) {
        var swallowee = file2[fr];
        this.debug("\nglobstar while", file2, fr, pattern, pr, swallowee);
        if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial)) {
          this.debug("globstar found match!", fr, fl, swallowee);
          return true;
        } else {
          if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file2, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue");
          fr++;
        }
      }
      if (partial) {
        this.debug("\n>>> no match, partial?", file2, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }
    var hit;
    if (typeof p === "string") {
      hit = f === p;
      this.debug("string match", p, f, hit);
    } else {
      hit = f.match(p);
      this.debug("pattern match", p, f, hit);
    }
    if (!hit) return false;
  }
  if (fi === fl && pi === pl) {
    return true;
  } else if (fi === fl) {
    return partial;
  } else if (pi === pl) {
    return fi === fl - 1 && file2[fi] === "";
  }
  throw new Error("wtf?");
};
function globUnescape(s) {
  return s.replace(/\\(.)/g, "$1");
}
function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
var pathIsAbsolute = { exports: {} };
function posix(path2) {
  return path2.charAt(0) === "/";
}
function win32$1(path2) {
  var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
  var result = splitDeviceRe.exec(path2);
  var device = result[1] || "";
  var isUnc = Boolean(device && device.charAt(1) !== ":");
  return Boolean(result[2] || isUnc);
}
pathIsAbsolute.exports = process.platform === "win32" ? win32$1 : posix;
pathIsAbsolute.exports.posix = posix;
pathIsAbsolute.exports.win32 = win32$1;
var pathIsAbsoluteExports = pathIsAbsolute.exports;
var common = {};
common.setopts = setopts;
common.ownProp = ownProp;
common.makeAbs = makeAbs;
common.finish = finish;
common.mark = mark;
common.isIgnored = isIgnored;
common.childrenIgnored = childrenIgnored;
function ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}
var fs$a = require$$0$2;
var path$9 = require$$1;
var minimatch = minimatch_1;
var isAbsolute = pathIsAbsoluteExports;
var Minimatch2 = minimatch.Minimatch;
function alphasort(a, b) {
  return a.localeCompare(b, "en");
}
function setupIgnores(self2, options) {
  self2.ignore = options.ignore || [];
  if (!Array.isArray(self2.ignore))
    self2.ignore = [self2.ignore];
  if (self2.ignore.length) {
    self2.ignore = self2.ignore.map(ignoreMap);
  }
}
function ignoreMap(pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === "/**") {
    var gpattern = pattern.replace(/(\/\*\*)+$/, "");
    gmatcher = new Minimatch2(gpattern, { dot: true });
  }
  return {
    matcher: new Minimatch2(pattern, { dot: true }),
    gmatcher
  };
}
function setopts(self2, pattern, options) {
  if (!options)
    options = {};
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar");
    }
    pattern = "**/" + pattern;
  }
  self2.silent = !!options.silent;
  self2.pattern = pattern;
  self2.strict = options.strict !== false;
  self2.realpath = !!options.realpath;
  self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
  self2.follow = !!options.follow;
  self2.dot = !!options.dot;
  self2.mark = !!options.mark;
  self2.nodir = !!options.nodir;
  if (self2.nodir)
    self2.mark = true;
  self2.sync = !!options.sync;
  self2.nounique = !!options.nounique;
  self2.nonull = !!options.nonull;
  self2.nosort = !!options.nosort;
  self2.nocase = !!options.nocase;
  self2.stat = !!options.stat;
  self2.noprocess = !!options.noprocess;
  self2.absolute = !!options.absolute;
  self2.fs = options.fs || fs$a;
  self2.maxLength = options.maxLength || Infinity;
  self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
  self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
  self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
  setupIgnores(self2, options);
  self2.changedCwd = false;
  var cwd2 = process.cwd();
  if (!ownProp(options, "cwd"))
    self2.cwd = cwd2;
  else {
    self2.cwd = path$9.resolve(options.cwd);
    self2.changedCwd = self2.cwd !== cwd2;
  }
  self2.root = options.root || path$9.resolve(self2.cwd, "/");
  self2.root = path$9.resolve(self2.root);
  if (process.platform === "win32")
    self2.root = self2.root.replace(/\\/g, "/");
  self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
  if (process.platform === "win32")
    self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
  self2.nomount = !!options.nomount;
  options.nonegate = true;
  options.nocomment = true;
  options.allowWindowsEscape = false;
  self2.minimatch = new Minimatch2(pattern, options);
  self2.options = self2.minimatch.options;
}
function finish(self2) {
  var nou = self2.nounique;
  var all = nou ? [] : /* @__PURE__ */ Object.create(null);
  for (var i = 0, l = self2.matches.length; i < l; i++) {
    var matches = self2.matches[i];
    if (!matches || Object.keys(matches).length === 0) {
      if (self2.nonull) {
        var literal = self2.minimatch.globSet[i];
        if (nou)
          all.push(literal);
        else
          all[literal] = true;
      }
    } else {
      var m = Object.keys(matches);
      if (nou)
        all.push.apply(all, m);
      else
        m.forEach(function(m2) {
          all[m2] = true;
        });
    }
  }
  if (!nou)
    all = Object.keys(all);
  if (!self2.nosort)
    all = all.sort(alphasort);
  if (self2.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self2._mark(all[i]);
    }
    if (self2.nodir) {
      all = all.filter(function(e) {
        var notDir = !/\/$/.test(e);
        var c2 = self2.cache[e] || self2.cache[makeAbs(self2, e)];
        if (notDir && c2)
          notDir = c2 !== "DIR" && !Array.isArray(c2);
        return notDir;
      });
    }
  }
  if (self2.ignore.length)
    all = all.filter(function(m2) {
      return !isIgnored(self2, m2);
    });
  self2.found = all;
}
function mark(self2, p) {
  var abs = makeAbs(self2, p);
  var c2 = self2.cache[abs];
  var m = p;
  if (c2) {
    var isDir = c2 === "DIR" || Array.isArray(c2);
    var slash = p.slice(-1) === "/";
    if (isDir && !slash)
      m += "/";
    else if (!isDir && slash)
      m = m.slice(0, -1);
    if (m !== p) {
      var mabs = makeAbs(self2, m);
      self2.statCache[mabs] = self2.statCache[abs];
      self2.cache[mabs] = self2.cache[abs];
    }
  }
  return m;
}
function makeAbs(self2, f) {
  var abs = f;
  if (f.charAt(0) === "/") {
    abs = path$9.join(self2.root, f);
  } else if (isAbsolute(f) || f === "") {
    abs = f;
  } else if (self2.changedCwd) {
    abs = path$9.resolve(self2.cwd, f);
  } else {
    abs = path$9.resolve(f);
  }
  if (process.platform === "win32")
    abs = abs.replace(/\\/g, "/");
  return abs;
}
function isIgnored(self2, path2) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
  });
}
function childrenIgnored(self2, path2) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path2));
  });
}
var sync;
var hasRequiredSync;
function requireSync() {
  if (hasRequiredSync) return sync;
  hasRequiredSync = 1;
  sync = globSync;
  globSync.GlobSync = GlobSync;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  minimatch2.Minimatch;
  requireGlob().Glob;
  var path2 = require$$1;
  var assert2 = require$$5;
  var isAbsolute2 = pathIsAbsoluteExports;
  var common$12 = common;
  var setopts2 = common$12.setopts;
  var ownProp2 = common$12.ownProp;
  var childrenIgnored2 = common$12.childrenIgnored;
  var isIgnored2 = common$12.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts2(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert2.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index2) {
        var set2 = self2.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set2[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set2[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common$12.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index2, inGlobStar) {
    assert2.ok(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index2);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute2(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored2(this, read))
      return;
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index2, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index2, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path2.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index2, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index2, e) {
    if (isIgnored2(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c2 = this.cache[abs];
      if (c2 === "DIR" || Array.isArray(c2))
        return;
    }
    this.matches[index2][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    try {
      lstat = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return null;
      if (Array.isArray(c2))
        return c2;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          throw error2;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index2, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index2, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index2) {
    var exists2 = this._stat(prefix);
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists2)
      return;
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path2.join(this.root, prefix);
      } else {
        prefix = path2.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2))
        c2 = "DIR";
      if (!needDir || c2 === "DIR")
        return c2;
      if (needDir && c2 === "FILE")
        return false;
    }
    var stat2 = this.statCache[abs];
    if (!stat2) {
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat2 = this.fs.statSync(abs);
        } catch (er) {
          stat2 = lstat;
        }
      } else {
        stat2 = lstat;
      }
    }
    this.statCache[abs] = stat2;
    var c2 = true;
    if (stat2)
      c2 = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c2;
    if (needDir && c2 === "FILE")
      return false;
    return c2;
  };
  GlobSync.prototype._mark = function(p) {
    return common$12.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common$12.makeAbs(this, f);
  };
  return sync;
}
var wrappy_1 = wrappy$2;
function wrappy$2(fn, cb) {
  if (fn && cb) return wrappy$2(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      });
    }
    return ret;
  }
}
var once$4 = { exports: {} };
var wrappy$1 = wrappy_1;
once$4.exports = wrappy$1(once$3);
once$4.exports.strict = wrappy$1(onceStrict);
once$3.proto = once$3(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once$3(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: true
  });
});
function once$3(fn) {
  var f = function() {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  f.called = false;
  return f;
}
function onceStrict(fn) {
  var f = function() {
    if (f.called)
      throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name = fn.name || "Function wrapped with `once`";
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
var onceExports = once$4.exports;
var wrappy = wrappy_1;
var reqs = /* @__PURE__ */ Object.create(null);
var once$2 = onceExports;
var inflight_1 = wrappy(inflight);
function inflight(key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb);
    return null;
  } else {
    reqs[key] = [cb];
    return makeres(key);
  }
}
function makeres(key) {
  return once$2(function RES() {
    var cbs = reqs[key];
    var len = cbs.length;
    var args = slice(arguments);
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        cbs.splice(0, len);
        process.nextTick(function() {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key];
      }
    }
  });
}
function slice(args) {
  var length = args.length;
  var array = [];
  for (var i = 0; i < length; i++) array[i] = args[i];
  return array;
}
var glob_1;
var hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob) return glob_1;
  hasRequiredGlob = 1;
  glob_1 = glob2;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  minimatch2.Minimatch;
  var inherits2 = requireInherits();
  var EE = require$$2$1.EventEmitter;
  var path2 = require$$1;
  var assert2 = require$$5;
  var isAbsolute2 = pathIsAbsoluteExports;
  var globSync = requireSync();
  var common$12 = common;
  var setopts2 = common$12.setopts;
  var ownProp2 = common$12.ownProp;
  var inflight2 = inflight_1;
  var childrenIgnored2 = common$12.childrenIgnored;
  var isIgnored2 = common$12.isIgnored;
  var once2 = onceExports;
  function glob2(pattern, options, cb) {
    if (typeof options === "function") cb = options, options = {};
    if (!options) options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob2.sync = globSync;
  var GlobSync = glob2.GlobSync = globSync.GlobSync;
  glob2.glob = glob2;
  function extend(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob2.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set2 = g.minimatch.set;
    if (!pattern)
      return false;
    if (set2.length > 1)
      return true;
    for (var j = 0; j < set2[0].length; j++) {
      if (typeof set2[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob2.Glob = Glob;
  inherits2(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts2(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once2(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync3 = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync3 = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync3) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert2(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common$12.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index2, cb) {
    var matchset = this.matches[index2];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set2 = this.matches[index2] = /* @__PURE__ */ Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set2[real] = true;
        else if (er.syscall === "stat")
          set2[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index2] = set2;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common$12.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common$12.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq2 = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq2.length; i++) {
          var e = eq2[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index2, inGlobStar, cb) {
    assert2(this instanceof Glob);
    assert2(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index2, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index2, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute2(prefix) || isAbsolute2(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute2(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored2(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index2, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index2, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path2.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index2, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index2, e) {
    if (this.aborted)
      return;
    if (isIgnored2(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index2, e]);
      return;
    }
    var abs = isAbsolute2(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c2 = this.cache[abs];
      if (c2 === "DIR" || Array.isArray(c2))
        return;
    }
    this.matches[index2][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight2(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight2("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return cb();
      if (Array.isArray(c2))
        return cb(null, c2);
    }
    var self2 = this;
    self2.fs.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          this.emit("error", error2);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index2, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index2, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index2, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists2) {
      self2._processSimple2(prefix, index2, er, exists2, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index2, er, exists2, cb) {
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists2)
      return cb();
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path2.join(this.root, prefix);
      } else {
        prefix = path2.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2))
        c2 = "DIR";
      if (!needDir || c2 === "DIR")
        return cb(null, c2);
      if (needDir && c2 === "FILE")
        return cb();
    }
    var stat2 = this.statCache[abs];
    if (stat2 !== void 0) {
      if (stat2 === false)
        return cb(null, stat2);
      else {
        var type = stat2.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat2);
      }
    }
    var self2 = this;
    var statcb = inflight2("stat\0" + abs, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return self2.fs.stat(abs, function(er2, stat3) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat3, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat2, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat2;
    if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
      return cb(null, false, stat2);
    var c2 = true;
    if (stat2)
      c2 = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c2;
    if (needDir && c2 === "FILE")
      return cb();
    return cb(null, c2, stat2);
  };
  return glob_1;
}
var fs$9 = gracefulFs;
var path$8 = require$$1;
var flatten$1 = lodash_flatten;
var difference$1 = lodash_difference;
var union$1 = lodash_union;
var isPlainObject$1 = lodash_isplainobject;
var glob$3 = requireGlob();
var file$2 = file$3.exports = {};
var pathSeparatorRe$1 = /[\/\\]/g;
var processPatterns$1 = function(patterns, fn) {
  var result = [];
  flatten$1(patterns).forEach(function(pattern) {
    var exclusion = pattern.indexOf("!") === 0;
    if (exclusion) {
      pattern = pattern.slice(1);
    }
    var matches = fn(pattern);
    if (exclusion) {
      result = difference$1(result, matches);
    } else {
      result = union$1(result, matches);
    }
  });
  return result;
};
file$2.exists = function() {
  var filepath = path$8.join.apply(path$8, arguments);
  return fs$9.existsSync(filepath);
};
file$2.expand = function(...args) {
  var options = isPlainObject$1(args[0]) ? args.shift() : {};
  var patterns = Array.isArray(args[0]) ? args[0] : args;
  if (patterns.length === 0) {
    return [];
  }
  var matches = processPatterns$1(patterns, function(pattern) {
    return glob$3.sync(pattern, options);
  });
  if (options.filter) {
    matches = matches.filter(function(filepath) {
      filepath = path$8.join(options.cwd || "", filepath);
      try {
        if (typeof options.filter === "function") {
          return options.filter(filepath);
        } else {
          return fs$9.statSync(filepath)[options.filter]();
        }
      } catch (e) {
        return false;
      }
    });
  }
  return matches;
};
file$2.expandMapping = function(patterns, destBase, options) {
  options = Object.assign({
    rename: function(destBase2, destPath) {
      return path$8.join(destBase2 || "", destPath);
    }
  }, options);
  var files = [];
  var fileByDest = {};
  file$2.expand(options, patterns).forEach(function(src2) {
    var destPath = src2;
    if (options.flatten) {
      destPath = path$8.basename(destPath);
    }
    if (options.ext) {
      destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
    }
    var dest = options.rename(destBase, destPath, options);
    if (options.cwd) {
      src2 = path$8.join(options.cwd, src2);
    }
    dest = dest.replace(pathSeparatorRe$1, "/");
    src2 = src2.replace(pathSeparatorRe$1, "/");
    if (fileByDest[dest]) {
      fileByDest[dest].src.push(src2);
    } else {
      files.push({
        src: [src2],
        dest
      });
      fileByDest[dest] = files[files.length - 1];
    }
  });
  return files;
};
file$2.normalizeFilesArray = function(data) {
  var files = [];
  data.forEach(function(obj) {
    if ("src" in obj || "dest" in obj) {
      files.push(obj);
    }
  });
  if (files.length === 0) {
    return [];
  }
  files = _(files).chain().forEach(function(obj) {
    if (!("src" in obj) || !obj.src) {
      return;
    }
    if (Array.isArray(obj.src)) {
      obj.src = flatten$1(obj.src);
    } else {
      obj.src = [obj.src];
    }
  }).map(function(obj) {
    var expandOptions = Object.assign({}, obj);
    delete expandOptions.src;
    delete expandOptions.dest;
    if (obj.expand) {
      return file$2.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
        var result2 = Object.assign({}, obj);
        result2.orig = Object.assign({}, obj);
        result2.src = mapObj.src;
        result2.dest = mapObj.dest;
        ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
          delete result2[prop];
        });
        return result2;
      });
    }
    var result = Object.assign({}, obj);
    result.orig = Object.assign({}, obj);
    if ("src" in result) {
      Object.defineProperty(result, "src", {
        enumerable: true,
        get: function fn() {
          var src2;
          if (!("result" in fn)) {
            src2 = obj.src;
            src2 = Array.isArray(src2) ? flatten$1(src2) : [src2];
            fn.result = file$2.expand(expandOptions, src2);
          }
          return fn.result;
        }
      });
    }
    if ("dest" in result) {
      result.dest = obj.dest;
    }
    return result;
  }).flatten().value();
  return files;
};
var fileExports$1 = file$3.exports;
var fs$8 = gracefulFs;
var path$7 = require$$1;
var lazystream$1 = lazystream$2;
var normalizePath$2 = normalizePath$3;
var defaults$2 = lodash_defaults;
var Stream$b = require$$0$1.Stream;
var PassThrough$4 = readableExports$1.PassThrough;
var utils$3 = archiverUtils$1.exports = {};
utils$3.file = fileExports$1;
utils$3.collectStream = function(source, callback) {
  var collection = [];
  var size = 0;
  source.on("error", callback);
  source.on("data", function(chunk) {
    collection.push(chunk);
    size += chunk.length;
  });
  source.on("end", function() {
    var buf = new Buffer(size);
    var offset = 0;
    collection.forEach(function(data) {
      data.copy(buf, offset);
      offset += data.length;
    });
    callback(null, buf);
  });
};
utils$3.dateify = function(dateish) {
  dateish = dateish || /* @__PURE__ */ new Date();
  if (dateish instanceof Date) {
    dateish = dateish;
  } else if (typeof dateish === "string") {
    dateish = new Date(dateish);
  } else {
    dateish = /* @__PURE__ */ new Date();
  }
  return dateish;
};
utils$3.defaults = function(object2, source, guard) {
  var args = arguments;
  args[0] = args[0] || {};
  return defaults$2(...args);
};
utils$3.isStream = function(source) {
  return source instanceof Stream$b;
};
utils$3.lazyReadStream = function(filepath) {
  return new lazystream$1.Readable(function() {
    return fs$8.createReadStream(filepath);
  });
};
utils$3.normalizeInputSource = function(source) {
  if (source === null) {
    return new Buffer(0);
  } else if (typeof source === "string") {
    return new Buffer(source);
  } else if (utils$3.isStream(source) && !source._readableState) {
    var normalized = new PassThrough$4();
    source.pipe(normalized);
    return normalized;
  }
  return source;
};
utils$3.sanitizePath = function(filepath) {
  return normalizePath$2(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
};
utils$3.trailingSlashIt = function(str) {
  return str.slice(-1) !== "/" ? str + "/" : str;
};
utils$3.unixifyPath = function(filepath) {
  return normalizePath$2(filepath, false).replace(/^\w+:/, "");
};
utils$3.walkdir = function(dirpath, base, callback) {
  var results = [];
  if (typeof base === "function") {
    callback = base;
    base = dirpath;
  }
  fs$8.readdir(dirpath, function(err2, list) {
    var i = 0;
    var file2;
    var filepath;
    if (err2) {
      return callback(err2);
    }
    (function next() {
      file2 = list[i++];
      if (!file2) {
        return callback(null, results);
      }
      filepath = path$7.join(dirpath, file2);
      fs$8.stat(filepath, function(err3, stats) {
        results.push({
          path: filepath,
          relative: path$7.relative(base, filepath).replace(/\\/g, "/"),
          stats
        });
        if (stats && stats.isDirectory()) {
          utils$3.walkdir(filepath, base, function(err4, res) {
            res.forEach(function(dirEntry) {
              results.push(dirEntry);
            });
            next();
          });
        } else {
          next();
        }
      });
    })();
  });
};
var archiverUtilsExports$1 = archiverUtils$1.exports;
var error = { exports: {} };
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
(function(module, exports) {
  var util2 = require$$0$4;
  const ERROR_CODES = {
    "ABORTED": "archive was aborted",
    "DIRECTORYDIRPATHREQUIRED": "diretory dirpath argument must be a non-empty string value",
    "DIRECTORYFUNCTIONINVALIDDATA": "invalid data returned by directory custom data function",
    "ENTRYNAMEREQUIRED": "entry name must be a non-empty string value",
    "FILEFILEPATHREQUIRED": "file filepath argument must be a non-empty string value",
    "FINALIZING": "archive already finalizing",
    "QUEUECLOSED": "queue closed",
    "NOENDMETHOD": "no suitable finalize/end method defined by module",
    "DIRECTORYNOTSUPPORTED": "support for directory entries not defined by module",
    "FORMATSET": "archive format already set",
    "INPUTSTEAMBUFFERREQUIRED": "input source must be valid Stream or Buffer instance",
    "MODULESET": "module already set",
    "SYMLINKNOTSUPPORTED": "support for symlink entries not defined by module",
    "SYMLINKFILEPATHREQUIRED": "symlink filepath argument must be a non-empty string value",
    "SYMLINKTARGETREQUIRED": "symlink target argument must be a non-empty string value",
    "ENTRYNOTSUPPORTED": "entry not supported"
  };
  function ArchiverError2(code, data) {
    Error.captureStackTrace(this, this.constructor);
    this.message = ERROR_CODES[code] || code;
    this.code = code;
    this.data = data;
  }
  util2.inherits(ArchiverError2, Error);
  module.exports = ArchiverError2;
})(error);
var errorExports = error.exports;
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var fs$7 = require$$0$2;
var glob$2 = readdirGlob_1;
var async$1 = require$$2;
var path$6 = require$$1;
var util$e = archiverUtilsExports$1;
var inherits$8 = require$$0$4.inherits;
var ArchiverError = errorExports;
var Transform$3 = readableExports$3.Transform;
var win32 = process.platform === "win32";
var Archiver$2 = function(format, options) {
  if (!(this instanceof Archiver$2)) {
    return new Archiver$2(format, options);
  }
  if (typeof format !== "string") {
    options = format;
    format = "zip";
  }
  options = this.options = util$e.defaults(options, {
    highWaterMark: 1024 * 1024,
    statConcurrency: 4
  });
  Transform$3.call(this, options);
  this._format = false;
  this._module = false;
  this._pending = 0;
  this._pointer = 0;
  this._entriesCount = 0;
  this._entriesProcessedCount = 0;
  this._fsEntriesTotalBytes = 0;
  this._fsEntriesProcessedBytes = 0;
  this._queue = async$1.queue(this._onQueueTask.bind(this), 1);
  this._queue.drain(this._onQueueDrain.bind(this));
  this._statQueue = async$1.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
  this._statQueue.drain(this._onQueueDrain.bind(this));
  this._state = {
    aborted: false,
    finalize: false,
    finalizing: false,
    finalized: false,
    modulePiped: false
  };
  this._streams = [];
};
inherits$8(Archiver$2, Transform$3);
Archiver$2.prototype._abort = function() {
  this._state.aborted = true;
  this._queue.kill();
  this._statQueue.kill();
  if (this._queue.idle()) {
    this._shutdown();
  }
};
Archiver$2.prototype._append = function(filepath, data) {
  data = data || {};
  var task = {
    source: null,
    filepath
  };
  if (!data.name) {
    data.name = filepath;
  }
  data.sourcePath = filepath;
  task.data = data;
  this._entriesCount++;
  if (data.stats && data.stats instanceof fs$7.Stats) {
    task = this._updateQueueTaskWithStats(task, data.stats);
    if (task) {
      if (data.stats.size) {
        this._fsEntriesTotalBytes += data.stats.size;
      }
      this._queue.push(task);
    }
  } else {
    this._statQueue.push(task);
  }
};
Archiver$2.prototype._finalize = function() {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    return;
  }
  this._state.finalizing = true;
  this._moduleFinalize();
  this._state.finalizing = false;
  this._state.finalized = true;
};
Archiver$2.prototype._maybeFinalize = function() {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    return false;
  }
  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
    this._finalize();
    return true;
  }
  return false;
};
Archiver$2.prototype._moduleAppend = function(source, data, callback) {
  if (this._state.aborted) {
    callback();
    return;
  }
  this._module.append(source, data, (function(err2) {
    this._task = null;
    if (this._state.aborted) {
      this._shutdown();
      return;
    }
    if (err2) {
      this.emit("error", err2);
      setImmediate(callback);
      return;
    }
    this.emit("entry", data);
    this._entriesProcessedCount++;
    if (data.stats && data.stats.size) {
      this._fsEntriesProcessedBytes += data.stats.size;
    }
    this.emit("progress", {
      entries: {
        total: this._entriesCount,
        processed: this._entriesProcessedCount
      },
      fs: {
        totalBytes: this._fsEntriesTotalBytes,
        processedBytes: this._fsEntriesProcessedBytes
      }
    });
    setImmediate(callback);
  }).bind(this));
};
Archiver$2.prototype._moduleFinalize = function() {
  if (typeof this._module.finalize === "function") {
    this._module.finalize();
  } else if (typeof this._module.end === "function") {
    this._module.end();
  } else {
    this.emit("error", new ArchiverError("NOENDMETHOD"));
  }
};
Archiver$2.prototype._modulePipe = function() {
  this._module.on("error", this._onModuleError.bind(this));
  this._module.pipe(this);
  this._state.modulePiped = true;
};
Archiver$2.prototype._moduleSupports = function(key) {
  if (!this._module.supports || !this._module.supports[key]) {
    return false;
  }
  return this._module.supports[key];
};
Archiver$2.prototype._moduleUnpipe = function() {
  this._module.unpipe(this);
  this._state.modulePiped = false;
};
Archiver$2.prototype._normalizeEntryData = function(data, stats) {
  data = util$e.defaults(data, {
    type: "file",
    name: null,
    date: null,
    mode: null,
    prefix: null,
    sourcePath: null,
    stats: false
  });
  if (stats && data.stats === false) {
    data.stats = stats;
  }
  var isDir = data.type === "directory";
  if (data.name) {
    if (typeof data.prefix === "string" && "" !== data.prefix) {
      data.name = data.prefix + "/" + data.name;
      data.prefix = null;
    }
    data.name = util$e.sanitizePath(data.name);
    if (data.type !== "symlink" && data.name.slice(-1) === "/") {
      isDir = true;
      data.type = "directory";
    } else if (isDir) {
      data.name += "/";
    }
  }
  if (typeof data.mode === "number") {
    if (win32) {
      data.mode &= 511;
    } else {
      data.mode &= 4095;
    }
  } else if (data.stats && data.mode === null) {
    if (win32) {
      data.mode = data.stats.mode & 511;
    } else {
      data.mode = data.stats.mode & 4095;
    }
    if (win32 && isDir) {
      data.mode = 493;
    }
  } else if (data.mode === null) {
    data.mode = isDir ? 493 : 420;
  }
  if (data.stats && data.date === null) {
    data.date = data.stats.mtime;
  } else {
    data.date = util$e.dateify(data.date);
  }
  return data;
};
Archiver$2.prototype._onModuleError = function(err2) {
  this.emit("error", err2);
};
Archiver$2.prototype._onQueueDrain = function() {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    return;
  }
  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
    this._finalize();
  }
};
Archiver$2.prototype._onQueueTask = function(task, callback) {
  var fullCallback = () => {
    if (task.data.callback) {
      task.data.callback();
    }
    callback();
  };
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    fullCallback();
    return;
  }
  this._task = task;
  this._moduleAppend(task.source, task.data, fullCallback);
};
Archiver$2.prototype._onStatQueueTask = function(task, callback) {
  if (this._state.finalizing || this._state.finalized || this._state.aborted) {
    callback();
    return;
  }
  fs$7.lstat(task.filepath, (function(err2, stats) {
    if (this._state.aborted) {
      setImmediate(callback);
      return;
    }
    if (err2) {
      this._entriesCount--;
      this.emit("warning", err2);
      setImmediate(callback);
      return;
    }
    task = this._updateQueueTaskWithStats(task, stats);
    if (task) {
      if (stats.size) {
        this._fsEntriesTotalBytes += stats.size;
      }
      this._queue.push(task);
    }
    setImmediate(callback);
  }).bind(this));
};
Archiver$2.prototype._shutdown = function() {
  this._moduleUnpipe();
  this.end();
};
Archiver$2.prototype._transform = function(chunk, encoding, callback) {
  if (chunk) {
    this._pointer += chunk.length;
  }
  callback(null, chunk);
};
Archiver$2.prototype._updateQueueTaskWithStats = function(task, stats) {
  if (stats.isFile()) {
    task.data.type = "file";
    task.data.sourceType = "stream";
    task.source = util$e.lazyReadStream(task.filepath);
  } else if (stats.isDirectory() && this._moduleSupports("directory")) {
    task.data.name = util$e.trailingSlashIt(task.data.name);
    task.data.type = "directory";
    task.data.sourcePath = util$e.trailingSlashIt(task.filepath);
    task.data.sourceType = "buffer";
    task.source = Buffer.concat([]);
  } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
    var linkPath = fs$7.readlinkSync(task.filepath);
    var dirName = path$6.dirname(task.filepath);
    task.data.type = "symlink";
    task.data.linkname = path$6.relative(dirName, path$6.resolve(dirName, linkPath));
    task.data.sourceType = "buffer";
    task.source = Buffer.concat([]);
  } else {
    if (stats.isDirectory()) {
      this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
    } else if (stats.isSymbolicLink()) {
      this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
    } else {
      this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
    }
    return null;
  }
  task.data = this._normalizeEntryData(task.data, stats);
  return task;
};
Archiver$2.prototype.abort = function() {
  if (this._state.aborted || this._state.finalized) {
    return this;
  }
  this._abort();
  return this;
};
Archiver$2.prototype.append = function(source, data) {
  if (this._state.finalize || this._state.aborted) {
    this.emit("error", new ArchiverError("QUEUECLOSED"));
    return this;
  }
  data = this._normalizeEntryData(data);
  if (typeof data.name !== "string" || data.name.length === 0) {
    this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
    return this;
  }
  if (data.type === "directory" && !this._moduleSupports("directory")) {
    this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
    return this;
  }
  source = util$e.normalizeInputSource(source);
  if (Buffer.isBuffer(source)) {
    data.sourceType = "buffer";
  } else if (util$e.isStream(source)) {
    data.sourceType = "stream";
  } else {
    this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
    return this;
  }
  this._entriesCount++;
  this._queue.push({
    data,
    source
  });
  return this;
};
Archiver$2.prototype.directory = function(dirpath, destpath, data) {
  if (this._state.finalize || this._state.aborted) {
    this.emit("error", new ArchiverError("QUEUECLOSED"));
    return this;
  }
  if (typeof dirpath !== "string" || dirpath.length === 0) {
    this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
    return this;
  }
  this._pending++;
  if (destpath === false) {
    destpath = "";
  } else if (typeof destpath !== "string") {
    destpath = dirpath;
  }
  var dataFunction = false;
  if (typeof data === "function") {
    dataFunction = data;
    data = {};
  } else if (typeof data !== "object") {
    data = {};
  }
  var globOptions = {
    stat: true,
    dot: true
  };
  function onGlobEnd() {
    this._pending--;
    this._maybeFinalize();
  }
  function onGlobError(err2) {
    this.emit("error", err2);
  }
  function onGlobMatch(match2) {
    globber.pause();
    var ignoreMatch = false;
    var entryData = Object.assign({}, data);
    entryData.name = match2.relative;
    entryData.prefix = destpath;
    entryData.stats = match2.stat;
    entryData.callback = globber.resume.bind(globber);
    try {
      if (dataFunction) {
        entryData = dataFunction(entryData);
        if (entryData === false) {
          ignoreMatch = true;
        } else if (typeof entryData !== "object") {
          throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
        }
      }
    } catch (e) {
      this.emit("error", e);
      return;
    }
    if (ignoreMatch) {
      globber.resume();
      return;
    }
    this._append(match2.absolute, entryData);
  }
  var globber = glob$2(dirpath, globOptions);
  globber.on("error", onGlobError.bind(this));
  globber.on("match", onGlobMatch.bind(this));
  globber.on("end", onGlobEnd.bind(this));
  return this;
};
Archiver$2.prototype.file = function(filepath, data) {
  if (this._state.finalize || this._state.aborted) {
    this.emit("error", new ArchiverError("QUEUECLOSED"));
    return this;
  }
  if (typeof filepath !== "string" || filepath.length === 0) {
    this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
    return this;
  }
  this._append(filepath, data);
  return this;
};
Archiver$2.prototype.glob = function(pattern, options, data) {
  this._pending++;
  options = util$e.defaults(options, {
    stat: true,
    pattern
  });
  function onGlobEnd() {
    this._pending--;
    this._maybeFinalize();
  }
  function onGlobError(err2) {
    this.emit("error", err2);
  }
  function onGlobMatch(match2) {
    globber.pause();
    var entryData = Object.assign({}, data);
    entryData.callback = globber.resume.bind(globber);
    entryData.stats = match2.stat;
    entryData.name = match2.relative;
    this._append(match2.absolute, entryData);
  }
  var globber = glob$2(options.cwd || ".", options);
  globber.on("error", onGlobError.bind(this));
  globber.on("match", onGlobMatch.bind(this));
  globber.on("end", onGlobEnd.bind(this));
  return this;
};
Archiver$2.prototype.finalize = function() {
  if (this._state.aborted) {
    var abortedError = new ArchiverError("ABORTED");
    this.emit("error", abortedError);
    return Promise.reject(abortedError);
  }
  if (this._state.finalize) {
    var finalizingError = new ArchiverError("FINALIZING");
    this.emit("error", finalizingError);
    return Promise.reject(finalizingError);
  }
  this._state.finalize = true;
  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
    this._finalize();
  }
  var self2 = this;
  return new Promise(function(resolve2, reject2) {
    var errored;
    self2._module.on("end", function() {
      if (!errored) {
        resolve2();
      }
    });
    self2._module.on("error", function(err2) {
      errored = true;
      reject2(err2);
    });
  });
};
Archiver$2.prototype.setFormat = function(format) {
  if (this._format) {
    this.emit("error", new ArchiverError("FORMATSET"));
    return this;
  }
  this._format = format;
  return this;
};
Archiver$2.prototype.setModule = function(module) {
  if (this._state.aborted) {
    this.emit("error", new ArchiverError("ABORTED"));
    return this;
  }
  if (this._state.module) {
    this.emit("error", new ArchiverError("MODULESET"));
    return this;
  }
  this._module = module;
  this._modulePipe();
  return this;
};
Archiver$2.prototype.symlink = function(filepath, target, mode) {
  if (this._state.finalize || this._state.aborted) {
    this.emit("error", new ArchiverError("QUEUECLOSED"));
    return this;
  }
  if (typeof filepath !== "string" || filepath.length === 0) {
    this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
    return this;
  }
  if (typeof target !== "string" || target.length === 0) {
    this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
    return this;
  }
  if (!this._moduleSupports("symlink")) {
    this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
    return this;
  }
  var data = {};
  data.type = "symlink";
  data.name = filepath.replace(/\\/g, "/");
  data.linkname = target.replace(/\\/g, "/");
  data.sourceType = "buffer";
  if (typeof mode === "number") {
    data.mode = mode;
  }
  this._entriesCount++;
  this._queue.push({
    data,
    source: Buffer.concat([])
  });
  return this;
};
Archiver$2.prototype.pointer = function() {
  return this._pointer;
};
Archiver$2.prototype.use = function(plugin) {
  this._streams.push(plugin);
  return this;
};
var core = Archiver$2;
var zipStream = { exports: {} };
var archiveEntry = { exports: {} };
var ArchiveEntry$2 = archiveEntry.exports = function() {
};
ArchiveEntry$2.prototype.getName = function() {
};
ArchiveEntry$2.prototype.getSize = function() {
};
ArchiveEntry$2.prototype.getLastModifiedDate = function() {
};
ArchiveEntry$2.prototype.isDirectory = function() {
};
var archiveEntryExports = archiveEntry.exports;
var zipArchiveEntry = { exports: {} };
var generalPurposeBit = { exports: {} };
var util$d = { exports: {} };
var util$c = util$d.exports = {};
util$c.dateToDos = function(d, forceLocalTime) {
  forceLocalTime = forceLocalTime || false;
  var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
  if (year < 1980) {
    return 2162688;
  } else if (year >= 2044) {
    return 2141175677;
  }
  var val = {
    year,
    month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
    date: forceLocalTime ? d.getDate() : d.getUTCDate(),
    hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
    minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
    seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
  };
  return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
};
util$c.dosToDate = function(dos) {
  return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
};
util$c.fromDosTime = function(buf) {
  return util$c.dosToDate(buf.readUInt32LE(0));
};
util$c.getEightBytes = function(v) {
  var buf = Buffer.alloc(8);
  buf.writeUInt32LE(v % 4294967296, 0);
  buf.writeUInt32LE(v / 4294967296 | 0, 4);
  return buf;
};
util$c.getShortBytes = function(v) {
  var buf = Buffer.alloc(2);
  buf.writeUInt16LE((v & 65535) >>> 0, 0);
  return buf;
};
util$c.getShortBytesValue = function(buf, offset) {
  return buf.readUInt16LE(offset);
};
util$c.getLongBytes = function(v) {
  var buf = Buffer.alloc(4);
  buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
  return buf;
};
util$c.getLongBytesValue = function(buf, offset) {
  return buf.readUInt32LE(offset);
};
util$c.toDosTime = function(d) {
  return util$c.getLongBytes(util$c.dateToDos(d));
};
var utilExports$1 = util$d.exports;
var zipUtil$2 = utilExports$1;
var DATA_DESCRIPTOR_FLAG = 1 << 3;
var ENCRYPTION_FLAG = 1 << 0;
var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
var STRONG_ENCRYPTION_FLAG = 1 << 6;
var UFT8_NAMES_FLAG = 1 << 11;
var GeneralPurposeBit$1 = generalPurposeBit.exports = function() {
  if (!(this instanceof GeneralPurposeBit$1)) {
    return new GeneralPurposeBit$1();
  }
  this.descriptor = false;
  this.encryption = false;
  this.utf8 = false;
  this.numberOfShannonFanoTrees = 0;
  this.strongEncryption = false;
  this.slidingDictionarySize = 0;
  return this;
};
GeneralPurposeBit$1.prototype.encode = function() {
  return zipUtil$2.getShortBytes(
    (this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0)
  );
};
GeneralPurposeBit$1.prototype.parse = function(buf, offset) {
  var flag = zipUtil$2.getShortBytesValue(buf, offset);
  var gbp = new GeneralPurposeBit$1();
  gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
  gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
  gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
  gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
  gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
  gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
  return gbp;
};
GeneralPurposeBit$1.prototype.setNumberOfShannonFanoTrees = function(n) {
  this.numberOfShannonFanoTrees = n;
};
GeneralPurposeBit$1.prototype.getNumberOfShannonFanoTrees = function() {
  return this.numberOfShannonFanoTrees;
};
GeneralPurposeBit$1.prototype.setSlidingDictionarySize = function(n) {
  this.slidingDictionarySize = n;
};
GeneralPurposeBit$1.prototype.getSlidingDictionarySize = function() {
  return this.slidingDictionarySize;
};
GeneralPurposeBit$1.prototype.useDataDescriptor = function(b) {
  this.descriptor = b;
};
GeneralPurposeBit$1.prototype.usesDataDescriptor = function() {
  return this.descriptor;
};
GeneralPurposeBit$1.prototype.useEncryption = function(b) {
  this.encryption = b;
};
GeneralPurposeBit$1.prototype.usesEncryption = function() {
  return this.encryption;
};
GeneralPurposeBit$1.prototype.useStrongEncryption = function(b) {
  this.strongEncryption = b;
};
GeneralPurposeBit$1.prototype.usesStrongEncryption = function() {
  return this.strongEncryption;
};
GeneralPurposeBit$1.prototype.useUTF8ForNames = function(b) {
  this.utf8 = b;
};
GeneralPurposeBit$1.prototype.usesUTF8ForNames = function() {
  return this.utf8;
};
var generalPurposeBitExports = generalPurposeBit.exports;
var unixStat = {
  /**
   * Bits used to indicate the filesystem object type.
   */
  FILE_TYPE_FLAG: 61440,
  // 0170000
  /**
   * Indicates symbolic links.
   */
  LINK_FLAG: 40960
};
var constants$3 = {
  EMPTY: Buffer.alloc(0),
  SHORT_MASK: 65535,
  SHORT_SHIFT: 16,
  SHORT_ZERO: Buffer.from(Array(2)),
  LONG_ZERO: Buffer.from(Array(4)),
  MIN_VERSION_INITIAL: 10,
  MIN_VERSION_DATA_DESCRIPTOR: 20,
  MIN_VERSION_ZIP64: 45,
  VERSION_MADEBY: 45,
  METHOD_STORED: 0,
  METHOD_DEFLATED: 8,
  PLATFORM_UNIX: 3,
  PLATFORM_FAT: 0,
  SIG_LFH: 67324752,
  SIG_DD: 134695760,
  SIG_CFH: 33639248,
  SIG_EOCD: 101010256,
  SIG_ZIP64_EOCD: 101075792,
  SIG_ZIP64_EOCD_LOC: 117853008,
  ZIP64_MAGIC_SHORT: 65535,
  ZIP64_MAGIC: 4294967295,
  ZIP64_EXTRA_ID: 1,
  ZLIB_BEST_SPEED: 1,
  MODE_MASK: 4095,
  S_IFDIR: 16384,
  // 040000 directory
  S_IFREG: 32768,
  // 0100000 regular
  // DOS file type flags
  S_DOS_A: 32,
  // 040 Archive
  S_DOS_D: 16
};
var inherits$7 = require$$0$4.inherits;
var normalizePath$1 = normalizePath$3;
var ArchiveEntry$1 = archiveEntryExports;
var GeneralPurposeBit = generalPurposeBitExports;
var UnixStat = unixStat;
var constants$2 = constants$3;
var zipUtil$1 = utilExports$1;
var ZipArchiveEntry$1 = zipArchiveEntry.exports = function(name) {
  if (!(this instanceof ZipArchiveEntry$1)) {
    return new ZipArchiveEntry$1(name);
  }
  ArchiveEntry$1.call(this);
  this.platform = constants$2.PLATFORM_FAT;
  this.method = -1;
  this.name = null;
  this.size = 0;
  this.csize = 0;
  this.gpb = new GeneralPurposeBit();
  this.crc = 0;
  this.time = -1;
  this.minver = constants$2.MIN_VERSION_INITIAL;
  this.mode = -1;
  this.extra = null;
  this.exattr = 0;
  this.inattr = 0;
  this.comment = null;
  if (name) {
    this.setName(name);
  }
};
inherits$7(ZipArchiveEntry$1, ArchiveEntry$1);
ZipArchiveEntry$1.prototype.getCentralDirectoryExtra = function() {
  return this.getExtra();
};
ZipArchiveEntry$1.prototype.getComment = function() {
  return this.comment !== null ? this.comment : "";
};
ZipArchiveEntry$1.prototype.getCompressedSize = function() {
  return this.csize;
};
ZipArchiveEntry$1.prototype.getCrc = function() {
  return this.crc;
};
ZipArchiveEntry$1.prototype.getExternalAttributes = function() {
  return this.exattr;
};
ZipArchiveEntry$1.prototype.getExtra = function() {
  return this.extra !== null ? this.extra : constants$2.EMPTY;
};
ZipArchiveEntry$1.prototype.getGeneralPurposeBit = function() {
  return this.gpb;
};
ZipArchiveEntry$1.prototype.getInternalAttributes = function() {
  return this.inattr;
};
ZipArchiveEntry$1.prototype.getLastModifiedDate = function() {
  return this.getTime();
};
ZipArchiveEntry$1.prototype.getLocalFileDataExtra = function() {
  return this.getExtra();
};
ZipArchiveEntry$1.prototype.getMethod = function() {
  return this.method;
};
ZipArchiveEntry$1.prototype.getName = function() {
  return this.name;
};
ZipArchiveEntry$1.prototype.getPlatform = function() {
  return this.platform;
};
ZipArchiveEntry$1.prototype.getSize = function() {
  return this.size;
};
ZipArchiveEntry$1.prototype.getTime = function() {
  return this.time !== -1 ? zipUtil$1.dosToDate(this.time) : -1;
};
ZipArchiveEntry$1.prototype.getTimeDos = function() {
  return this.time !== -1 ? this.time : 0;
};
ZipArchiveEntry$1.prototype.getUnixMode = function() {
  return this.platform !== constants$2.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants$2.SHORT_SHIFT & constants$2.SHORT_MASK;
};
ZipArchiveEntry$1.prototype.getVersionNeededToExtract = function() {
  return this.minver;
};
ZipArchiveEntry$1.prototype.setComment = function(comment) {
  if (Buffer.byteLength(comment) !== comment.length) {
    this.getGeneralPurposeBit().useUTF8ForNames(true);
  }
  this.comment = comment;
};
ZipArchiveEntry$1.prototype.setCompressedSize = function(size) {
  if (size < 0) {
    throw new Error("invalid entry compressed size");
  }
  this.csize = size;
};
ZipArchiveEntry$1.prototype.setCrc = function(crc2) {
  if (crc2 < 0) {
    throw new Error("invalid entry crc32");
  }
  this.crc = crc2;
};
ZipArchiveEntry$1.prototype.setExternalAttributes = function(attr) {
  this.exattr = attr >>> 0;
};
ZipArchiveEntry$1.prototype.setExtra = function(extra) {
  this.extra = extra;
};
ZipArchiveEntry$1.prototype.setGeneralPurposeBit = function(gpb) {
  if (!(gpb instanceof GeneralPurposeBit)) {
    throw new Error("invalid entry GeneralPurposeBit");
  }
  this.gpb = gpb;
};
ZipArchiveEntry$1.prototype.setInternalAttributes = function(attr) {
  this.inattr = attr;
};
ZipArchiveEntry$1.prototype.setMethod = function(method2) {
  if (method2 < 0) {
    throw new Error("invalid entry compression method");
  }
  this.method = method2;
};
ZipArchiveEntry$1.prototype.setName = function(name, prependSlash = false) {
  name = normalizePath$1(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  if (prependSlash) {
    name = `/${name}`;
  }
  if (Buffer.byteLength(name) !== name.length) {
    this.getGeneralPurposeBit().useUTF8ForNames(true);
  }
  this.name = name;
};
ZipArchiveEntry$1.prototype.setPlatform = function(platform2) {
  this.platform = platform2;
};
ZipArchiveEntry$1.prototype.setSize = function(size) {
  if (size < 0) {
    throw new Error("invalid entry size");
  }
  this.size = size;
};
ZipArchiveEntry$1.prototype.setTime = function(time, forceLocalTime) {
  if (!(time instanceof Date)) {
    throw new Error("invalid entry time");
  }
  this.time = zipUtil$1.dateToDos(time, forceLocalTime);
};
ZipArchiveEntry$1.prototype.setUnixMode = function(mode) {
  mode |= this.isDirectory() ? constants$2.S_IFDIR : constants$2.S_IFREG;
  var extattr = 0;
  extattr |= mode << constants$2.SHORT_SHIFT | (this.isDirectory() ? constants$2.S_DOS_D : constants$2.S_DOS_A);
  this.setExternalAttributes(extattr);
  this.mode = mode & constants$2.MODE_MASK;
  this.platform = constants$2.PLATFORM_UNIX;
};
ZipArchiveEntry$1.prototype.setVersionNeededToExtract = function(minver) {
  this.minver = minver;
};
ZipArchiveEntry$1.prototype.isDirectory = function() {
  return this.getName().slice(-1) === "/";
};
ZipArchiveEntry$1.prototype.isUnixSymlink = function() {
  return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
};
ZipArchiveEntry$1.prototype.isZip64 = function() {
  return this.csize > constants$2.ZIP64_MAGIC || this.size > constants$2.ZIP64_MAGIC;
};
var zipArchiveEntryExports = zipArchiveEntry.exports;
var archiveOutputStream = { exports: {} };
var util$b = { exports: {} };
var Stream$a = require$$0$1.Stream;
var PassThrough$3 = readableExports$3.PassThrough;
var util$a = util$b.exports = {};
util$a.isStream = function(source) {
  return source instanceof Stream$a;
};
util$a.normalizeInputSource = function(source) {
  if (source === null) {
    return Buffer.alloc(0);
  } else if (typeof source === "string") {
    return Buffer.from(source);
  } else if (util$a.isStream(source) && !source._readableState) {
    var normalized = new PassThrough$3();
    source.pipe(normalized);
    return normalized;
  }
  return source;
};
var utilExports = util$b.exports;
var inherits$6 = require$$0$4.inherits;
var Transform$2 = readableExports$3.Transform;
var ArchiveEntry = archiveEntryExports;
var util$9 = utilExports;
var ArchiveOutputStream$1 = archiveOutputStream.exports = function(options) {
  if (!(this instanceof ArchiveOutputStream$1)) {
    return new ArchiveOutputStream$1(options);
  }
  Transform$2.call(this, options);
  this.offset = 0;
  this._archive = {
    finish: false,
    finished: false,
    processing: false
  };
};
inherits$6(ArchiveOutputStream$1, Transform$2);
ArchiveOutputStream$1.prototype._appendBuffer = function(zae, source, callback) {
};
ArchiveOutputStream$1.prototype._appendStream = function(zae, source, callback) {
};
ArchiveOutputStream$1.prototype._emitErrorCallback = function(err2) {
  if (err2) {
    this.emit("error", err2);
  }
};
ArchiveOutputStream$1.prototype._finish = function(ae) {
};
ArchiveOutputStream$1.prototype._normalizeEntry = function(ae) {
};
ArchiveOutputStream$1.prototype._transform = function(chunk, encoding, callback) {
  callback(null, chunk);
};
ArchiveOutputStream$1.prototype.entry = function(ae, source, callback) {
  source = source || null;
  if (typeof callback !== "function") {
    callback = this._emitErrorCallback.bind(this);
  }
  if (!(ae instanceof ArchiveEntry)) {
    callback(new Error("not a valid instance of ArchiveEntry"));
    return;
  }
  if (this._archive.finish || this._archive.finished) {
    callback(new Error("unacceptable entry after finish"));
    return;
  }
  if (this._archive.processing) {
    callback(new Error("already processing an entry"));
    return;
  }
  this._archive.processing = true;
  this._normalizeEntry(ae);
  this._entry = ae;
  source = util$9.normalizeInputSource(source);
  if (Buffer.isBuffer(source)) {
    this._appendBuffer(ae, source, callback);
  } else if (util$9.isStream(source)) {
    this._appendStream(ae, source, callback);
  } else {
    this._archive.processing = false;
    callback(new Error("input source must be valid Stream or Buffer instance"));
    return;
  }
  return this;
};
ArchiveOutputStream$1.prototype.finish = function() {
  if (this._archive.processing) {
    this._archive.finish = true;
    return;
  }
  this._finish();
};
ArchiveOutputStream$1.prototype.getBytesWritten = function() {
  return this.offset;
};
ArchiveOutputStream$1.prototype.write = function(chunk, cb) {
  if (chunk) {
    this.offset += chunk.length;
  }
  return Transform$2.prototype.write.call(this, chunk, cb);
};
var archiveOutputStreamExports = archiveOutputStream.exports;
var zipArchiveOutputStream = { exports: {} };
var Buffer$8 = require$$0$3.Buffer;
var CRC_TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}
function ensureBuffer(input) {
  if (Buffer$8.isBuffer(input)) {
    return input;
  }
  var hasNewBufferAPI = typeof Buffer$8.alloc === "function" && typeof Buffer$8.from === "function";
  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer$8.alloc(input) : new Buffer$8(input);
  } else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer$8.from(input) : new Buffer$8(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
}
function bufferizeInt(num) {
  var tmp2 = ensureBuffer(4);
  tmp2.writeInt32BE(num, 0);
  return tmp2;
}
function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer$8.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc2 = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc2 = CRC_TABLE[(crc2 ^ buf[n]) & 255] ^ crc2 >>> 8;
  }
  return crc2 ^ -1;
}
function crc32$5() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32$5.signed = function() {
  return _crc32.apply(null, arguments);
};
crc32$5.unsigned = function() {
  return _crc32.apply(null, arguments) >>> 0;
};
var bufferCrc32 = crc32$5;
var crc32$4 = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(exports) {
  (function(factory) {
    if (typeof DO_NOT_EXPORT_CRC === "undefined") {
      {
        factory(exports);
      }
    } else {
      factory({});
    }
  })(function(CRC32) {
    CRC32.version = "1.2.2";
    function signed_crc_table() {
      var c2 = 0, table2 = new Array(256);
      for (var n = 0; n != 256; ++n) {
        c2 = n;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
        table2[n] = c2;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table2) : table2;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c2 = 0, v = 0, n = 0, table2 = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0; n != 256; ++n) table2[n] = T[n];
      for (n = 0; n != 256; ++n) {
        v = T[n];
        for (c2 = 256 + n; c2 < 4096; c2 += 256) v = table2[c2] = v >>> 8 ^ T[v & 255];
      }
      var out2 = [];
      for (n = 1; n != 16; ++n) out2[n - 1] = typeof Int32Array !== "undefined" ? table2.subarray(n * 256, n * 256 + 256) : table2.slice(n * 256, n * 256 + 256);
      return out2;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length; i < L; ) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (; i < L; ) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c2 = 0, d = 0; i < L; ) {
        c2 = str.charCodeAt(i++);
        if (c2 < 128) {
          C = C >>> 8 ^ T0[(C ^ c2) & 255];
        } else if (c2 < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c2 >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 & 63)) & 255];
        } else if (c2 >= 55296 && c2 < 57344) {
          c2 = (c2 & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c2 >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c2 & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c2 >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c2 & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC32.table = T0;
    CRC32.bstr = crc32_bstr;
    CRC32.buf = crc32_buf;
    CRC32.str = crc32_str;
  });
})(crc32$4);
const { Transform: Transform$1 } = readableExports$3;
const crc32$3 = crc32$4;
let CRC32Stream$1 = class CRC32Stream extends Transform$1 {
  constructor(options) {
    super(options);
    this.checksum = Buffer.allocUnsafe(4);
    this.checksum.writeInt32BE(0, 0);
    this.rawSize = 0;
  }
  _transform(chunk, encoding, callback) {
    if (chunk) {
      this.checksum = crc32$3.buf(chunk, this.checksum) >>> 0;
      this.rawSize += chunk.length;
    }
    callback(null, chunk);
  }
  digest(encoding) {
    const checksum = Buffer.allocUnsafe(4);
    checksum.writeUInt32BE(this.checksum >>> 0, 0);
    return encoding ? checksum.toString(encoding) : checksum;
  }
  hex() {
    return this.digest("hex").toUpperCase();
  }
  size() {
    return this.rawSize;
  }
};
var crc32Stream = CRC32Stream$1;
const { DeflateRaw } = require$$0$7;
const crc32$2 = crc32$4;
let DeflateCRC32Stream$1 = class DeflateCRC32Stream extends DeflateRaw {
  constructor(options) {
    super(options);
    this.checksum = Buffer.allocUnsafe(4);
    this.checksum.writeInt32BE(0, 0);
    this.rawSize = 0;
    this.compressedSize = 0;
  }
  push(chunk, encoding) {
    if (chunk) {
      this.compressedSize += chunk.length;
    }
    return super.push(chunk, encoding);
  }
  _transform(chunk, encoding, callback) {
    if (chunk) {
      this.checksum = crc32$2.buf(chunk, this.checksum) >>> 0;
      this.rawSize += chunk.length;
    }
    super._transform(chunk, encoding, callback);
  }
  digest(encoding) {
    const checksum = Buffer.allocUnsafe(4);
    checksum.writeUInt32BE(this.checksum >>> 0, 0);
    return encoding ? checksum.toString(encoding) : checksum;
  }
  hex() {
    return this.digest("hex").toUpperCase();
  }
  size(compressed = false) {
    if (compressed) {
      return this.compressedSize;
    } else {
      return this.rawSize;
    }
  }
};
var deflateCrc32Stream = DeflateCRC32Stream$1;
var lib = {
  CRC32Stream: crc32Stream,
  DeflateCRC32Stream: deflateCrc32Stream
};
var inherits$5 = require$$0$4.inherits;
var crc32$1 = bufferCrc32;
var { CRC32Stream: CRC32Stream2 } = lib;
var { DeflateCRC32Stream: DeflateCRC32Stream2 } = lib;
var ArchiveOutputStream = archiveOutputStreamExports;
var constants$1 = constants$3;
var zipUtil = utilExports$1;
var ZipArchiveOutputStream$1 = zipArchiveOutputStream.exports = function(options) {
  if (!(this instanceof ZipArchiveOutputStream$1)) {
    return new ZipArchiveOutputStream$1(options);
  }
  options = this.options = this._defaults(options);
  ArchiveOutputStream.call(this, options);
  this._entry = null;
  this._entries = [];
  this._archive = {
    centralLength: 0,
    centralOffset: 0,
    comment: "",
    finish: false,
    finished: false,
    processing: false,
    forceZip64: options.forceZip64,
    forceLocalTime: options.forceLocalTime
  };
};
inherits$5(ZipArchiveOutputStream$1, ArchiveOutputStream);
ZipArchiveOutputStream$1.prototype._afterAppend = function(ae) {
  this._entries.push(ae);
  if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
    this._writeDataDescriptor(ae);
  }
  this._archive.processing = false;
  this._entry = null;
  if (this._archive.finish && !this._archive.finished) {
    this._finish();
  }
};
ZipArchiveOutputStream$1.prototype._appendBuffer = function(ae, source, callback) {
  if (source.length === 0) {
    ae.setMethod(constants$1.METHOD_STORED);
  }
  var method2 = ae.getMethod();
  if (method2 === constants$1.METHOD_STORED) {
    ae.setSize(source.length);
    ae.setCompressedSize(source.length);
    ae.setCrc(crc32$1.unsigned(source));
  }
  this._writeLocalFileHeader(ae);
  if (method2 === constants$1.METHOD_STORED) {
    this.write(source);
    this._afterAppend(ae);
    callback(null, ae);
    return;
  } else if (method2 === constants$1.METHOD_DEFLATED) {
    this._smartStream(ae, callback).end(source);
    return;
  } else {
    callback(new Error("compression method " + method2 + " not implemented"));
    return;
  }
};
ZipArchiveOutputStream$1.prototype._appendStream = function(ae, source, callback) {
  ae.getGeneralPurposeBit().useDataDescriptor(true);
  ae.setVersionNeededToExtract(constants$1.MIN_VERSION_DATA_DESCRIPTOR);
  this._writeLocalFileHeader(ae);
  var smart = this._smartStream(ae, callback);
  source.once("error", function(err2) {
    smart.emit("error", err2);
    smart.end();
  });
  source.pipe(smart);
};
ZipArchiveOutputStream$1.prototype._defaults = function(o) {
  if (typeof o !== "object") {
    o = {};
  }
  if (typeof o.zlib !== "object") {
    o.zlib = {};
  }
  if (typeof o.zlib.level !== "number") {
    o.zlib.level = constants$1.ZLIB_BEST_SPEED;
  }
  o.forceZip64 = !!o.forceZip64;
  o.forceLocalTime = !!o.forceLocalTime;
  return o;
};
ZipArchiveOutputStream$1.prototype._finish = function() {
  this._archive.centralOffset = this.offset;
  this._entries.forEach((function(ae) {
    this._writeCentralFileHeader(ae);
  }).bind(this));
  this._archive.centralLength = this.offset - this._archive.centralOffset;
  if (this.isZip64()) {
    this._writeCentralDirectoryZip64();
  }
  this._writeCentralDirectoryEnd();
  this._archive.processing = false;
  this._archive.finish = true;
  this._archive.finished = true;
  this.end();
};
ZipArchiveOutputStream$1.prototype._normalizeEntry = function(ae) {
  if (ae.getMethod() === -1) {
    ae.setMethod(constants$1.METHOD_DEFLATED);
  }
  if (ae.getMethod() === constants$1.METHOD_DEFLATED) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants$1.MIN_VERSION_DATA_DESCRIPTOR);
  }
  if (ae.getTime() === -1) {
    ae.setTime(/* @__PURE__ */ new Date(), this._archive.forceLocalTime);
  }
  ae._offsets = {
    file: 0,
    data: 0,
    contents: 0
  };
};
ZipArchiveOutputStream$1.prototype._smartStream = function(ae, callback) {
  var deflate2 = ae.getMethod() === constants$1.METHOD_DEFLATED;
  var process2 = deflate2 ? new DeflateCRC32Stream2(this.options.zlib) : new CRC32Stream2();
  var error2 = null;
  function handleStuff() {
    var digest = process2.digest().readUInt32BE(0);
    ae.setCrc(digest);
    ae.setSize(process2.size());
    ae.setCompressedSize(process2.size(true));
    this._afterAppend(ae);
    callback(error2, ae);
  }
  process2.once("end", handleStuff.bind(this));
  process2.once("error", function(err2) {
    error2 = err2;
  });
  process2.pipe(this, { end: false });
  return process2;
};
ZipArchiveOutputStream$1.prototype._writeCentralDirectoryEnd = function() {
  var records = this._entries.length;
  var size = this._archive.centralLength;
  var offset = this._archive.centralOffset;
  if (this.isZip64()) {
    records = constants$1.ZIP64_MAGIC_SHORT;
    size = constants$1.ZIP64_MAGIC;
    offset = constants$1.ZIP64_MAGIC;
  }
  this.write(zipUtil.getLongBytes(constants$1.SIG_EOCD));
  this.write(constants$1.SHORT_ZERO);
  this.write(constants$1.SHORT_ZERO);
  this.write(zipUtil.getShortBytes(records));
  this.write(zipUtil.getShortBytes(records));
  this.write(zipUtil.getLongBytes(size));
  this.write(zipUtil.getLongBytes(offset));
  var comment = this.getComment();
  var commentLength = Buffer.byteLength(comment);
  this.write(zipUtil.getShortBytes(commentLength));
  this.write(comment);
};
ZipArchiveOutputStream$1.prototype._writeCentralDirectoryZip64 = function() {
  this.write(zipUtil.getLongBytes(constants$1.SIG_ZIP64_EOCD));
  this.write(zipUtil.getEightBytes(44));
  this.write(zipUtil.getShortBytes(constants$1.MIN_VERSION_ZIP64));
  this.write(zipUtil.getShortBytes(constants$1.MIN_VERSION_ZIP64));
  this.write(constants$1.LONG_ZERO);
  this.write(constants$1.LONG_ZERO);
  this.write(zipUtil.getEightBytes(this._entries.length));
  this.write(zipUtil.getEightBytes(this._entries.length));
  this.write(zipUtil.getEightBytes(this._archive.centralLength));
  this.write(zipUtil.getEightBytes(this._archive.centralOffset));
  this.write(zipUtil.getLongBytes(constants$1.SIG_ZIP64_EOCD_LOC));
  this.write(constants$1.LONG_ZERO);
  this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
  this.write(zipUtil.getLongBytes(1));
};
ZipArchiveOutputStream$1.prototype._writeCentralFileHeader = function(ae) {
  var gpb = ae.getGeneralPurposeBit();
  var method2 = ae.getMethod();
  var offsets = ae._offsets;
  var size = ae.getSize();
  var compressedSize = ae.getCompressedSize();
  if (ae.isZip64() || offsets.file > constants$1.ZIP64_MAGIC) {
    size = constants$1.ZIP64_MAGIC;
    compressedSize = constants$1.ZIP64_MAGIC;
    ae.setVersionNeededToExtract(constants$1.MIN_VERSION_ZIP64);
    var extraBuf = Buffer.concat([
      zipUtil.getShortBytes(constants$1.ZIP64_EXTRA_ID),
      zipUtil.getShortBytes(24),
      zipUtil.getEightBytes(ae.getSize()),
      zipUtil.getEightBytes(ae.getCompressedSize()),
      zipUtil.getEightBytes(offsets.file)
    ], 28);
    ae.setExtra(extraBuf);
  }
  this.write(zipUtil.getLongBytes(constants$1.SIG_CFH));
  this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants$1.VERSION_MADEBY));
  this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
  this.write(gpb.encode());
  this.write(zipUtil.getShortBytes(method2));
  this.write(zipUtil.getLongBytes(ae.getTimeDos()));
  this.write(zipUtil.getLongBytes(ae.getCrc()));
  this.write(zipUtil.getLongBytes(compressedSize));
  this.write(zipUtil.getLongBytes(size));
  var name = ae.getName();
  var comment = ae.getComment();
  var extra = ae.getCentralDirectoryExtra();
  if (gpb.usesUTF8ForNames()) {
    name = Buffer.from(name);
    comment = Buffer.from(comment);
  }
  this.write(zipUtil.getShortBytes(name.length));
  this.write(zipUtil.getShortBytes(extra.length));
  this.write(zipUtil.getShortBytes(comment.length));
  this.write(constants$1.SHORT_ZERO);
  this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
  this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
  if (offsets.file > constants$1.ZIP64_MAGIC) {
    this.write(zipUtil.getLongBytes(constants$1.ZIP64_MAGIC));
  } else {
    this.write(zipUtil.getLongBytes(offsets.file));
  }
  this.write(name);
  this.write(extra);
  this.write(comment);
};
ZipArchiveOutputStream$1.prototype._writeDataDescriptor = function(ae) {
  this.write(zipUtil.getLongBytes(constants$1.SIG_DD));
  this.write(zipUtil.getLongBytes(ae.getCrc()));
  if (ae.isZip64()) {
    this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
    this.write(zipUtil.getEightBytes(ae.getSize()));
  } else {
    this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
    this.write(zipUtil.getLongBytes(ae.getSize()));
  }
};
ZipArchiveOutputStream$1.prototype._writeLocalFileHeader = function(ae) {
  var gpb = ae.getGeneralPurposeBit();
  var method2 = ae.getMethod();
  var name = ae.getName();
  var extra = ae.getLocalFileDataExtra();
  if (ae.isZip64()) {
    gpb.useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants$1.MIN_VERSION_ZIP64);
  }
  if (gpb.usesUTF8ForNames()) {
    name = Buffer.from(name);
  }
  ae._offsets.file = this.offset;
  this.write(zipUtil.getLongBytes(constants$1.SIG_LFH));
  this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
  this.write(gpb.encode());
  this.write(zipUtil.getShortBytes(method2));
  this.write(zipUtil.getLongBytes(ae.getTimeDos()));
  ae._offsets.data = this.offset;
  if (gpb.usesDataDescriptor()) {
    this.write(constants$1.LONG_ZERO);
    this.write(constants$1.LONG_ZERO);
    this.write(constants$1.LONG_ZERO);
  } else {
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
    this.write(zipUtil.getLongBytes(ae.getSize()));
  }
  this.write(zipUtil.getShortBytes(name.length));
  this.write(zipUtil.getShortBytes(extra.length));
  this.write(name);
  this.write(extra);
  ae._offsets.contents = this.offset;
};
ZipArchiveOutputStream$1.prototype.getComment = function(comment) {
  return this._archive.comment !== null ? this._archive.comment : "";
};
ZipArchiveOutputStream$1.prototype.isZip64 = function() {
  return this._archive.forceZip64 || this._entries.length > constants$1.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants$1.ZIP64_MAGIC || this._archive.centralOffset > constants$1.ZIP64_MAGIC;
};
ZipArchiveOutputStream$1.prototype.setComment = function(comment) {
  this._archive.comment = comment;
};
var zipArchiveOutputStreamExports = zipArchiveOutputStream.exports;
var compressCommons = {
  ZipArchiveEntry: zipArchiveEntryExports,
  ZipArchiveOutputStream: zipArchiveOutputStreamExports
};
var archiverUtils = { exports: {} };
var file$1 = { exports: {} };
var fs$6 = gracefulFs;
var path$5 = require$$1;
var flatten = lodash_flatten;
var difference = lodash_difference;
var union = lodash_union;
var isPlainObject = lodash_isplainobject;
var glob$1 = requireGlob();
var file = file$1.exports = {};
var pathSeparatorRe = /[\/\\]/g;
var processPatterns = function(patterns, fn) {
  var result = [];
  flatten(patterns).forEach(function(pattern) {
    var exclusion = pattern.indexOf("!") === 0;
    if (exclusion) {
      pattern = pattern.slice(1);
    }
    var matches = fn(pattern);
    if (exclusion) {
      result = difference(result, matches);
    } else {
      result = union(result, matches);
    }
  });
  return result;
};
file.exists = function() {
  var filepath = path$5.join.apply(path$5, arguments);
  return fs$6.existsSync(filepath);
};
file.expand = function(...args) {
  var options = isPlainObject(args[0]) ? args.shift() : {};
  var patterns = Array.isArray(args[0]) ? args[0] : args;
  if (patterns.length === 0) {
    return [];
  }
  var matches = processPatterns(patterns, function(pattern) {
    return glob$1.sync(pattern, options);
  });
  if (options.filter) {
    matches = matches.filter(function(filepath) {
      filepath = path$5.join(options.cwd || "", filepath);
      try {
        if (typeof options.filter === "function") {
          return options.filter(filepath);
        } else {
          return fs$6.statSync(filepath)[options.filter]();
        }
      } catch (e) {
        return false;
      }
    });
  }
  return matches;
};
file.expandMapping = function(patterns, destBase, options) {
  options = Object.assign({
    rename: function(destBase2, destPath) {
      return path$5.join(destBase2 || "", destPath);
    }
  }, options);
  var files = [];
  var fileByDest = {};
  file.expand(options, patterns).forEach(function(src2) {
    var destPath = src2;
    if (options.flatten) {
      destPath = path$5.basename(destPath);
    }
    if (options.ext) {
      destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
    }
    var dest = options.rename(destBase, destPath, options);
    if (options.cwd) {
      src2 = path$5.join(options.cwd, src2);
    }
    dest = dest.replace(pathSeparatorRe, "/");
    src2 = src2.replace(pathSeparatorRe, "/");
    if (fileByDest[dest]) {
      fileByDest[dest].src.push(src2);
    } else {
      files.push({
        src: [src2],
        dest
      });
      fileByDest[dest] = files[files.length - 1];
    }
  });
  return files;
};
file.normalizeFilesArray = function(data) {
  var files = [];
  data.forEach(function(obj) {
    if ("src" in obj || "dest" in obj) {
      files.push(obj);
    }
  });
  if (files.length === 0) {
    return [];
  }
  files = _(files).chain().forEach(function(obj) {
    if (!("src" in obj) || !obj.src) {
      return;
    }
    if (Array.isArray(obj.src)) {
      obj.src = flatten(obj.src);
    } else {
      obj.src = [obj.src];
    }
  }).map(function(obj) {
    var expandOptions = Object.assign({}, obj);
    delete expandOptions.src;
    delete expandOptions.dest;
    if (obj.expand) {
      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
        var result2 = Object.assign({}, obj);
        result2.orig = Object.assign({}, obj);
        result2.src = mapObj.src;
        result2.dest = mapObj.dest;
        ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
          delete result2[prop];
        });
        return result2;
      });
    }
    var result = Object.assign({}, obj);
    result.orig = Object.assign({}, obj);
    if ("src" in result) {
      Object.defineProperty(result, "src", {
        enumerable: true,
        get: function fn() {
          var src2;
          if (!("result" in fn)) {
            src2 = obj.src;
            src2 = Array.isArray(src2) ? flatten(src2) : [src2];
            fn.result = file.expand(expandOptions, src2);
          }
          return fn.result;
        }
      });
    }
    if ("dest" in result) {
      result.dest = obj.dest;
    }
    return result;
  }).flatten().value();
  return files;
};
var fileExports = file$1.exports;
var fs$5 = gracefulFs;
var path$4 = require$$1;
var lazystream = lazystream$2;
var normalizePath = normalizePath$3;
var defaults$1 = lodash_defaults;
var Stream$9 = require$$0$1.Stream;
var PassThrough$2 = readableExports$3.PassThrough;
var utils$2 = archiverUtils.exports = {};
utils$2.file = fileExports;
utils$2.collectStream = function(source, callback) {
  var collection = [];
  var size = 0;
  source.on("error", callback);
  source.on("data", function(chunk) {
    collection.push(chunk);
    size += chunk.length;
  });
  source.on("end", function() {
    var buf = Buffer.alloc(size);
    var offset = 0;
    collection.forEach(function(data) {
      data.copy(buf, offset);
      offset += data.length;
    });
    callback(null, buf);
  });
};
utils$2.dateify = function(dateish) {
  dateish = dateish || /* @__PURE__ */ new Date();
  if (dateish instanceof Date) {
    dateish = dateish;
  } else if (typeof dateish === "string") {
    dateish = new Date(dateish);
  } else {
    dateish = /* @__PURE__ */ new Date();
  }
  return dateish;
};
utils$2.defaults = function(object2, source, guard) {
  var args = arguments;
  args[0] = args[0] || {};
  return defaults$1(...args);
};
utils$2.isStream = function(source) {
  return source instanceof Stream$9;
};
utils$2.lazyReadStream = function(filepath) {
  return new lazystream.Readable(function() {
    return fs$5.createReadStream(filepath);
  });
};
utils$2.normalizeInputSource = function(source) {
  if (source === null) {
    return Buffer.alloc(0);
  } else if (typeof source === "string") {
    return Buffer.from(source);
  } else if (utils$2.isStream(source)) {
    return source.pipe(new PassThrough$2());
  }
  return source;
};
utils$2.sanitizePath = function(filepath) {
  return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
};
utils$2.trailingSlashIt = function(str) {
  return str.slice(-1) !== "/" ? str + "/" : str;
};
utils$2.unixifyPath = function(filepath) {
  return normalizePath(filepath, false).replace(/^\w+:/, "");
};
utils$2.walkdir = function(dirpath, base, callback) {
  var results = [];
  if (typeof base === "function") {
    callback = base;
    base = dirpath;
  }
  fs$5.readdir(dirpath, function(err2, list) {
    var i = 0;
    var file2;
    var filepath;
    if (err2) {
      return callback(err2);
    }
    (function next() {
      file2 = list[i++];
      if (!file2) {
        return callback(null, results);
      }
      filepath = path$4.join(dirpath, file2);
      fs$5.stat(filepath, function(err3, stats) {
        results.push({
          path: filepath,
          relative: path$4.relative(base, filepath).replace(/\\/g, "/"),
          stats
        });
        if (stats && stats.isDirectory()) {
          utils$2.walkdir(filepath, base, function(err4, res) {
            res.forEach(function(dirEntry) {
              results.push(dirEntry);
            });
            next();
          });
        } else {
          next();
        }
      });
    })();
  });
};
var archiverUtilsExports = archiverUtils.exports;
/**
 * ZipStream
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
 * @copyright (c) 2014 Chris Talkington, contributors.
 */
var inherits$4 = require$$0$4.inherits;
var ZipArchiveOutputStream = compressCommons.ZipArchiveOutputStream;
var ZipArchiveEntry = compressCommons.ZipArchiveEntry;
var util$8 = archiverUtilsExports;
var ZipStream = zipStream.exports = function(options) {
  if (!(this instanceof ZipStream)) {
    return new ZipStream(options);
  }
  options = this.options = options || {};
  options.zlib = options.zlib || {};
  ZipArchiveOutputStream.call(this, options);
  if (typeof options.level === "number" && options.level >= 0) {
    options.zlib.level = options.level;
    delete options.level;
  }
  if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
    options.store = true;
  }
  options.namePrependSlash = options.namePrependSlash || false;
  if (options.comment && options.comment.length > 0) {
    this.setComment(options.comment);
  }
};
inherits$4(ZipStream, ZipArchiveOutputStream);
ZipStream.prototype._normalizeFileData = function(data) {
  data = util$8.defaults(data, {
    type: "file",
    name: null,
    namePrependSlash: this.options.namePrependSlash,
    linkname: null,
    date: null,
    mode: null,
    store: this.options.store,
    comment: ""
  });
  var isDir = data.type === "directory";
  var isSymlink = data.type === "symlink";
  if (data.name) {
    data.name = util$8.sanitizePath(data.name);
    if (!isSymlink && data.name.slice(-1) === "/") {
      isDir = true;
      data.type = "directory";
    } else if (isDir) {
      data.name += "/";
    }
  }
  if (isDir || isSymlink) {
    data.store = true;
  }
  data.date = util$8.dateify(data.date);
  return data;
};
ZipStream.prototype.entry = function(source, data, callback) {
  if (typeof callback !== "function") {
    callback = this._emitErrorCallback.bind(this);
  }
  data = this._normalizeFileData(data);
  if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
    callback(new Error(data.type + " entries not currently supported"));
    return;
  }
  if (typeof data.name !== "string" || data.name.length === 0) {
    callback(new Error("entry name must be a non-empty string value"));
    return;
  }
  if (data.type === "symlink" && typeof data.linkname !== "string") {
    callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
    return;
  }
  var entry = new ZipArchiveEntry(data.name);
  entry.setTime(data.date, this.options.forceLocalTime);
  if (data.namePrependSlash) {
    entry.setName(data.name, true);
  }
  if (data.store) {
    entry.setMethod(0);
  }
  if (data.comment.length > 0) {
    entry.setComment(data.comment);
  }
  if (data.type === "symlink" && typeof data.mode !== "number") {
    data.mode = 40960;
  }
  if (typeof data.mode === "number") {
    if (data.type === "symlink") {
      data.mode |= 40960;
    }
    entry.setUnixMode(data.mode);
  }
  if (data.type === "symlink" && typeof data.linkname === "string") {
    source = Buffer.from(data.linkname);
  }
  return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
};
ZipStream.prototype.finalize = function() {
  this.finish();
};
var zipStreamExports = zipStream.exports;
/**
 * ZIP Format Plugin
 *
 * @module plugins/zip
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var engine$1 = zipStreamExports;
var util$7 = archiverUtilsExports$1;
var Zip = function(options) {
  if (!(this instanceof Zip)) {
    return new Zip(options);
  }
  options = this.options = util$7.defaults(options, {
    comment: "",
    forceUTC: false,
    namePrependSlash: false,
    store: false
  });
  this.supports = {
    directory: true,
    symlink: true
  };
  this.engine = new engine$1(options);
};
Zip.prototype.append = function(source, data, callback) {
  this.engine.entry(source, data, callback);
};
Zip.prototype.finalize = function() {
  this.engine.finalize();
};
Zip.prototype.on = function() {
  return this.engine.on.apply(this.engine, arguments);
};
Zip.prototype.pipe = function() {
  return this.engine.pipe.apply(this.engine, arguments);
};
Zip.prototype.unpipe = function() {
  return this.engine.unpipe.apply(this.engine, arguments);
};
var zip = Zip;
var tarStream = {};
var bl$1 = { exports: {} };
const { Buffer: Buffer$7 } = require$$0$3;
const symbol = Symbol.for("BufferList");
function BufferList$3(buf) {
  if (!(this instanceof BufferList$3)) {
    return new BufferList$3(buf);
  }
  BufferList$3._init.call(this, buf);
}
BufferList$3._init = function _init(buf) {
  Object.defineProperty(this, symbol, { value: true });
  this._bufs = [];
  this.length = 0;
  if (buf) {
    this.append(buf);
  }
};
BufferList$3.prototype._new = function _new(buf) {
  return new BufferList$3(buf);
};
BufferList$3.prototype._offset = function _offset(offset) {
  if (offset === 0) {
    return [0, 0];
  }
  let tot = 0;
  for (let i = 0; i < this._bufs.length; i++) {
    const _t = tot + this._bufs[i].length;
    if (offset < _t || i === this._bufs.length - 1) {
      return [i, offset - tot];
    }
    tot = _t;
  }
};
BufferList$3.prototype._reverseOffset = function(blOffset) {
  const bufferId = blOffset[0];
  let offset = blOffset[1];
  for (let i = 0; i < bufferId; i++) {
    offset += this._bufs[i].length;
  }
  return offset;
};
BufferList$3.prototype.get = function get(index2) {
  if (index2 > this.length || index2 < 0) {
    return void 0;
  }
  const offset = this._offset(index2);
  return this._bufs[offset[0]][offset[1]];
};
BufferList$3.prototype.slice = function slice2(start, end2) {
  if (typeof start === "number" && start < 0) {
    start += this.length;
  }
  if (typeof end2 === "number" && end2 < 0) {
    end2 += this.length;
  }
  return this.copy(null, 0, start, end2);
};
BufferList$3.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart !== "number" || srcStart < 0) {
    srcStart = 0;
  }
  if (typeof srcEnd !== "number" || srcEnd > this.length) {
    srcEnd = this.length;
  }
  if (srcStart >= this.length) {
    return dst || Buffer$7.alloc(0);
  }
  if (srcEnd <= 0) {
    return dst || Buffer$7.alloc(0);
  }
  const copy3 = !!dst;
  const off = this._offset(srcStart);
  const len = srcEnd - srcStart;
  let bytes = len;
  let bufoff = copy3 && dstStart || 0;
  let start = off[1];
  if (srcStart === 0 && srcEnd === this.length) {
    if (!copy3) {
      return this._bufs.length === 1 ? this._bufs[0] : Buffer$7.concat(this._bufs, this.length);
    }
    for (let i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff);
      bufoff += this._bufs[i].length;
    }
    return dst;
  }
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy3 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
  }
  if (!copy3) {
    dst = Buffer$7.allocUnsafe(len);
  }
  for (let i = off[0]; i < this._bufs.length; i++) {
    const l = this._bufs[i].length - start;
    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start);
      bufoff += l;
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes);
      bufoff += l;
      break;
    }
    bytes -= l;
    if (start) {
      start = 0;
    }
  }
  if (dst.length > bufoff) return dst.slice(0, bufoff);
  return dst;
};
BufferList$3.prototype.shallowSlice = function shallowSlice(start, end2) {
  start = start || 0;
  end2 = typeof end2 !== "number" ? this.length : end2;
  if (start < 0) {
    start += this.length;
  }
  if (end2 < 0) {
    end2 += this.length;
  }
  if (start === end2) {
    return this._new();
  }
  const startOffset = this._offset(start);
  const endOffset = this._offset(end2);
  const buffers2 = this._bufs.slice(startOffset[0], endOffset[0] + 1);
  if (endOffset[1] === 0) {
    buffers2.pop();
  } else {
    buffers2[buffers2.length - 1] = buffers2[buffers2.length - 1].slice(0, endOffset[1]);
  }
  if (startOffset[1] !== 0) {
    buffers2[0] = buffers2[0].slice(startOffset[1]);
  }
  return this._new(buffers2);
};
BufferList$3.prototype.toString = function toString2(encoding, start, end2) {
  return this.slice(start, end2).toString(encoding);
};
BufferList$3.prototype.consume = function consume(bytes) {
  bytes = Math.trunc(bytes);
  if (Number.isNaN(bytes) || bytes <= 0) return this;
  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length;
      this.length -= this._bufs[0].length;
      this._bufs.shift();
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes);
      this.length -= bytes;
      break;
    }
  }
  return this;
};
BufferList$3.prototype.duplicate = function duplicate() {
  const copy3 = this._new();
  for (let i = 0; i < this._bufs.length; i++) {
    copy3.append(this._bufs[i]);
  }
  return copy3;
};
BufferList$3.prototype.append = function append(buf) {
  if (buf == null) {
    return this;
  }
  if (buf.buffer) {
    this._appendBuffer(Buffer$7.from(buf.buffer, buf.byteOffset, buf.byteLength));
  } else if (Array.isArray(buf)) {
    for (let i = 0; i < buf.length; i++) {
      this.append(buf[i]);
    }
  } else if (this._isBufferList(buf)) {
    for (let i = 0; i < buf._bufs.length; i++) {
      this.append(buf._bufs[i]);
    }
  } else {
    if (typeof buf === "number") {
      buf = buf.toString();
    }
    this._appendBuffer(Buffer$7.from(buf));
  }
  return this;
};
BufferList$3.prototype._appendBuffer = function appendBuffer(buf) {
  this._bufs.push(buf);
  this.length += buf.length;
};
BufferList$3.prototype.indexOf = function(search, offset, encoding) {
  if (encoding === void 0 && typeof offset === "string") {
    encoding = offset;
    offset = void 0;
  }
  if (typeof search === "function" || Array.isArray(search)) {
    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
  } else if (typeof search === "number") {
    search = Buffer$7.from([search]);
  } else if (typeof search === "string") {
    search = Buffer$7.from(search, encoding);
  } else if (this._isBufferList(search)) {
    search = search.slice();
  } else if (Array.isArray(search.buffer)) {
    search = Buffer$7.from(search.buffer, search.byteOffset, search.byteLength);
  } else if (!Buffer$7.isBuffer(search)) {
    search = Buffer$7.from(search);
  }
  offset = Number(offset || 0);
  if (isNaN(offset)) {
    offset = 0;
  }
  if (offset < 0) {
    offset = this.length + offset;
  }
  if (offset < 0) {
    offset = 0;
  }
  if (search.length === 0) {
    return offset > this.length ? this.length : offset;
  }
  const blOffset = this._offset(offset);
  let blIndex = blOffset[0];
  let buffOffset = blOffset[1];
  for (; blIndex < this._bufs.length; blIndex++) {
    const buff = this._bufs[blIndex];
    while (buffOffset < buff.length) {
      const availableWindow = buff.length - buffOffset;
      if (availableWindow >= search.length) {
        const nativeSearchResult = buff.indexOf(search, buffOffset);
        if (nativeSearchResult !== -1) {
          return this._reverseOffset([blIndex, nativeSearchResult]);
        }
        buffOffset = buff.length - search.length + 1;
      } else {
        const revOffset = this._reverseOffset([blIndex, buffOffset]);
        if (this._match(revOffset, search)) {
          return revOffset;
        }
        buffOffset++;
      }
    }
    buffOffset = 0;
  }
  return -1;
};
BufferList$3.prototype._match = function(offset, search) {
  if (this.length - offset < search.length) {
    return false;
  }
  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
    if (this.get(offset + searchOffset) !== search[searchOffset]) {
      return false;
    }
  }
  return true;
};
(function() {
  const methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
    readIntBE: null,
    readIntLE: null,
    readUIntBE: null,
    readUIntLE: null
  };
  for (const m in methods) {
    (function(m2) {
      if (methods[m2] === null) {
        BufferList$3.prototype[m2] = function(offset, byteLength) {
          return this.slice(offset, offset + byteLength)[m2](0, byteLength);
        };
      } else {
        BufferList$3.prototype[m2] = function(offset = 0) {
          return this.slice(offset, offset + methods[m2])[m2](0);
        };
      }
    })(m);
  }
})();
BufferList$3.prototype._isBufferList = function _isBufferList(b) {
  return b instanceof BufferList$3 || BufferList$3.isBufferList(b);
};
BufferList$3.isBufferList = function isBufferList(b) {
  return b != null && b[symbol];
};
var BufferList_1 = BufferList$3;
const DuplexStream = readableExports$3.Duplex;
const inherits$3 = requireInherits();
const BufferList$2 = BufferList_1;
function BufferListStream(callback) {
  if (!(this instanceof BufferListStream)) {
    return new BufferListStream(callback);
  }
  if (typeof callback === "function") {
    this._callback = callback;
    const piper = (function piper2(err2) {
      if (this._callback) {
        this._callback(err2);
        this._callback = null;
      }
    }).bind(this);
    this.on("pipe", function onPipe(src2) {
      src2.on("error", piper);
    });
    this.on("unpipe", function onUnpipe(src2) {
      src2.removeListener("error", piper);
    });
    callback = null;
  }
  BufferList$2._init.call(this, callback);
  DuplexStream.call(this);
}
inherits$3(BufferListStream, DuplexStream);
Object.assign(BufferListStream.prototype, BufferList$2.prototype);
BufferListStream.prototype._new = function _new2(callback) {
  return new BufferListStream(callback);
};
BufferListStream.prototype._write = function _write(buf, encoding, callback) {
  this._appendBuffer(buf);
  if (typeof callback === "function") {
    callback();
  }
};
BufferListStream.prototype._read = function _read(size) {
  if (!this.length) {
    return this.push(null);
  }
  size = Math.min(size, this.length);
  this.push(this.slice(0, size));
  this.consume(size);
};
BufferListStream.prototype.end = function end(chunk) {
  DuplexStream.prototype.end.call(this, chunk);
  if (this._callback) {
    this._callback(null, this.slice());
    this._callback = null;
  }
};
BufferListStream.prototype._destroy = function _destroy(err2, cb) {
  this._bufs.length = 0;
  this.length = 0;
  cb(err2);
};
BufferListStream.prototype._isBufferList = function _isBufferList2(b) {
  return b instanceof BufferListStream || b instanceof BufferList$2 || BufferListStream.isBufferList(b);
};
BufferListStream.isBufferList = BufferList$2.isBufferList;
bl$1.exports = BufferListStream;
bl$1.exports.BufferListStream = BufferListStream;
bl$1.exports.BufferList = BufferList$2;
var blExports = bl$1.exports;
var headers$2 = {};
var alloc$1 = Buffer.alloc;
var ZEROS = "0000000000000000000";
var SEVENS = "7777777777777777777";
var ZERO_OFFSET = "0".charCodeAt(0);
var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
var USTAR_VER = Buffer.from("00", "binary");
var GNU_MAGIC = Buffer.from("ustar ", "binary");
var GNU_VER = Buffer.from(" \0", "binary");
var MASK = parseInt("7777", 8);
var MAGIC_OFFSET = 257;
var VERSION_OFFSET = 263;
var clamp = function(index2, len, defaultValue) {
  if (typeof index2 !== "number") return defaultValue;
  index2 = ~~index2;
  if (index2 >= len) return len;
  if (index2 >= 0) return index2;
  index2 += len;
  if (index2 >= 0) return index2;
  return 0;
};
var toType = function(flag) {
  switch (flag) {
    case 0:
      return "file";
    case 1:
      return "link";
    case 2:
      return "symlink";
    case 3:
      return "character-device";
    case 4:
      return "block-device";
    case 5:
      return "directory";
    case 6:
      return "fifo";
    case 7:
      return "contiguous-file";
    case 72:
      return "pax-header";
    case 55:
      return "pax-global-header";
    case 27:
      return "gnu-long-link-path";
    case 28:
    case 30:
      return "gnu-long-path";
  }
  return null;
};
var toTypeflag = function(flag) {
  switch (flag) {
    case "file":
      return 0;
    case "link":
      return 1;
    case "symlink":
      return 2;
    case "character-device":
      return 3;
    case "block-device":
      return 4;
    case "directory":
      return 5;
    case "fifo":
      return 6;
    case "contiguous-file":
      return 7;
    case "pax-header":
      return 72;
  }
  return 0;
};
var indexOf = function(block, num, offset, end2) {
  for (; offset < end2; offset++) {
    if (block[offset] === num) return offset;
  }
  return end2;
};
var cksum = function(block) {
  var sum = 8 * 32;
  for (var i = 0; i < 148; i++) sum += block[i];
  for (var j = 156; j < 512; j++) sum += block[j];
  return sum;
};
var encodeOct = function(val, n) {
  val = val.toString(8);
  if (val.length > n) return SEVENS.slice(0, n) + " ";
  else return ZEROS.slice(0, n - val.length) + val + " ";
};
function parse256(buf) {
  var positive;
  if (buf[0] === 128) positive = true;
  else if (buf[0] === 255) positive = false;
  else return null;
  var tuple = [];
  for (var i = buf.length - 1; i > 0; i--) {
    var byte = buf[i];
    if (positive) tuple.push(byte);
    else tuple.push(255 - byte);
  }
  var sum = 0;
  var l = tuple.length;
  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i);
  }
  return positive ? sum : -1 * sum;
}
var decodeOct = function(val, offset, length) {
  val = val.slice(offset, offset + length);
  offset = 0;
  if (val[offset] & 128) {
    return parse256(val);
  } else {
    while (offset < val.length && val[offset] === 32) offset++;
    var end2 = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
    while (offset < end2 && val[offset] === 0) offset++;
    if (end2 === offset) return 0;
    return parseInt(val.slice(offset, end2).toString(), 8);
  }
};
var decodeStr = function(val, offset, length, encoding) {
  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
};
var addLength = function(str) {
  var len = Buffer.byteLength(str);
  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) digits++;
  return len + digits + str;
};
headers$2.decodeLongPath = function(buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding);
};
headers$2.encodePax = function(opts) {
  var result = "";
  if (opts.name) result += addLength(" path=" + opts.name + "\n");
  if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
  var pax = opts.pax;
  if (pax) {
    for (var key in pax) {
      result += addLength(" " + key + "=" + pax[key] + "\n");
    }
  }
  return Buffer.from(result);
};
headers$2.decodePax = function(buf) {
  var result = {};
  while (buf.length) {
    var i = 0;
    while (i < buf.length && buf[i] !== 32) i++;
    var len = parseInt(buf.slice(0, i).toString(), 10);
    if (!len) return result;
    var b = buf.slice(i + 1, len - 1).toString();
    var keyIndex = b.indexOf("=");
    if (keyIndex === -1) return result;
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
    buf = buf.slice(len);
  }
  return result;
};
headers$2.encode = function(opts) {
  var buf = alloc$1(512);
  var name = opts.name;
  var prefix = "";
  if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
  if (Buffer.byteLength(name) !== name.length) return null;
  while (Buffer.byteLength(name) > 100) {
    var i = name.indexOf("/");
    if (i === -1) return null;
    prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
    name = name.slice(i + 1);
  }
  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null;
  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null;
  buf.write(name);
  buf.write(encodeOct(opts.mode & MASK, 6), 100);
  buf.write(encodeOct(opts.uid, 6), 108);
  buf.write(encodeOct(opts.gid, 6), 116);
  buf.write(encodeOct(opts.size, 11), 124);
  buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
  buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
  if (opts.linkname) buf.write(opts.linkname, 157);
  USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
  USTAR_VER.copy(buf, VERSION_OFFSET);
  if (opts.uname) buf.write(opts.uname, 265);
  if (opts.gname) buf.write(opts.gname, 297);
  buf.write(encodeOct(opts.devmajor || 0, 6), 329);
  buf.write(encodeOct(opts.devminor || 0, 6), 337);
  if (prefix) buf.write(prefix, 345);
  buf.write(encodeOct(cksum(buf), 6), 148);
  return buf;
};
headers$2.decode = function(buf, filenameEncoding, allowUnknownFormat) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
  var name = decodeStr(buf, 0, 100, filenameEncoding);
  var mode = decodeOct(buf, 100, 8);
  var uid = decodeOct(buf, 108, 8);
  var gid = decodeOct(buf, 116, 8);
  var size = decodeOct(buf, 124, 12);
  var mtime = decodeOct(buf, 136, 12);
  var type = toType(typeflag);
  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
  var uname = decodeStr(buf, 265, 32);
  var gname = decodeStr(buf, 297, 32);
  var devmajor = decodeOct(buf, 329, 8);
  var devminor = decodeOct(buf, 337, 8);
  var c2 = cksum(buf);
  if (c2 === 8 * 32) return null;
  if (c2 !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
  if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
  } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) ;
  else {
    if (!allowUnknownFormat) {
      throw new Error("Invalid tar header: unknown format.");
    }
  }
  if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
  return {
    name,
    mode,
    uid,
    gid,
    size,
    mtime: new Date(1e3 * mtime),
    type,
    linkname,
    uname,
    gname,
    devmajor,
    devminor
  };
};
var util$6 = require$$0$4;
var bl = blExports;
var headers$1 = headers$2;
var Writable$1 = readableExports$3.Writable;
var PassThrough$1 = readableExports$3.PassThrough;
var noop$2 = function() {
};
var overflow$1 = function(size) {
  size &= 511;
  return size && 512 - size;
};
var emptyStream = function(self2, offset) {
  var s = new Source(self2, offset);
  s.end();
  return s;
};
var mixinPax = function(header, pax) {
  if (pax.path) header.name = pax.path;
  if (pax.linkpath) header.linkname = pax.linkpath;
  if (pax.size) header.size = parseInt(pax.size, 10);
  header.pax = pax;
  return header;
};
var Source = function(self2, offset) {
  this._parent = self2;
  this.offset = offset;
  PassThrough$1.call(this, { autoDestroy: false });
};
util$6.inherits(Source, PassThrough$1);
Source.prototype.destroy = function(err2) {
  this._parent.destroy(err2);
};
var Extract$1 = function(opts) {
  if (!(this instanceof Extract$1)) return new Extract$1(opts);
  Writable$1.call(this, opts);
  opts = opts || {};
  this._offset = 0;
  this._buffer = bl();
  this._missing = 0;
  this._partial = false;
  this._onparse = noop$2;
  this._header = null;
  this._stream = null;
  this._overflow = null;
  this._cb = null;
  this._locked = false;
  this._destroyed = false;
  this._pax = null;
  this._paxGlobal = null;
  this._gnuLongPath = null;
  this._gnuLongLinkPath = null;
  var self2 = this;
  var b = self2._buffer;
  var oncontinue = function() {
    self2._continue();
  };
  var onunlock = function(err2) {
    self2._locked = false;
    if (err2) return self2.destroy(err2);
    if (!self2._stream) oncontinue();
  };
  var onstreamend = function() {
    self2._stream = null;
    var drain = overflow$1(self2._header.size);
    if (drain) self2._parse(drain, ondrain);
    else self2._parse(512, onheader);
    if (!self2._locked) oncontinue();
  };
  var ondrain = function() {
    self2._buffer.consume(overflow$1(self2._header.size));
    self2._parse(512, onheader);
    oncontinue();
  };
  var onpaxglobalheader = function() {
    var size = self2._header.size;
    self2._paxGlobal = headers$1.decodePax(b.slice(0, size));
    b.consume(size);
    onstreamend();
  };
  var onpaxheader = function() {
    var size = self2._header.size;
    self2._pax = headers$1.decodePax(b.slice(0, size));
    if (self2._paxGlobal) self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
    b.consume(size);
    onstreamend();
  };
  var ongnulongpath = function() {
    var size = self2._header.size;
    this._gnuLongPath = headers$1.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };
  var ongnulonglinkpath = function() {
    var size = self2._header.size;
    this._gnuLongLinkPath = headers$1.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };
  var onheader = function() {
    var offset = self2._offset;
    var header;
    try {
      header = self2._header = headers$1.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
    } catch (err2) {
      self2.emit("error", err2);
    }
    b.consume(512);
    if (!header) {
      self2._parse(512, onheader);
      oncontinue();
      return;
    }
    if (header.type === "gnu-long-path") {
      self2._parse(header.size, ongnulongpath);
      oncontinue();
      return;
    }
    if (header.type === "gnu-long-link-path") {
      self2._parse(header.size, ongnulonglinkpath);
      oncontinue();
      return;
    }
    if (header.type === "pax-global-header") {
      self2._parse(header.size, onpaxglobalheader);
      oncontinue();
      return;
    }
    if (header.type === "pax-header") {
      self2._parse(header.size, onpaxheader);
      oncontinue();
      return;
    }
    if (self2._gnuLongPath) {
      header.name = self2._gnuLongPath;
      self2._gnuLongPath = null;
    }
    if (self2._gnuLongLinkPath) {
      header.linkname = self2._gnuLongLinkPath;
      self2._gnuLongLinkPath = null;
    }
    if (self2._pax) {
      self2._header = header = mixinPax(header, self2._pax);
      self2._pax = null;
    }
    self2._locked = true;
    if (!header.size || header.type === "directory") {
      self2._parse(512, onheader);
      self2.emit("entry", header, emptyStream(self2, offset), onunlock);
      return;
    }
    self2._stream = new Source(self2, offset);
    self2.emit("entry", header, self2._stream, onunlock);
    self2._parse(header.size, onstreamend);
    oncontinue();
  };
  this._onheader = onheader;
  this._parse(512, onheader);
};
util$6.inherits(Extract$1, Writable$1);
Extract$1.prototype.destroy = function(err2) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err2) this.emit("error", err2);
  this.emit("close");
  if (this._stream) this._stream.emit("close");
};
Extract$1.prototype._parse = function(size, onparse) {
  if (this._destroyed) return;
  this._offset += size;
  this._missing = size;
  if (onparse === this._onheader) this._partial = false;
  this._onparse = onparse;
};
Extract$1.prototype._continue = function() {
  if (this._destroyed) return;
  var cb = this._cb;
  this._cb = noop$2;
  if (this._overflow) this._write(this._overflow, void 0, cb);
  else cb();
};
Extract$1.prototype._write = function(data, enc, cb) {
  if (this._destroyed) return;
  var s = this._stream;
  var b = this._buffer;
  var missing = this._missing;
  if (data.length) this._partial = true;
  if (data.length < missing) {
    this._missing -= data.length;
    this._overflow = null;
    if (s) return s.write(data, cb);
    b.append(data);
    return cb();
  }
  this._cb = cb;
  this._missing = 0;
  var overflow2 = null;
  if (data.length > missing) {
    overflow2 = data.slice(missing);
    data = data.slice(0, missing);
  }
  if (s) s.end(data);
  else b.append(data);
  this._overflow = overflow2;
  this._onparse();
};
Extract$1.prototype._final = function(cb) {
  if (this._partial) return this.destroy(new Error("Unexpected end of data"));
  cb();
};
var extract$1 = Extract$1;
var fsConstants = require$$0$2.constants || require$$0$6;
var once$1 = onceExports;
var noop$1 = function() {
};
var isRequest = function(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
};
var isChildProcess = function(stream2) {
  return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
};
var eos$1 = function(stream2, opts, callback) {
  if (typeof opts === "function") return eos$1(stream2, null, opts);
  if (!opts) opts = {};
  callback = once$1(callback || noop$1);
  var ws = stream2._writableState;
  var rs = stream2._readableState;
  var readable2 = opts.readable || opts.readable !== false && stream2.readable;
  var writable = opts.writable || opts.writable !== false && stream2.writable;
  var cancelled = false;
  var onlegacyfinish = function() {
    if (!stream2.writable) onfinish();
  };
  var onfinish = function() {
    writable = false;
    if (!readable2) callback.call(stream2);
  };
  var onend = function() {
    readable2 = false;
    if (!writable) callback.call(stream2);
  };
  var onexit = function(exitCode) {
    callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
  };
  var onerror = function(err2) {
    callback.call(stream2, err2);
  };
  var onclose = function() {
    process.nextTick(onclosenexttick);
  };
  var onclosenexttick = function() {
    if (cancelled) return;
    if (readable2 && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream2, new Error("premature close"));
    if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream2, new Error("premature close"));
  };
  var onrequest = function() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !ws) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  if (isChildProcess(stream2)) stream2.on("exit", onexit);
  stream2.on("end", onend);
  stream2.on("finish", onfinish);
  if (opts.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    cancelled = true;
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("exit", onexit);
    stream2.removeListener("end", onend);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
};
var endOfStream = eos$1;
var constants = fsConstants;
var eos = endOfStream;
var inherits$2 = requireInherits();
var alloc = Buffer.alloc;
var Readable$1 = readableExports$3.Readable;
var Writable = readableExports$3.Writable;
var StringDecoder = require$$0$5.StringDecoder;
var headers = headers$2;
var DMODE = parseInt("755", 8);
var FMODE = parseInt("644", 8);
var END_OF_TAR = alloc(1024);
var noop = function() {
};
var overflow = function(self2, size) {
  size &= 511;
  if (size) self2.push(END_OF_TAR.slice(0, 512 - size));
};
function modeToType(mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK:
      return "block-device";
    case constants.S_IFCHR:
      return "character-device";
    case constants.S_IFDIR:
      return "directory";
    case constants.S_IFIFO:
      return "fifo";
    case constants.S_IFLNK:
      return "symlink";
  }
  return "file";
}
var Sink = function(to) {
  Writable.call(this);
  this.written = 0;
  this._to = to;
  this._destroyed = false;
};
inherits$2(Sink, Writable);
Sink.prototype._write = function(data, enc, cb) {
  this.written += data.length;
  if (this._to.push(data)) return cb();
  this._to._drain = cb;
};
Sink.prototype.destroy = function() {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit("close");
};
var LinkSink = function() {
  Writable.call(this);
  this.linkname = "";
  this._decoder = new StringDecoder("utf-8");
  this._destroyed = false;
};
inherits$2(LinkSink, Writable);
LinkSink.prototype._write = function(data, enc, cb) {
  this.linkname += this._decoder.write(data);
  cb();
};
LinkSink.prototype.destroy = function() {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit("close");
};
var Void = function() {
  Writable.call(this);
  this._destroyed = false;
};
inherits$2(Void, Writable);
Void.prototype._write = function(data, enc, cb) {
  cb(new Error("No body allowed for this entry"));
};
Void.prototype.destroy = function() {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit("close");
};
var Pack = function(opts) {
  if (!(this instanceof Pack)) return new Pack(opts);
  Readable$1.call(this, opts);
  this._drain = noop;
  this._finalized = false;
  this._finalizing = false;
  this._destroyed = false;
  this._stream = null;
};
inherits$2(Pack, Readable$1);
Pack.prototype.entry = function(header, buffer, callback) {
  if (this._stream) throw new Error("already piping an entry");
  if (this._finalized || this._destroyed) return;
  if (typeof buffer === "function") {
    callback = buffer;
    buffer = null;
  }
  if (!callback) callback = noop;
  var self2 = this;
  if (!header.size || header.type === "symlink") header.size = 0;
  if (!header.type) header.type = modeToType(header.mode);
  if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
  if (!header.uid) header.uid = 0;
  if (!header.gid) header.gid = 0;
  if (!header.mtime) header.mtime = /* @__PURE__ */ new Date();
  if (typeof buffer === "string") buffer = Buffer.from(buffer);
  if (Buffer.isBuffer(buffer)) {
    header.size = buffer.length;
    this._encode(header);
    var ok2 = this.push(buffer);
    overflow(self2, header.size);
    if (ok2) process.nextTick(callback);
    else this._drain = callback;
    return new Void();
  }
  if (header.type === "symlink" && !header.linkname) {
    var linkSink = new LinkSink();
    eos(linkSink, function(err2) {
      if (err2) {
        self2.destroy();
        return callback(err2);
      }
      header.linkname = linkSink.linkname;
      self2._encode(header);
      callback();
    });
    return linkSink;
  }
  this._encode(header);
  if (header.type !== "file" && header.type !== "contiguous-file") {
    process.nextTick(callback);
    return new Void();
  }
  var sink = new Sink(this);
  this._stream = sink;
  eos(sink, function(err2) {
    self2._stream = null;
    if (err2) {
      self2.destroy();
      return callback(err2);
    }
    if (sink.written !== header.size) {
      self2.destroy();
      return callback(new Error("size mismatch"));
    }
    overflow(self2, header.size);
    if (self2._finalizing) self2.finalize();
    callback();
  });
  return sink;
};
Pack.prototype.finalize = function() {
  if (this._stream) {
    this._finalizing = true;
    return;
  }
  if (this._finalized) return;
  this._finalized = true;
  this.push(END_OF_TAR);
  this.push(null);
};
Pack.prototype.destroy = function(err2) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err2) this.emit("error", err2);
  this.emit("close");
  if (this._stream && this._stream.destroy) this._stream.destroy();
};
Pack.prototype._encode = function(header) {
  if (!header.pax) {
    var buf = headers.encode(header);
    if (buf) {
      this.push(buf);
      return;
    }
  }
  this._encodePax(header);
};
Pack.prototype._encodePax = function(header) {
  var paxHeader = headers.encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  });
  var newHeader = {
    name: "PaxHeader",
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: "pax-header",
    linkname: header.linkname && "PaxHeader",
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  };
  this.push(headers.encode(newHeader));
  this.push(paxHeader);
  overflow(this, paxHeader.length);
  newHeader.size = header.size;
  newHeader.type = header.type;
  this.push(headers.encode(newHeader));
};
Pack.prototype._read = function(n) {
  var drain = this._drain;
  this._drain = noop;
  drain();
};
var pack = Pack;
tarStream.extract = extract$1;
tarStream.pack = pack;
/**
 * TAR Format Plugin
 *
 * @module plugins/tar
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var zlib$2 = require$$0$7;
var engine = tarStream;
var util$5 = archiverUtilsExports$1;
var Tar = function(options) {
  if (!(this instanceof Tar)) {
    return new Tar(options);
  }
  options = this.options = util$5.defaults(options, {
    gzip: false
  });
  if (typeof options.gzipOptions !== "object") {
    options.gzipOptions = {};
  }
  this.supports = {
    directory: true,
    symlink: true
  };
  this.engine = engine.pack(options);
  this.compressor = false;
  if (options.gzip) {
    this.compressor = zlib$2.createGzip(options.gzipOptions);
    this.compressor.on("error", this._onCompressorError.bind(this));
  }
};
Tar.prototype._onCompressorError = function(err2) {
  this.engine.emit("error", err2);
};
Tar.prototype.append = function(source, data, callback) {
  var self2 = this;
  data.mtime = data.date;
  function append2(err2, sourceBuffer) {
    if (err2) {
      callback(err2);
      return;
    }
    self2.engine.entry(data, sourceBuffer, function(err3) {
      callback(err3, data);
    });
  }
  if (data.sourceType === "buffer") {
    append2(null, source);
  } else if (data.sourceType === "stream" && data.stats) {
    data.size = data.stats.size;
    var entry = self2.engine.entry(data, function(err2) {
      callback(err2, data);
    });
    source.pipe(entry);
  } else if (data.sourceType === "stream") {
    util$5.collectStream(source, append2);
  }
};
Tar.prototype.finalize = function() {
  this.engine.finalize();
};
Tar.prototype.on = function() {
  return this.engine.on.apply(this.engine, arguments);
};
Tar.prototype.pipe = function(destination, options) {
  if (this.compressor) {
    return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
  } else {
    return this.engine.pipe.apply(this.engine, arguments);
  }
};
Tar.prototype.unpipe = function() {
  if (this.compressor) {
    return this.compressor.unpipe.apply(this.compressor, arguments);
  } else {
    return this.engine.unpipe.apply(this.engine, arguments);
  }
};
var tar = Tar;
/**
 * JSON Format Plugin
 *
 * @module plugins/json
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var inherits$1 = require$$0$4.inherits;
var Transform = readableExports$3.Transform;
var crc32 = bufferCrc32;
var util$4 = archiverUtilsExports$1;
var Json = function(options) {
  if (!(this instanceof Json)) {
    return new Json(options);
  }
  options = this.options = util$4.defaults(options, {});
  Transform.call(this, options);
  this.supports = {
    directory: true,
    symlink: true
  };
  this.files = [];
};
inherits$1(Json, Transform);
Json.prototype._transform = function(chunk, encoding, callback) {
  callback(null, chunk);
};
Json.prototype._writeStringified = function() {
  var fileString = JSON.stringify(this.files);
  this.write(fileString);
};
Json.prototype.append = function(source, data, callback) {
  var self2 = this;
  data.crc32 = 0;
  function onend(err2, sourceBuffer) {
    if (err2) {
      callback(err2);
      return;
    }
    data.size = sourceBuffer.length || 0;
    data.crc32 = crc32.unsigned(sourceBuffer);
    self2.files.push(data);
    callback(null, data);
  }
  if (data.sourceType === "buffer") {
    onend(null, source);
  } else if (data.sourceType === "stream") {
    util$4.collectStream(source, onend);
  }
};
Json.prototype.finalize = function() {
  this._writeStringified();
  this.end();
};
var json = Json;
/**
 * Archiver Vending
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var Archiver$1 = core;
var formats = {};
var vending = function(format, options) {
  return vending.create(format, options);
};
vending.create = function(format, options) {
  if (formats[format]) {
    var instance = new Archiver$1(format, options);
    instance.setFormat(format);
    instance.setModule(new formats[format](options));
    return instance;
  } else {
    throw new Error("create(" + format + "): format not registered");
  }
};
vending.registerFormat = function(format, module) {
  if (formats[format]) {
    throw new Error("register(" + format + "): format already registered");
  }
  if (typeof module !== "function") {
    throw new Error("register(" + format + "): format module invalid");
  }
  if (typeof module.prototype.append !== "function" || typeof module.prototype.finalize !== "function") {
    throw new Error("register(" + format + "): format module missing methods");
  }
  formats[format] = module;
};
vending.isRegisteredFormat = function(format) {
  if (formats[format]) {
    return true;
  }
  return false;
};
vending.registerFormat("zip", zip);
vending.registerFormat("tar", tar);
vending.registerFormat("json", json);
var archiver = vending;
let SharedStrings$1 = class SharedStrings {
  constructor() {
    this._values = [];
    this._totalRefs = 0;
    this._hash = /* @__PURE__ */ Object.create(null);
  }
  get count() {
    return this._values.length;
  }
  get values() {
    return this._values;
  }
  get totalRefs() {
    return this._totalRefs;
  }
  getString(index2) {
    return this._values[index2];
  }
  add(value) {
    let index2 = this._hash[value];
    if (index2 === void 0) {
      index2 = this._hash[value] = this._values.length;
      this._values.push(value);
    }
    this._totalRefs++;
    return index2;
  }
};
var sharedStrings = SharedStrings$1;
const utils$1 = utils_1;
const RelType$4 = relType;
class HyperlinksProxy {
  constructor(sheetRelsWriter2) {
    this.writer = sheetRelsWriter2;
  }
  push(hyperlink) {
    this.writer.addHyperlink(hyperlink);
  }
}
let SheetRelsWriter$1 = class SheetRelsWriter {
  constructor(options) {
    this.id = options.id;
    this.count = 0;
    this._hyperlinks = [];
    this._workbook = options.workbook;
  }
  get stream() {
    if (!this._stream) {
      this._stream = this._workbook._openStream(`/xl/worksheets/_rels/sheet${this.id}.xml.rels`);
    }
    return this._stream;
  }
  get length() {
    return this._hyperlinks.length;
  }
  each(fn) {
    return this._hyperlinks.forEach(fn);
  }
  get hyperlinksProxy() {
    return this._hyperlinksProxy || (this._hyperlinksProxy = new HyperlinksProxy(this));
  }
  addHyperlink(hyperlink) {
    const relationship = {
      Target: hyperlink.target,
      Type: RelType$4.Hyperlink,
      TargetMode: "External"
    };
    const rId = this._writeRelationship(relationship);
    this._hyperlinks.push({
      rId,
      address: hyperlink.address
    });
  }
  addMedia(media) {
    return this._writeRelationship(media);
  }
  addRelationship(rel) {
    return this._writeRelationship(rel);
  }
  commit() {
    if (this.count) {
      this._writeClose();
      this.stream.end();
    }
  }
  // ================================================================================
  _writeOpen() {
    this.stream.write(
      `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
       <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`
    );
  }
  _writeRelationship(relationship) {
    if (!this.count) {
      this._writeOpen();
    }
    const rId = `rId${++this.count}`;
    if (relationship.TargetMode) {
      this.stream.write(
        `<Relationship Id="${rId}" Type="${relationship.Type}" Target="${utils$1.xmlEncode(relationship.Target)}" TargetMode="${relationship.TargetMode}"/>`
      );
    } else {
      this.stream.write(
        `<Relationship Id="${rId}" Type="${relationship.Type}" Target="${relationship.Target}"/>`
      );
    }
    return rId;
  }
  _writeClose() {
    this.stream.write("</Relationships>");
  }
};
var sheetRelsWriter = SheetRelsWriter$1;
const XmlStream2 = xmlStream;
const RelType$3 = relType;
const colCache$2 = colCache_1;
const CommentXform = commentXformExports;
const VmlShapeXform2 = vmlShapeXform;
let SheetCommentsWriter$1 = class SheetCommentsWriter {
  constructor(worksheet2, sheetRelsWriter2, options) {
    this.id = options.id;
    this.count = 0;
    this._worksheet = worksheet2;
    this._workbook = options.workbook;
    this._sheetRelsWriter = sheetRelsWriter2;
  }
  get commentsStream() {
    if (!this._commentsStream) {
      this._commentsStream = this._workbook._openStream(`/xl/comments${this.id}.xml`);
    }
    return this._commentsStream;
  }
  get vmlStream() {
    if (!this._vmlStream) {
      this._vmlStream = this._workbook._openStream(`xl/drawings/vmlDrawing${this.id}.vml`);
    }
    return this._vmlStream;
  }
  _addRelationships() {
    const commentRel = {
      Type: RelType$3.Comments,
      Target: `../comments${this.id}.xml`
    };
    this._sheetRelsWriter.addRelationship(commentRel);
    const vmlDrawingRel = {
      Type: RelType$3.VmlDrawing,
      Target: `../drawings/vmlDrawing${this.id}.vml`
    };
    this.vmlRelId = this._sheetRelsWriter.addRelationship(vmlDrawingRel);
  }
  _addCommentRefs() {
    this._workbook.commentRefs.push({
      commentName: `comments${this.id}`,
      vmlDrawing: `vmlDrawing${this.id}`
    });
  }
  _writeOpen() {
    this.commentsStream.write(
      '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><authors><author>Author</author></authors><commentList>'
    );
    this.vmlStream.write(
      '<?xml version="1.0" encoding="UTF-8"?><xml xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:x="urn:schemas-microsoft-com:office:excel"><o:shapelayout v:ext="edit"><o:idmap v:ext="edit" data="1" /></o:shapelayout><v:shapetype id="_x0000_t202" coordsize="21600,21600" o:spt="202" path="m,l,21600r21600,l21600,xe"><v:stroke joinstyle="miter" /><v:path gradientshapeok="t" o:connecttype="rect" /></v:shapetype>'
    );
  }
  _writeComment(comment, index2) {
    const commentXform2 = new CommentXform();
    const commentsXmlStream = new XmlStream2();
    commentXform2.render(commentsXmlStream, comment);
    this.commentsStream.write(commentsXmlStream.xml);
    const vmlShapeXform2 = new VmlShapeXform2();
    const vmlXmlStream = new XmlStream2();
    vmlShapeXform2.render(vmlXmlStream, comment, index2);
    this.vmlStream.write(vmlXmlStream.xml);
  }
  _writeClose() {
    this.commentsStream.write("</commentList></comments>");
    this.vmlStream.write("</xml>");
  }
  addComments(comments) {
    if (comments && comments.length) {
      if (!this.startedData) {
        this._worksheet.comments = [];
        this._writeOpen();
        this._addRelationships();
        this._addCommentRefs();
        this.startedData = true;
      }
      comments.forEach((item) => {
        item.refAddress = colCache$2.decodeAddress(item.ref);
      });
      comments.forEach((comment) => {
        this._writeComment(comment, this.count);
        this.count += 1;
      });
    }
  }
  commit() {
    if (this.count) {
      this._writeClose();
      this.commentsStream.end();
      this.vmlStream.end();
    }
  }
};
var sheetCommentsWriter = SheetCommentsWriter$1;
const _$2 = underDash;
const RelType$2 = relType;
const colCache$1 = colCache_1;
const Encryptor = encryptor;
const Dimensions$1 = range$2;
const StringBuf2 = stringBuf;
const Row$1 = row;
const Column$1 = column$1;
const SheetRelsWriter2 = sheetRelsWriter;
const SheetCommentsWriter2 = sheetCommentsWriter;
const DataValidations2 = dataValidations;
const xmlBuffer = new StringBuf2();
const ListXform2 = listXform;
const DataValidationsXform2 = dataValidationsXform;
const SheetPropertiesXform2 = sheetPropertiesXform;
const SheetFormatPropertiesXform2 = sheetFormatPropertiesXform;
const ColXform2 = colXform;
const RowXform2 = rowXform;
const HyperlinkXform2 = hyperlinkXform;
const SheetViewXform2 = sheetViewXform;
const SheetProtectionXform2 = sheetProtectionXform;
const PageMarginsXform2 = pageMarginsXform;
const PageSetupXform2 = pageSetupXform;
const AutoFilterXform3 = autoFilterXform$1;
const PictureXform2 = pictureXform;
const ConditionalFormattingsXform2 = conditionalFormattingsXform;
const HeaderFooterXform2 = headerFooterXform;
const RowBreaksXform2 = rowBreaksXform;
const xform = {
  dataValidations: new DataValidationsXform2(),
  sheetProperties: new SheetPropertiesXform2(),
  sheetFormatProperties: new SheetFormatPropertiesXform2(),
  columns: new ListXform2({ tag: "cols", length: false, childXform: new ColXform2() }),
  row: new RowXform2(),
  hyperlinks: new ListXform2({ tag: "hyperlinks", length: false, childXform: new HyperlinkXform2() }),
  sheetViews: new ListXform2({ tag: "sheetViews", length: false, childXform: new SheetViewXform2() }),
  sheetProtection: new SheetProtectionXform2(),
  pageMargins: new PageMarginsXform2(),
  pageSeteup: new PageSetupXform2(),
  autoFilter: new AutoFilterXform3(),
  picture: new PictureXform2(),
  conditionalFormattings: new ConditionalFormattingsXform2(),
  headerFooter: new HeaderFooterXform2(),
  rowBreaks: new RowBreaksXform2()
};
let WorksheetWriter$1 = class WorksheetWriter {
  constructor(options) {
    this.id = options.id;
    this.name = options.name || `Sheet${this.id}`;
    this.state = options.state || "visible";
    this._rows = [];
    this._columns = null;
    this._keys = {};
    this._merges = [];
    this._merges.add = function() {
    };
    this._sheetRelsWriter = new SheetRelsWriter2(options);
    this._sheetCommentsWriter = new SheetCommentsWriter2(this, this._sheetRelsWriter, options);
    this._dimensions = new Dimensions$1();
    this._rowZero = 1;
    this.committed = false;
    this.dataValidations = new DataValidations2();
    this._formulae = {};
    this._siFormulae = 0;
    this.conditionalFormatting = [];
    this.rowBreaks = [];
    this.properties = Object.assign(
      {},
      {
        defaultRowHeight: 15,
        dyDescent: 55,
        outlineLevelCol: 0,
        outlineLevelRow: 0
      },
      options.properties
    );
    this.headerFooter = Object.assign(
      {},
      {
        differentFirst: false,
        differentOddEven: false,
        oddHeader: null,
        oddFooter: null,
        evenHeader: null,
        evenFooter: null,
        firstHeader: null,
        firstFooter: null
      },
      options.headerFooter
    );
    this.pageSetup = Object.assign(
      {},
      {
        margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 },
        orientation: "portrait",
        horizontalDpi: 4294967295,
        verticalDpi: 4294967295,
        fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
        pageOrder: "downThenOver",
        blackAndWhite: false,
        draft: false,
        cellComments: "None",
        errors: "displayed",
        scale: 100,
        fitToWidth: 1,
        fitToHeight: 1,
        paperSize: void 0,
        showRowColHeaders: false,
        showGridLines: false,
        horizontalCentered: false,
        verticalCentered: false,
        rowBreaks: null,
        colBreaks: null
      },
      options.pageSetup
    );
    this.useSharedStrings = options.useSharedStrings || false;
    this._workbook = options.workbook;
    this.hasComments = false;
    this._views = options.views || [];
    this.autoFilter = options.autoFilter || null;
    this._media = [];
    this.sheetProtection = null;
    this._writeOpenWorksheet();
    this.startedData = false;
  }
  get workbook() {
    return this._workbook;
  }
  get stream() {
    if (!this._stream) {
      this._stream = this._workbook._openStream(`/xl/worksheets/sheet${this.id}.xml`);
      this._stream.pause();
    }
    return this._stream;
  }
  // destroy - not a valid operation for a streaming writer
  // even though some streamers might be able to, it's a bad idea.
  destroy() {
    throw new Error("Invalid Operation: destroy");
  }
  commit() {
    if (this.committed) {
      return;
    }
    this._rows.forEach((cRow) => {
      if (cRow) {
        this._writeRow(cRow);
      }
    });
    this._rows = null;
    if (!this.startedData) {
      this._writeOpenSheetData();
    }
    this._writeCloseSheetData();
    this._writeAutoFilter();
    this._writeMergeCells();
    this._writeHyperlinks();
    this._writeConditionalFormatting();
    this._writeDataValidations();
    this._writeSheetProtection();
    this._writePageMargins();
    this._writePageSetup();
    this._writeBackground();
    this._writeHeaderFooter();
    this._writeRowBreaks();
    this._writeLegacyData();
    this._writeCloseWorksheet();
    this.stream.end();
    this._sheetCommentsWriter.commit();
    this._sheetRelsWriter.commit();
    this.committed = true;
  }
  // return the current dimensions of the writer
  get dimensions() {
    return this._dimensions;
  }
  get views() {
    return this._views;
  }
  // =========================================================================
  // Columns
  // get the current columns array.
  get columns() {
    return this._columns;
  }
  // set the columns from an array of column definitions.
  // Note: any headers defined will overwrite existing values.
  set columns(value) {
    this._headerRowCount = value.reduce((pv, cv) => {
      const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
      return Math.max(pv, headerCount);
    }, 0);
    let count = 1;
    const columns = this._columns = [];
    value.forEach((defn) => {
      const column2 = new Column$1(this, count++, false);
      columns.push(column2);
      column2.defn = defn;
    });
  }
  getColumnKey(key) {
    return this._keys[key];
  }
  setColumnKey(key, value) {
    this._keys[key] = value;
  }
  deleteColumnKey(key) {
    delete this._keys[key];
  }
  eachColumnKey(f) {
    _$2.each(this._keys, f);
  }
  // get a single column by col number. If it doesn't exist, it and any gaps before it
  // are created.
  getColumn(c2) {
    if (typeof c2 === "string") {
      const col = this._keys[c2];
      if (col) return col;
      c2 = colCache$1.l2n(c2);
    }
    if (!this._columns) {
      this._columns = [];
    }
    if (c2 > this._columns.length) {
      let n = this._columns.length + 1;
      while (n <= c2) {
        this._columns.push(new Column$1(this, n++));
      }
    }
    return this._columns[c2 - 1];
  }
  // =========================================================================
  // Rows
  get _nextRow() {
    return this._rowZero + this._rows.length;
  }
  // iterate over every uncommitted row in the worksheet, including maybe empty rows
  eachRow(options, iteratee) {
    if (!iteratee) {
      iteratee = options;
      options = void 0;
    }
    if (options && options.includeEmpty) {
      const n = this._nextRow;
      for (let i = this._rowZero; i < n; i++) {
        iteratee(this.getRow(i), i);
      }
    } else {
      this._rows.forEach((row2) => {
        if (row2.hasValues) {
          iteratee(row2, row2.number);
        }
      });
    }
  }
  _commitRow(cRow) {
    let found = false;
    while (this._rows.length && !found) {
      const row2 = this._rows.shift();
      this._rowZero++;
      if (row2) {
        this._writeRow(row2);
        found = row2.number === cRow.number;
        this._rowZero = row2.number + 1;
      }
    }
  }
  get lastRow() {
    if (this._rows.length) {
      return this._rows[this._rows.length - 1];
    }
    return void 0;
  }
  // find a row (if exists) by row number
  findRow(rowNumber) {
    const index2 = rowNumber - this._rowZero;
    return this._rows[index2];
  }
  getRow(rowNumber) {
    const index2 = rowNumber - this._rowZero;
    if (index2 < 0) {
      throw new Error("Out of bounds: this row has been committed");
    }
    let row2 = this._rows[index2];
    if (!row2) {
      this._rows[index2] = row2 = new Row$1(this, rowNumber);
    }
    return row2;
  }
  addRow(value) {
    const row2 = new Row$1(this, this._nextRow);
    this._rows[row2.number - this._rowZero] = row2;
    row2.values = value;
    return row2;
  }
  // ================================================================================
  // Cells
  // returns the cell at [r,c] or address given by r. If not found, return undefined
  findCell(r, c2) {
    const address = colCache$1.getAddress(r, c2);
    const row2 = this.findRow(address.row);
    return row2 ? row2.findCell(address.column) : void 0;
  }
  // return the cell at [r,c] or address given by r. If not found, create a new one.
  getCell(r, c2) {
    const address = colCache$1.getAddress(r, c2);
    const row2 = this.getRow(address.row);
    return row2.getCellEx(address);
  }
  mergeCells(...cells) {
    const dimensions = new Dimensions$1(cells);
    this._merges.forEach((merge) => {
      if (merge.intersects(dimensions)) {
        throw new Error("Cannot merge already merged cells");
      }
    });
    const master = this.getCell(dimensions.top, dimensions.left);
    for (let i = dimensions.top; i <= dimensions.bottom; i++) {
      for (let j = dimensions.left; j <= dimensions.right; j++) {
        if (i > dimensions.top || j > dimensions.left) {
          this.getCell(i, j).merge(master);
        }
      }
    }
    this._merges.push(dimensions);
  }
  // ===========================================================================
  // Conditional Formatting
  addConditionalFormatting(cf) {
    this.conditionalFormatting.push(cf);
  }
  removeConditionalFormatting(filter2) {
    if (typeof filter2 === "number") {
      this.conditionalFormatting.splice(filter2, 1);
    } else if (filter2 instanceof Function) {
      this.conditionalFormatting = this.conditionalFormatting.filter(filter2);
    } else {
      this.conditionalFormatting = [];
    }
  }
  // =========================================================================
  addBackgroundImage(imageId) {
    this._background = {
      imageId
    };
  }
  getBackgroundImageId() {
    return this._background && this._background.imageId;
  }
  // =========================================================================
  // Worksheet Protection
  protect(password, options) {
    return new Promise((resolve2) => {
      this.sheetProtection = {
        sheet: true
      };
      if (options && "spinCount" in options) {
        options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
      }
      if (password) {
        this.sheetProtection.algorithmName = "SHA-512";
        this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
        this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
        this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(
          password,
          "SHA512",
          this.sheetProtection.saltValue,
          this.sheetProtection.spinCount
        );
      }
      if (options) {
        this.sheetProtection = Object.assign(this.sheetProtection, options);
        if (!password && "spinCount" in options) {
          delete this.sheetProtection.spinCount;
        }
      }
      resolve2();
    });
  }
  unprotect() {
    this.sheetProtection = null;
  }
  // ================================================================================
  _write(text) {
    xmlBuffer.reset();
    xmlBuffer.addText(text);
    this.stream.write(xmlBuffer);
  }
  _writeSheetProperties(xmlBuf, properties, pageSetup) {
    const sheetPropertiesModel = {
      outlineProperties: properties && properties.outlineProperties,
      tabColor: properties && properties.tabColor,
      pageSetup: pageSetup && pageSetup.fitToPage ? {
        fitToPage: pageSetup.fitToPage
      } : void 0
    };
    xmlBuf.addText(xform.sheetProperties.toXml(sheetPropertiesModel));
  }
  _writeSheetFormatProperties(xmlBuf, properties) {
    const sheetFormatPropertiesModel = properties ? {
      defaultRowHeight: properties.defaultRowHeight,
      dyDescent: properties.dyDescent,
      outlineLevelCol: properties.outlineLevelCol,
      outlineLevelRow: properties.outlineLevelRow
    } : void 0;
    if (properties.defaultColWidth) {
      sheetFormatPropertiesModel.defaultColWidth = properties.defaultColWidth;
    }
    xmlBuf.addText(xform.sheetFormatProperties.toXml(sheetFormatPropertiesModel));
  }
  _writeOpenWorksheet() {
    xmlBuffer.reset();
    xmlBuffer.addText('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
    xmlBuffer.addText(
      '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'
    );
    this._writeSheetProperties(xmlBuffer, this.properties, this.pageSetup);
    xmlBuffer.addText(xform.sheetViews.toXml(this.views));
    this._writeSheetFormatProperties(xmlBuffer, this.properties);
    this.stream.write(xmlBuffer);
  }
  _writeColumns() {
    const cols = Column$1.toModel(this.columns);
    if (cols) {
      xform.columns.prepare(cols, { styles: this._workbook.styles });
      this.stream.write(xform.columns.toXml(cols));
    }
  }
  _writeOpenSheetData() {
    this._write("<sheetData>");
  }
  _writeRow(row2) {
    if (!this.startedData) {
      this._writeColumns();
      this._writeOpenSheetData();
      this.startedData = true;
    }
    if (row2.hasValues || row2.height) {
      const { model } = row2;
      const options = {
        styles: this._workbook.styles,
        sharedStrings: this.useSharedStrings ? this._workbook.sharedStrings : void 0,
        hyperlinks: this._sheetRelsWriter.hyperlinksProxy,
        merges: this._merges,
        formulae: this._formulae,
        siFormulae: this._siFormulae,
        comments: []
      };
      xform.row.prepare(model, options);
      this.stream.write(xform.row.toXml(model));
      if (options.comments.length) {
        this.hasComments = true;
        this._sheetCommentsWriter.addComments(options.comments);
      }
    }
  }
  _writeCloseSheetData() {
    this._write("</sheetData>");
  }
  _writeMergeCells() {
    if (this._merges.length) {
      xmlBuffer.reset();
      xmlBuffer.addText(`<mergeCells count="${this._merges.length}">`);
      this._merges.forEach((merge) => {
        xmlBuffer.addText(`<mergeCell ref="${merge}"/>`);
      });
      xmlBuffer.addText("</mergeCells>");
      this.stream.write(xmlBuffer);
    }
  }
  _writeHyperlinks() {
    this.stream.write(xform.hyperlinks.toXml(this._sheetRelsWriter._hyperlinks));
  }
  _writeConditionalFormatting() {
    const options = {
      styles: this._workbook.styles
    };
    xform.conditionalFormattings.prepare(this.conditionalFormatting, options);
    this.stream.write(xform.conditionalFormattings.toXml(this.conditionalFormatting));
  }
  _writeRowBreaks() {
    this.stream.write(xform.rowBreaks.toXml(this.rowBreaks));
  }
  _writeDataValidations() {
    this.stream.write(xform.dataValidations.toXml(this.dataValidations.model));
  }
  _writeSheetProtection() {
    this.stream.write(xform.sheetProtection.toXml(this.sheetProtection));
  }
  _writePageMargins() {
    this.stream.write(xform.pageMargins.toXml(this.pageSetup.margins));
  }
  _writePageSetup() {
    this.stream.write(xform.pageSeteup.toXml(this.pageSetup));
  }
  _writeHeaderFooter() {
    this.stream.write(xform.headerFooter.toXml(this.headerFooter));
  }
  _writeAutoFilter() {
    this.stream.write(xform.autoFilter.toXml(this.autoFilter));
  }
  _writeBackground() {
    if (this._background) {
      if (this._background.imageId !== void 0) {
        const image2 = this._workbook.getImage(this._background.imageId);
        const pictureId = this._sheetRelsWriter.addMedia({
          Target: `../media/${image2.name}`,
          Type: RelType$2.Image
        });
        this._background = {
          ...this._background,
          rId: pictureId
        };
      }
      this.stream.write(xform.picture.toXml({ rId: this._background.rId }));
    }
  }
  _writeLegacyData() {
    if (this.hasComments) {
      xmlBuffer.reset();
      xmlBuffer.addText(`<legacyDrawing r:id="${this._sheetCommentsWriter.vmlRelId}"/>`);
      this.stream.write(xmlBuffer);
    }
  }
  _writeDimensions() {
  }
  _writeCloseWorksheet() {
    this._write("</worksheet>");
  }
};
var worksheetWriter = WorksheetWriter$1;
const fs$4 = require$$0$2;
const Archiver = archiver;
const StreamBuf = streamBuf;
const RelType$1 = relType;
const StylesXform2 = stylesXform;
const SharedStrings2 = sharedStrings;
const DefinedNames2 = definedNames;
const CoreXform2 = coreXform;
const RelationshipsXform$1 = relationshipsXform;
const ContentTypesXform2 = contentTypesXform;
const AppXform2 = appXform;
const WorkbookXform$1 = workbookXform;
const SharedStringsXform2 = sharedStringsXform;
const WorksheetWriter2 = worksheetWriter;
const theme1Xml = theme1;
class WorkbookWriter {
  constructor(options) {
    options = options || {};
    this.created = options.created || /* @__PURE__ */ new Date();
    this.modified = options.modified || this.created;
    this.creator = options.creator || "ExcelJS";
    this.lastModifiedBy = options.lastModifiedBy || "ExcelJS";
    this.lastPrinted = options.lastPrinted;
    this.useSharedStrings = options.useSharedStrings || false;
    this.sharedStrings = new SharedStrings2();
    this.styles = options.useStyles ? new StylesXform2(true) : new StylesXform2.Mock(true);
    this._definedNames = new DefinedNames2();
    this._worksheets = [];
    this.views = [];
    this.zipOptions = options.zip;
    this.media = [];
    this.commentRefs = [];
    this.zip = Archiver("zip", this.zipOptions);
    if (options.stream) {
      this.stream = options.stream;
    } else if (options.filename) {
      this.stream = fs$4.createWriteStream(options.filename);
    } else {
      this.stream = new StreamBuf();
    }
    this.zip.pipe(this.stream);
    this.promise = Promise.all([this.addThemes(), this.addOfficeRels()]);
  }
  get definedNames() {
    return this._definedNames;
  }
  _openStream(path2) {
    const stream2 = new StreamBuf({ bufSize: 65536, batch: true });
    this.zip.append(stream2, { name: path2 });
    stream2.on("finish", () => {
      stream2.emit("zipped");
    });
    return stream2;
  }
  _commitWorksheets() {
    const commitWorksheet = function(worksheet2) {
      if (!worksheet2.committed) {
        return new Promise((resolve2) => {
          worksheet2.stream.on("zipped", () => {
            resolve2();
          });
          worksheet2.commit();
        });
      }
      return Promise.resolve();
    };
    const promises = this._worksheets.map(commitWorksheet);
    if (promises.length) {
      return Promise.all(promises);
    }
    return Promise.resolve();
  }
  async commit() {
    await this.promise;
    await this.addMedia();
    await this._commitWorksheets();
    await Promise.all([
      this.addContentTypes(),
      this.addApp(),
      this.addCore(),
      this.addSharedStrings(),
      this.addStyles(),
      this.addWorkbookRels()
    ]);
    await this.addWorkbook();
    return this._finalize();
  }
  get nextId() {
    let i;
    for (i = 1; i < this._worksheets.length; i++) {
      if (!this._worksheets[i]) {
        return i;
      }
    }
    return this._worksheets.length || 1;
  }
  addImage(image2) {
    const id = this.media.length;
    const medium = Object.assign({}, image2, { type: "image", name: `image${id}.${image2.extension}` });
    this.media.push(medium);
    return id;
  }
  getImage(id) {
    return this.media[id];
  }
  addWorksheet(name, options) {
    options = options || {};
    const useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : this.useSharedStrings;
    if (options.tabColor) {
      console.trace("tabColor option has moved to { properties: tabColor: {...} }");
      options.properties = Object.assign(
        {
          tabColor: options.tabColor
        },
        options.properties
      );
    }
    const id = this.nextId;
    name = name || `sheet${id}`;
    const worksheet2 = new WorksheetWriter2({
      id,
      name,
      workbook: this,
      useSharedStrings,
      properties: options.properties,
      state: options.state,
      pageSetup: options.pageSetup,
      views: options.views,
      autoFilter: options.autoFilter,
      headerFooter: options.headerFooter
    });
    this._worksheets[id] = worksheet2;
    return worksheet2;
  }
  getWorksheet(id) {
    if (id === void 0) {
      return this._worksheets.find(() => true);
    }
    if (typeof id === "number") {
      return this._worksheets[id];
    }
    if (typeof id === "string") {
      return this._worksheets.find((worksheet2) => worksheet2 && worksheet2.name === id);
    }
    return void 0;
  }
  addStyles() {
    return new Promise((resolve2) => {
      this.zip.append(this.styles.xml, { name: "xl/styles.xml" });
      resolve2();
    });
  }
  addThemes() {
    return new Promise((resolve2) => {
      this.zip.append(theme1Xml, { name: "xl/theme/theme1.xml" });
      resolve2();
    });
  }
  addOfficeRels() {
    return new Promise((resolve2) => {
      const xform2 = new RelationshipsXform$1();
      const xml = xform2.toXml([
        { Id: "rId1", Type: RelType$1.OfficeDocument, Target: "xl/workbook.xml" },
        { Id: "rId2", Type: RelType$1.CoreProperties, Target: "docProps/core.xml" },
        { Id: "rId3", Type: RelType$1.ExtenderProperties, Target: "docProps/app.xml" }
      ]);
      this.zip.append(xml, { name: "/_rels/.rels" });
      resolve2();
    });
  }
  addContentTypes() {
    return new Promise((resolve2) => {
      const model = {
        worksheets: this._worksheets.filter(Boolean),
        sharedStrings: this.sharedStrings,
        commentRefs: this.commentRefs,
        media: this.media
      };
      const xform2 = new ContentTypesXform2();
      const xml = xform2.toXml(model);
      this.zip.append(xml, { name: "[Content_Types].xml" });
      resolve2();
    });
  }
  addMedia() {
    return Promise.all(
      this.media.map((medium) => {
        if (medium.type === "image") {
          const filename = `xl/media/${medium.name}`;
          if (medium.filename) {
            return this.zip.file(medium.filename, { name: filename });
          }
          if (medium.buffer) {
            return this.zip.append(medium.buffer, { name: filename });
          }
          if (medium.base64) {
            const dataimg64 = medium.base64;
            const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
            return this.zip.append(content, { name: filename, base64: true });
          }
        }
        throw new Error("Unsupported media");
      })
    );
  }
  addApp() {
    return new Promise((resolve2) => {
      const model = {
        worksheets: this._worksheets.filter(Boolean)
      };
      const xform2 = new AppXform2();
      const xml = xform2.toXml(model);
      this.zip.append(xml, { name: "docProps/app.xml" });
      resolve2();
    });
  }
  addCore() {
    return new Promise((resolve2) => {
      const coreXform2 = new CoreXform2();
      const xml = coreXform2.toXml(this);
      this.zip.append(xml, { name: "docProps/core.xml" });
      resolve2();
    });
  }
  addSharedStrings() {
    if (this.sharedStrings.count) {
      return new Promise((resolve2) => {
        const sharedStringsXform2 = new SharedStringsXform2();
        const xml = sharedStringsXform2.toXml(this.sharedStrings);
        this.zip.append(xml, { name: "/xl/sharedStrings.xml" });
        resolve2();
      });
    }
    return Promise.resolve();
  }
  addWorkbookRels() {
    let count = 1;
    const relationships = [
      { Id: `rId${count++}`, Type: RelType$1.Styles, Target: "styles.xml" },
      { Id: `rId${count++}`, Type: RelType$1.Theme, Target: "theme/theme1.xml" }
    ];
    if (this.sharedStrings.count) {
      relationships.push({
        Id: `rId${count++}`,
        Type: RelType$1.SharedStrings,
        Target: "sharedStrings.xml"
      });
    }
    this._worksheets.forEach((worksheet2) => {
      if (worksheet2) {
        worksheet2.rId = `rId${count++}`;
        relationships.push({
          Id: worksheet2.rId,
          Type: RelType$1.Worksheet,
          Target: `worksheets/sheet${worksheet2.id}.xml`
        });
      }
    });
    return new Promise((resolve2) => {
      const xform2 = new RelationshipsXform$1();
      const xml = xform2.toXml(relationships);
      this.zip.append(xml, { name: "/xl/_rels/workbook.xml.rels" });
      resolve2();
    });
  }
  addWorkbook() {
    const { zip: zip2 } = this;
    const model = {
      worksheets: this._worksheets.filter(Boolean),
      definedNames: this._definedNames.model,
      views: this.views,
      properties: {},
      calcProperties: {}
    };
    return new Promise((resolve2) => {
      const xform2 = new WorkbookXform$1();
      xform2.prepare(model);
      zip2.append(xform2.toXml(model), { name: "/xl/workbook.xml" });
      resolve2();
    });
  }
  _finalize() {
    return new Promise((resolve2, reject2) => {
      this.stream.on("error", reject2);
      this.stream.on("finish", () => {
        resolve2(this);
      });
      this.zip.on("error", reject2);
      this.zip.finalize();
    });
  }
}
var workbookWriter = WorkbookWriter;
var unzip$3 = {};
require$$2$1.listenerCount;
var initBuffer$1 = function initBuffer(val) {
  var nodeVersion = process && process.version ? process.version : "v5.0.0";
  var major = nodeVersion.split(".")[0].replace("v", "");
  return major < 6 ? new Buffer(val) : Buffer.from(val);
};
var initBuffer2 = initBuffer$1;
if (!Buffer.prototype.indexOf) {
  Buffer.prototype.indexOf = function(value, offset) {
    offset = offset || 0;
    if (typeof value === "string" || value instanceof String) {
      value = initBuffer2(value);
    } else if (typeof value === "number" || value instanceof Number) {
      value = initBuffer2([value]);
    }
    var len = value.length;
    for (var i = offset; i <= this.length - len; i++) {
      var mismatch = false;
      for (var j = 0; j < len; j++) {
        if (this[i + j] != value[j]) {
          mismatch = true;
          break;
        }
      }
      if (!mismatch) {
        return i;
      }
    }
    return -1;
  };
}
function bufferLastIndexOf(value, offset) {
  if (typeof value === "string" || value instanceof String) {
    value = initBuffer2(value);
  } else if (typeof value === "number" || value instanceof Number) {
    value = initBuffer2([value]);
  }
  var len = value.length;
  offset = offset || this.length - len;
  for (var i = offset; i >= 0; i--) {
    var mismatch = false;
    for (var j = 0; j < len; j++) {
      if (this[i + j] != value[j]) {
        mismatch = true;
        break;
      }
    }
    if (!mismatch) {
      return i;
    }
  }
  return -1;
}
if (Buffer.prototype.lastIndexOf) {
  if (initBuffer2("ABC").lastIndexOf("ABC") === -1)
    Buffer.prototype.lastIndexOf = bufferLastIndexOf;
} else {
  Buffer.prototype.lastIndexOf = bufferLastIndexOf;
}
var binary$4 = { exports: {} };
var traverse = Traverse$1;
function Traverse$1(obj) {
  if (!(this instanceof Traverse$1)) return new Traverse$1(obj);
  this.value = obj;
}
Traverse$1.prototype.get = function(ps) {
  var node2 = this.value;
  for (var i = 0; i < ps.length; i++) {
    var key = ps[i];
    if (!Object.hasOwnProperty.call(node2, key)) {
      node2 = void 0;
      break;
    }
    node2 = node2[key];
  }
  return node2;
};
Traverse$1.prototype.set = function(ps, value) {
  var node2 = this.value;
  for (var i = 0; i < ps.length - 1; i++) {
    var key = ps[i];
    if (!Object.hasOwnProperty.call(node2, key)) node2[key] = {};
    node2 = node2[key];
  }
  node2[ps[i]] = value;
  return value;
};
Traverse$1.prototype.map = function(cb) {
  return walk(this.value, cb, true);
};
Traverse$1.prototype.forEach = function(cb) {
  this.value = walk(this.value, cb, false);
  return this.value;
};
Traverse$1.prototype.reduce = function(cb, init) {
  var skip = arguments.length === 1;
  var acc = skip ? this.value : init;
  this.forEach(function(x) {
    if (!this.isRoot || !skip) {
      acc = cb.call(this, acc, x);
    }
  });
  return acc;
};
Traverse$1.prototype.deepEqual = function(obj) {
  if (arguments.length !== 1) {
    throw new Error(
      "deepEqual requires exactly one object to compare against"
    );
  }
  var equal = true;
  var node2 = obj;
  this.forEach(function(y) {
    var notEqual = (function() {
      equal = false;
      return void 0;
    }).bind(this);
    if (!this.isRoot) {
      if (typeof node2 !== "object") return notEqual();
      node2 = node2[this.key];
    }
    var x = node2;
    this.post(function() {
      node2 = x;
    });
    var toS = function(o) {
      return Object.prototype.toString.call(o);
    };
    if (this.circular) {
      if (Traverse$1(obj).get(this.circular.path) !== x) notEqual();
    } else if (typeof x !== typeof y) {
      notEqual();
    } else if (x === null || y === null || x === void 0 || y === void 0) {
      if (x !== y) notEqual();
    } else if (x.__proto__ !== y.__proto__) {
      notEqual();
    } else if (x === y) ;
    else if (typeof x === "function") {
      if (x instanceof RegExp) {
        if (x.toString() != y.toString()) notEqual();
      } else if (x !== y) notEqual();
    } else if (typeof x === "object") {
      if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
        if (toS(x) !== toS(y)) {
          notEqual();
        }
      } else if (x instanceof Date || y instanceof Date) {
        if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
          notEqual();
        }
      } else {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (kx.length !== ky.length) return notEqual();
        for (var i = 0; i < kx.length; i++) {
          var k = kx[i];
          if (!Object.hasOwnProperty.call(y, k)) {
            notEqual();
          }
        }
      }
    }
  });
  return equal;
};
Traverse$1.prototype.paths = function() {
  var acc = [];
  this.forEach(function(x) {
    acc.push(this.path);
  });
  return acc;
};
Traverse$1.prototype.nodes = function() {
  var acc = [];
  this.forEach(function(x) {
    acc.push(this.node);
  });
  return acc;
};
Traverse$1.prototype.clone = function() {
  var parents = [], nodes = [];
  return function clone2(src2) {
    for (var i = 0; i < parents.length; i++) {
      if (parents[i] === src2) {
        return nodes[i];
      }
    }
    if (typeof src2 === "object" && src2 !== null) {
      var dst = copy2(src2);
      parents.push(src2);
      nodes.push(dst);
      Object.keys(src2).forEach(function(key) {
        dst[key] = clone2(src2[key]);
      });
      parents.pop();
      nodes.pop();
      return dst;
    } else {
      return src2;
    }
  }(this.value);
};
function walk(root2, cb, immutable) {
  var path2 = [];
  var parents = [];
  var alive = true;
  return function walker(node_) {
    var node2 = immutable ? copy2(node_) : node_;
    var modifiers = {};
    var state2 = {
      node: node2,
      node_,
      path: [].concat(path2),
      parent: parents.slice(-1)[0],
      key: path2.slice(-1)[0],
      isRoot: path2.length === 0,
      level: path2.length,
      circular: null,
      update: function(x) {
        if (!state2.isRoot) {
          state2.parent.node[state2.key] = x;
        }
        state2.node = x;
      },
      "delete": function() {
        delete state2.parent.node[state2.key];
      },
      remove: function() {
        if (Array.isArray(state2.parent.node)) {
          state2.parent.node.splice(state2.key, 1);
        } else {
          delete state2.parent.node[state2.key];
        }
      },
      before: function(f) {
        modifiers.before = f;
      },
      after: function(f) {
        modifiers.after = f;
      },
      pre: function(f) {
        modifiers.pre = f;
      },
      post: function(f) {
        modifiers.post = f;
      },
      stop: function() {
        alive = false;
      }
    };
    if (!alive) return state2;
    if (typeof node2 === "object" && node2 !== null) {
      state2.isLeaf = Object.keys(node2).length == 0;
      for (var i = 0; i < parents.length; i++) {
        if (parents[i].node_ === node_) {
          state2.circular = parents[i];
          break;
        }
      }
    } else {
      state2.isLeaf = true;
    }
    state2.notLeaf = !state2.isLeaf;
    state2.notRoot = !state2.isRoot;
    var ret = cb.call(state2, state2.node);
    if (ret !== void 0 && state2.update) state2.update(ret);
    if (modifiers.before) modifiers.before.call(state2, state2.node);
    if (typeof state2.node == "object" && state2.node !== null && !state2.circular) {
      parents.push(state2);
      var keys = Object.keys(state2.node);
      keys.forEach(function(key, i2) {
        path2.push(key);
        if (modifiers.pre) modifiers.pre.call(state2, state2.node[key], key);
        var child = walker(state2.node[key]);
        if (immutable && Object.hasOwnProperty.call(state2.node, key)) {
          state2.node[key] = child.node;
        }
        child.isLast = i2 == keys.length - 1;
        child.isFirst = i2 == 0;
        if (modifiers.post) modifiers.post.call(state2, child);
        path2.pop();
      });
      parents.pop();
    }
    if (modifiers.after) modifiers.after.call(state2, state2.node);
    return state2;
  }(root2).node;
}
Object.keys(Traverse$1.prototype).forEach(function(key) {
  Traverse$1[key] = function(obj) {
    var args = [].slice.call(arguments, 1);
    var t = Traverse$1(obj);
    return t[key].apply(t, args);
  };
});
function copy2(src2) {
  if (typeof src2 === "object" && src2 !== null) {
    var dst;
    if (Array.isArray(src2)) {
      dst = [];
    } else if (src2 instanceof Date) {
      dst = new Date(src2);
    } else if (src2 instanceof Boolean) {
      dst = new Boolean(src2);
    } else if (src2 instanceof Number) {
      dst = new Number(src2);
    } else if (src2 instanceof String) {
      dst = new String(src2);
    } else {
      dst = Object.create(Object.getPrototypeOf(src2));
    }
    Object.keys(src2).forEach(function(key) {
      dst[key] = src2[key];
    });
    return dst;
  } else return src2;
}
var Traverse = traverse;
var EventEmitter$3 = require$$2$1.EventEmitter;
var chainsaw = Chainsaw;
function Chainsaw(builder) {
  var saw = Chainsaw.saw(builder, {});
  var r = builder.call(saw.handlers, saw);
  if (r !== void 0) saw.handlers = r;
  saw.record();
  return saw.chain();
}
Chainsaw.light = function ChainsawLight(builder) {
  var saw = Chainsaw.saw(builder, {});
  var r = builder.call(saw.handlers, saw);
  if (r !== void 0) saw.handlers = r;
  return saw.chain();
};
Chainsaw.saw = function(builder, handlers) {
  var saw = new EventEmitter$3();
  saw.handlers = handlers;
  saw.actions = [];
  saw.chain = function() {
    var ch = Traverse(saw.handlers).map(function(node2) {
      if (this.isRoot) return node2;
      var ps = this.path;
      if (typeof node2 === "function") {
        this.update(function() {
          saw.actions.push({
            path: ps,
            args: [].slice.call(arguments)
          });
          return ch;
        });
      }
    });
    process.nextTick(function() {
      saw.emit("begin");
      saw.next();
    });
    return ch;
  };
  saw.pop = function() {
    return saw.actions.shift();
  };
  saw.next = function() {
    var action = saw.pop();
    if (!action) {
      saw.emit("end");
    } else if (!action.trap) {
      var node2 = saw.handlers;
      action.path.forEach(function(key) {
        node2 = node2[key];
      });
      node2.apply(saw.handlers, action.args);
    }
  };
  saw.nest = function(cb) {
    var args = [].slice.call(arguments, 1);
    var autonext = true;
    if (typeof cb === "boolean") {
      var autonext = cb;
      cb = args.shift();
    }
    var s = Chainsaw.saw(builder, {});
    var r = builder.call(s.handlers, s);
    if (r !== void 0) s.handlers = r;
    if ("undefined" !== typeof saw.step) {
      s.record();
    }
    cb.apply(s.chain(), args);
    if (autonext !== false) s.on("end", saw.next);
  };
  saw.record = function() {
    upgradeChainsaw(saw);
  };
  ["trap", "down", "jump"].forEach(function(method2) {
    saw[method2] = function() {
      throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
    };
  });
  return saw;
};
function upgradeChainsaw(saw) {
  saw.step = 0;
  saw.pop = function() {
    return saw.actions[saw.step++];
  };
  saw.trap = function(name, cb) {
    var ps = Array.isArray(name) ? name : [name];
    saw.actions.push({
      path: ps,
      step: saw.step,
      cb,
      trap: true
    });
  };
  saw.down = function(name) {
    var ps = (Array.isArray(name) ? name : [name]).join("/");
    var i = saw.actions.slice(saw.step).map(function(x) {
      if (x.trap && x.step <= saw.step) return false;
      return x.path.join("/") == ps;
    }).indexOf(true);
    if (i >= 0) saw.step += i;
    else saw.step = saw.actions.length;
    var act = saw.actions[saw.step - 1];
    if (act && act.trap) {
      saw.step = act.step;
      act.cb();
    } else saw.next();
  };
  saw.jump = function(step) {
    saw.step = step;
    saw.next();
  };
}
var buffers = Buffers;
function Buffers(bufs) {
  if (!(this instanceof Buffers)) return new Buffers(bufs);
  this.buffers = bufs || [];
  this.length = this.buffers.reduce(function(size, buf) {
    return size + buf.length;
  }, 0);
}
Buffers.prototype.push = function() {
  for (var i = 0; i < arguments.length; i++) {
    if (!Buffer.isBuffer(arguments[i])) {
      throw new TypeError("Tried to push a non-buffer");
    }
  }
  for (var i = 0; i < arguments.length; i++) {
    var buf = arguments[i];
    this.buffers.push(buf);
    this.length += buf.length;
  }
  return this.length;
};
Buffers.prototype.unshift = function() {
  for (var i = 0; i < arguments.length; i++) {
    if (!Buffer.isBuffer(arguments[i])) {
      throw new TypeError("Tried to unshift a non-buffer");
    }
  }
  for (var i = 0; i < arguments.length; i++) {
    var buf = arguments[i];
    this.buffers.unshift(buf);
    this.length += buf.length;
  }
  return this.length;
};
Buffers.prototype.copy = function(dst, dStart, start, end2) {
  return this.slice(start, end2).copy(dst, dStart, 0, end2 - start);
};
Buffers.prototype.splice = function(i, howMany) {
  var buffers2 = this.buffers;
  var index2 = i >= 0 ? i : this.length - i;
  var reps = [].slice.call(arguments, 2);
  if (howMany === void 0) {
    howMany = this.length - index2;
  } else if (howMany > this.length - index2) {
    howMany = this.length - index2;
  }
  for (var i = 0; i < reps.length; i++) {
    this.length += reps[i].length;
  }
  var removed = new Buffers();
  var startBytes = 0;
  for (var ii = 0; ii < buffers2.length && startBytes + buffers2[ii].length < index2; ii++) {
    startBytes += buffers2[ii].length;
  }
  if (index2 - startBytes > 0) {
    var start = index2 - startBytes;
    if (start + howMany < buffers2[ii].length) {
      removed.push(buffers2[ii].slice(start, start + howMany));
      var orig = buffers2[ii];
      var buf0 = new Buffer(start);
      for (var i = 0; i < start; i++) {
        buf0[i] = orig[i];
      }
      var buf1 = new Buffer(orig.length - start - howMany);
      for (var i = start + howMany; i < orig.length; i++) {
        buf1[i - howMany - start] = orig[i];
      }
      if (reps.length > 0) {
        var reps_ = reps.slice();
        reps_.unshift(buf0);
        reps_.push(buf1);
        buffers2.splice.apply(buffers2, [ii, 1].concat(reps_));
        ii += reps_.length;
        reps = [];
      } else {
        buffers2.splice(ii, 1, buf0, buf1);
        ii += 2;
      }
    } else {
      removed.push(buffers2[ii].slice(start));
      buffers2[ii] = buffers2[ii].slice(0, start);
      ii++;
    }
  }
  if (reps.length > 0) {
    buffers2.splice.apply(buffers2, [ii, 0].concat(reps));
    ii += reps.length;
  }
  while (removed.length < howMany) {
    var buf = buffers2[ii];
    var len = buf.length;
    var take = Math.min(len, howMany - removed.length);
    if (take === len) {
      removed.push(buf);
      buffers2.splice(ii, 1);
    } else {
      removed.push(buf.slice(0, take));
      buffers2[ii] = buffers2[ii].slice(take);
    }
  }
  this.length -= removed.length;
  return removed;
};
Buffers.prototype.slice = function(i, j) {
  var buffers2 = this.buffers;
  if (j === void 0) j = this.length;
  if (i === void 0) i = 0;
  if (j > this.length) j = this.length;
  var startBytes = 0;
  for (var si = 0; si < buffers2.length && startBytes + buffers2[si].length <= i; si++) {
    startBytes += buffers2[si].length;
  }
  var target = new Buffer(j - i);
  var ti = 0;
  for (var ii = si; ti < j - i && ii < buffers2.length; ii++) {
    var len = buffers2[ii].length;
    var start = ti === 0 ? i - startBytes : 0;
    var end2 = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
    buffers2[ii].copy(target, ti, start, end2);
    ti += end2 - start;
  }
  return target;
};
Buffers.prototype.pos = function(i) {
  if (i < 0 || i >= this.length) throw new Error("oob");
  var l = i, bi = 0, bu = null;
  for (; ; ) {
    bu = this.buffers[bi];
    if (l < bu.length) {
      return { buf: bi, offset: l };
    } else {
      l -= bu.length;
    }
    bi++;
  }
};
Buffers.prototype.get = function get2(i) {
  var pos = this.pos(i);
  return this.buffers[pos.buf].get(pos.offset);
};
Buffers.prototype.set = function set(i, b) {
  var pos = this.pos(i);
  return this.buffers[pos.buf].set(pos.offset, b);
};
Buffers.prototype.indexOf = function(needle, offset) {
  if ("string" === typeof needle) {
    needle = new Buffer(needle);
  } else if (needle instanceof Buffer) ;
  else {
    throw new Error("Invalid type for a search string");
  }
  if (!needle.length) {
    return 0;
  }
  if (!this.length) {
    return -1;
  }
  var i = 0, j = 0, match2 = 0, mstart, pos = 0;
  if (offset) {
    var p = this.pos(offset);
    i = p.buf;
    j = p.offset;
    pos = offset;
  }
  for (; ; ) {
    while (j >= this.buffers[i].length) {
      j = 0;
      i++;
      if (i >= this.buffers.length) {
        return -1;
      }
    }
    var char = this.buffers[i][j];
    if (char == needle[match2]) {
      if (match2 == 0) {
        mstart = {
          i,
          j,
          pos
        };
      }
      match2++;
      if (match2 == needle.length) {
        return mstart.pos;
      }
    } else if (match2 != 0) {
      i = mstart.i;
      j = mstart.j;
      pos = mstart.pos;
      match2 = 0;
    }
    j++;
    pos++;
  }
};
Buffers.prototype.toBuffer = function() {
  return this.slice();
};
Buffers.prototype.toString = function(encoding, start, end2) {
  return this.slice(start, end2).toString(encoding);
};
var vars = function(store) {
  function getset(name, value) {
    var node2 = vars2.store;
    var keys = name.split(".");
    keys.slice(0, -1).forEach(function(k) {
      if (node2[k] === void 0) node2[k] = {};
      node2 = node2[k];
    });
    var key = keys[keys.length - 1];
    if (arguments.length == 1) {
      return node2[key];
    } else {
      return node2[key] = value;
    }
  }
  var vars2 = {
    get: function(name) {
      return getset(name);
    },
    set: function(name, value) {
      return getset(name, value);
    },
    store: store || {}
  };
  return vars2;
};
(function(module, exports) {
  var Chainsaw2 = chainsaw;
  var EventEmitter2 = require$$2$1.EventEmitter;
  var Buffers2 = buffers;
  var Vars = vars;
  var Stream2 = require$$0$1.Stream;
  exports = module.exports = function(bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
      return exports.parse(bufOrEm);
    }
    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe) {
      bufOrEm.pipe(s);
    } else if (bufOrEm) {
      bufOrEm.on(eventName || "data", function(buf) {
        s.write(buf);
      });
      bufOrEm.on("end", function() {
        s.end();
      });
    }
    return s;
  };
  exports.stream = function(input) {
    if (input) return exports.apply(null, arguments);
    var pending = null;
    function getBytes(bytes, cb, skip) {
      pending = {
        bytes,
        skip,
        cb: function(buf) {
          pending = null;
          cb(buf);
        }
      };
      dispatch();
    }
    var offset = null;
    function dispatch() {
      if (!pending) {
        if (caughtEnd) done = true;
        return;
      }
      if (typeof pending === "function") {
        pending();
      } else {
        var bytes = offset + pending.bytes;
        if (buffers2.length >= bytes) {
          var buf;
          if (offset == null) {
            buf = buffers2.splice(0, bytes);
            if (!pending.skip) {
              buf = buf.slice();
            }
          } else {
            if (!pending.skip) {
              buf = buffers2.slice(offset, bytes);
            }
            offset = bytes;
          }
          if (pending.skip) {
            pending.cb();
          } else {
            pending.cb(buf);
          }
        }
      }
    }
    function builder(saw) {
      function next() {
        if (!done) saw.next();
      }
      var self2 = words(function(bytes, cb) {
        return function(name) {
          getBytes(bytes, function(buf) {
            vars2.set(name, cb(buf));
            next();
          });
        };
      });
      self2.tap = function(cb) {
        saw.nest(cb, vars2.store);
      };
      self2.into = function(key, cb) {
        if (!vars2.get(key)) vars2.set(key, {});
        var parent2 = vars2;
        vars2 = Vars(parent2.get(key));
        saw.nest(function() {
          cb.apply(this, arguments);
          this.tap(function() {
            vars2 = parent2;
          });
        }, vars2.store);
      };
      self2.flush = function() {
        vars2.store = {};
        next();
      };
      self2.loop = function(cb) {
        var end2 = false;
        saw.nest(false, function loop() {
          this.vars = vars2.store;
          cb.call(this, function() {
            end2 = true;
            next();
          }, vars2.store);
          this.tap((function() {
            if (end2) saw.next();
            else loop.call(this);
          }).bind(this));
        }, vars2.store);
      };
      self2.buffer = function(name, bytes) {
        if (typeof bytes === "string") {
          bytes = vars2.get(bytes);
        }
        getBytes(bytes, function(buf) {
          vars2.set(name, buf);
          next();
        });
      };
      self2.skip = function(bytes) {
        if (typeof bytes === "string") {
          bytes = vars2.get(bytes);
        }
        getBytes(bytes, function() {
          next();
        });
      };
      self2.scan = function find(name, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        var taken = 0;
        pending = function() {
          var pos = buffers2.indexOf(search, offset + taken);
          var i = pos - offset - taken;
          if (pos !== -1) {
            pending = null;
            if (offset != null) {
              vars2.set(
                name,
                buffers2.slice(offset, offset + taken + i)
              );
              offset += taken + i + search.length;
            } else {
              vars2.set(
                name,
                buffers2.slice(0, taken + i)
              );
              buffers2.splice(0, taken + i + search.length);
            }
            next();
            dispatch();
          } else {
            i = Math.max(buffers2.length - search.length - offset - taken, 0);
          }
          taken += i;
        };
        dispatch();
      };
      self2.peek = function(cb) {
        offset = 0;
        saw.nest(function() {
          cb.call(this, vars2.store);
          this.tap(function() {
            offset = null;
          });
        });
      };
      return self2;
    }
    var stream2 = Chainsaw2.light(builder);
    stream2.writable = true;
    var buffers2 = Buffers2();
    stream2.write = function(buf) {
      buffers2.push(buf);
      dispatch();
    };
    var vars2 = Vars();
    var done = false, caughtEnd = false;
    stream2.end = function() {
      caughtEnd = true;
    };
    stream2.pipe = Stream2.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter2.prototype).forEach(function(name) {
      stream2[name] = EventEmitter2.prototype[name];
    });
    return stream2;
  };
  exports.parse = function parse2(buffer) {
    var self2 = words(function(bytes, cb) {
      return function(name) {
        if (offset + bytes <= buffer.length) {
          var buf = buffer.slice(offset, offset + bytes);
          offset += bytes;
          vars2.set(name, cb(buf));
        } else {
          vars2.set(name, null);
        }
        return self2;
      };
    });
    var offset = 0;
    var vars2 = Vars();
    self2.vars = vars2.store;
    self2.tap = function(cb) {
      cb.call(self2, vars2.store);
      return self2;
    };
    self2.into = function(key, cb) {
      if (!vars2.get(key)) {
        vars2.set(key, {});
      }
      var parent2 = vars2;
      vars2 = Vars(parent2.get(key));
      cb.call(self2, vars2.store);
      vars2 = parent2;
      return self2;
    };
    self2.loop = function(cb) {
      var end2 = false;
      var ender = function() {
        end2 = true;
      };
      while (end2 === false) {
        cb.call(self2, ender, vars2.store);
      }
      return self2;
    };
    self2.buffer = function(name, size) {
      if (typeof size === "string") {
        size = vars2.get(size);
      }
      var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
      offset += size;
      vars2.set(name, buf);
      return self2;
    };
    self2.skip = function(bytes) {
      if (typeof bytes === "string") {
        bytes = vars2.get(bytes);
      }
      offset += bytes;
      return self2;
    };
    self2.scan = function(name, search) {
      if (typeof search === "string") {
        search = new Buffer(search);
      } else if (!Buffer.isBuffer(search)) {
        throw new Error("search must be a Buffer or a string");
      }
      vars2.set(name, null);
      for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
        for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++) ;
        if (j === search.length) break;
      }
      vars2.set(name, buffer.slice(offset, offset + i));
      offset += i + search.length;
      return self2;
    };
    self2.peek = function(cb) {
      var was = offset;
      cb.call(self2, vars2.store);
      offset = was;
      return self2;
    };
    self2.flush = function() {
      vars2.store = {};
      return self2;
    };
    self2.eof = function() {
      return offset >= buffer.length;
    };
    return self2;
  };
  function decodeLEu(bytes) {
    var acc = 0;
    for (var i = 0; i < bytes.length; i++) {
      acc += Math.pow(256, i) * bytes[i];
    }
    return acc;
  }
  function decodeBEu(bytes) {
    var acc = 0;
    for (var i = 0; i < bytes.length; i++) {
      acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    }
    return acc;
  }
  function decodeBEs(bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function decodeLEs(bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 128) == 128) {
      val -= Math.pow(256, bytes.length);
    }
    return val;
  }
  function words(decode) {
    var self2 = {};
    [1, 2, 4, 8].forEach(function(bytes) {
      var bits = bytes * 8;
      self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes, decodeLEu);
      self2["word" + bits + "ls"] = decode(bytes, decodeLEs);
      self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes, decodeBEu);
      self2["word" + bits + "bs"] = decode(bytes, decodeBEs);
    });
    self2.word8 = self2.word8u = self2.word8be;
    self2.word8s = self2.word8bs;
    return self2;
  }
})(binary$4, binary$4.exports);
var binaryExports = binary$4.exports;
var promise = { exports: {} };
var es5 = { exports: {} };
var hasRequiredEs5;
function requireEs5() {
  if (hasRequiredEs5) return es5.exports;
  hasRequiredEs5 = 1;
  var isES5 = /* @__PURE__ */ function() {
    return this === void 0;
  }();
  if (isES5) {
    es5.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;
    var ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    var ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    var ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    var ObjectFreeze = function(obj) {
      return obj;
    };
    var ObjectGetPrototypeOf = function(obj) {
      try {
        return Object(obj).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    var ArrayIsArray = function(obj) {
      try {
        return str.call(obj) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    es5.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  return es5.exports;
}
var util$3;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$3;
  hasRequiredUtil = 1;
  var es52 = requireEs5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : commonjsGlobal !== void 0 ? commonjsGlobal : null;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits2 = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject2(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key, defaultValue) {
    if (es52.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2)) return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es52.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0; i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es52.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = /* @__PURE__ */ Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys;
          try {
            keys = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key]) continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj2 = es52.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2)) return [];
        var ret2 = [];
        enumeration: for (var key in obj2) {
          if (hasProp.call(obj2, key)) {
            ret2.push(key);
          } else {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (hasProp.call(excludedPrototypes[i], key)) {
                continue enumeration;
              }
            }
            ret2.push(key);
          }
        }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es52.names(fn.prototype);
        var hasMethods = es52.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es52.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    return obj;
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str) {
    return rident.test(str);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0; i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError(obj2) {
    return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {
    }
  }
  function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return isError(obj2) && es52.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = function() {
    if (!("stack" in new Error())) {
      return function(value) {
        if (canAttachTrace(value)) return value;
        try {
          throw new Error(safeToString(value));
        } catch (err2) {
          return err2;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value)) return value;
        return new Error(safeToString(value));
      };
    }
  }();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from, to, filter2) {
    var keys = es52.names(from);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (filter2(key)) {
        try {
          es52.defineProperty(to, key, es52.getDescriptor(from, key));
        } catch (ignore) {
        }
      }
    }
  }
  var asArray = function(v) {
    if (es52.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es52.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  function env(key) {
    return hasEnvVariables ? process.env[key] : void 0;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise2 = new Promise(function() {
        });
        if ({}.toString.call(promise2) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {
      }
    }
  }
  function domainBind(self2, cb) {
    return self2.bind(cb);
  }
  var ret = {
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es52.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject: isObject2,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits: inherits2,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    domainBind
  };
  ret.isRecentNode = ret.isNode && function() {
    var version2 = process.versions.node.split(".").map(Number);
    return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
  }();
  if (ret.isNode) ret.toFastProperties(process);
  try {
    throw new Error();
  } catch (e) {
    ret.lastLineError = e;
  }
  util$3 = ret;
  return util$3;
}
var async = { exports: {} };
var schedule_1;
var hasRequiredSchedule;
function requireSchedule() {
  if (hasRequiredSchedule) return schedule_1;
  hasRequiredSchedule = 1;
  var util2 = requireUtil();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
  };
  var NativePromise = util2.getNativePromise();
  if (util2.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = commonjsGlobal.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util2.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(commonjsGlobal, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = function() {
      var div = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled) return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule2(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    }();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  schedule_1 = schedule;
  return schedule_1;
}
var queue;
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue;
  hasRequiredQueue = 1;
  function arrayMove(src2, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
      dst[j + dstIndex] = src2[j + srcIndex];
      src2[j + srcIndex] = void 0;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = void 0;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  queue = Queue;
  return queue;
}
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async.exports;
  hasRequiredAsync = 1;
  var firstLineError;
  try {
    throw new Error();
  } catch (e) {
    firstLineError = e;
  }
  var schedule = requireSchedule();
  var Queue = requireQueue();
  var util2 = requireUtil();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
  };
  Async.prototype.disableTrampolineIfNecessary = function() {
    if (util2.hasDevTools) {
      this._trampolineEnabled = false;
    }
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else try {
      this._schedule(function() {
        fn(arg);
      });
    } catch (e) {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise2) {
    this._normalQueue._pushOne(promise2);
    this._queueTick();
  }
  if (!util2.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
  } else {
    Async.prototype.invokeLater = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvokeLater.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          setTimeout(function() {
            fn.call(receiver, arg);
          }, 100);
        });
      }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvoke.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          fn.call(receiver, arg);
        });
      }
    };
    Async.prototype.settlePromises = function(promise2) {
      if (this._trampolineEnabled) {
        AsyncSettlePromises.call(this, promise2);
      } else {
        this._schedule(function() {
          promise2._settlePromises();
        });
      }
    };
  }
  Async.prototype._drainQueue = function(queue2) {
    while (queue2.length() > 0) {
      var fn = queue2.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
        continue;
      }
      var receiver = queue2.shift();
      var arg = queue2.shift();
      fn.call(receiver, arg);
    }
  };
  Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  async.exports = Async;
  async.exports.firstLineError = firstLineError;
  return async.exports;
}
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  var es52 = requireEs5();
  var Objectfreeze = es52.freeze;
  var util2 = requireUtil();
  var inherits2 = util2.inherits;
  var notEnumerableProp = util2.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError)) return new SubError(message);
      notEnumerableProp(
        this,
        "message",
        typeof message === "string" ? message : defaultMessage
      );
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits2(SubError, Error);
    return SubError;
  }
  var _TypeError, _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
  for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  es52.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError.prototype["isOperational"] = true;
  var level = 0;
  AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0; i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split("\n");
      for (var j = 0; j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join("\n");
      ret += str + "\n";
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits2(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError
    });
    es52.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  errors = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
  return errors;
}
var thenables;
var hasRequiredThenables;
function requireThenables() {
  if (hasRequiredThenables) return thenables;
  hasRequiredThenables = 1;
  thenables = function(Promise2, INTERNAL) {
    var util2 = requireUtil();
    var errorObj = util2.errorObj;
    var isObject2 = util2.isObject;
    function tryConvertToPromise(obj, context2) {
      if (isObject2(obj)) {
        if (obj instanceof Promise2) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
          if (context2) context2._pushContext();
          var ret = Promise2.reject(then.e);
          if (context2) context2._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise2(INTERNAL);
            obj._then(
              ret._fulfill,
              ret._reject,
              void 0,
              ret,
              null
            );
            return ret;
          }
          return doThenable(obj, then, context2);
        }
      }
      return obj;
    }
    function doGetThen(obj) {
      return obj.then;
    }
    function getThen(obj) {
      try {
        return doGetThen(obj);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
      try {
        return hasProp.call(obj, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context2) {
      var promise2 = new Promise2(INTERNAL);
      var ret = promise2;
      if (context2) context2._pushContext();
      promise2._captureStackTrace();
      if (context2) context2._popContext();
      var synchronous = true;
      var result = util2.tryCatch(then).call(x, resolve2, reject2);
      synchronous = false;
      if (promise2 && result === errorObj) {
        promise2._rejectCallback(result.e, true, true);
        promise2 = null;
      }
      function resolve2(value) {
        if (!promise2) return;
        promise2._resolveCallback(value);
        promise2 = null;
      }
      function reject2(reason) {
        if (!promise2) return;
        promise2._rejectCallback(reason, synchronous, true);
        promise2 = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
  return thenables;
}
var promise_array;
var hasRequiredPromise_array;
function requirePromise_array() {
  if (hasRequiredPromise_array) return promise_array;
  hasRequiredPromise_array = 1;
  promise_array = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util2 = requireUtil();
    util2.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function PromiseArray(values) {
      var promise2 = this._promise = new Promise2(INTERNAL);
      if (values instanceof Promise2) {
        promise2._propagateFrom(values, 3);
      }
      promise2._setOnCancel(this);
      this._values = values;
      this._length = 0;
      this._totalResolved = 0;
      this._init(void 0, -2);
    }
    util2.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_2, resolveValueIfEmpty) {
      var values = tryConvertToPromise(this._values, this._promise);
      if (values instanceof Promise2) {
        values = values._target();
        var bitField = values._bitField;
        this._values = values;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values._then(
            init,
            this._reject,
            void 0,
            this,
            resolveValueIfEmpty
          );
        } else if ((bitField & 33554432) !== 0) {
          values = values._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values._reason());
        } else {
          return this._cancel();
        }
      }
      values = util2.asArray(values);
      if (values === null) {
        var err2 = apiRejection(
          "expecting an array or an iterable object but got " + util2.classString(values)
        ).reason();
        this._promise._rejectCallback(err2, false);
        return;
      }
      if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values);
    };
    PromiseArray.prototype._iterate = function(values) {
      var len = this.getActualLength(values.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved) result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable()) return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index2) {
      this._values[index2] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved()) return;
      var values = this._values;
      this._cancel();
      if (values instanceof Promise2) {
        values.cancel();
      } else {
        for (var i = 0; i < values.length; ++i) {
          if (values[i] instanceof Promise2) {
            values[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
  return promise_array;
}
var context;
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  context = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {
    };
    Promise2.prototype._pushContext = function() {
    };
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {
    };
    function Context() {
      this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (this._trace !== void 0) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces) return new Context();
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return void 0;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function() {
    };
    Context.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context.prototype._pushContext;
      Promise2.prototype._popContext = Context.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
      };
    };
    return Context;
  };
  return context;
}
var debuggability;
var hasRequiredDebuggability;
function requireDebuggability() {
  if (hasRequiredDebuggability) return debuggability;
  hasRequiredDebuggability = 1;
  debuggability = function(Promise2, Context) {
    var getDomain = Promise2._getDomain;
    var async2 = Promise2._async;
    var Warning = requireErrors().Warning;
    var util2 = requireUtil();
    var canAttachTrace = util2.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util2.env("BLUEBIRD_DEBUG") != 0 && (util2.env("BLUEBIRD_DEBUG") || util2.env("NODE_ENV") === "development"));
    var warnings = !!(util2.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util2.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util2.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util2.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util2.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util2.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & -1048577 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0) return;
      this._setRejectionIsUnhandled();
      async2.invokeLater(this._notifyUnhandledRejection, this, void 0);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent(
        "rejectionHandled",
        unhandledRejectionHandled,
        void 0,
        this
      );
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent(
          "unhandledRejection",
          possiblyUnhandledRejection,
          reason,
          this
        );
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise2) {
      return warn(message, shouldUseOwnTrace, promise2 || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var domain = getDomain();
      possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var domain = getDomain();
      unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    var disableLongStackTraces = function() {
    };
    Promise2.longStackTraces = function() {
      if (async2.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async2.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Context.deactivateLongStackTraces();
          async2.enableTrampoline();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async2.disableTrampolineIfNecessary();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var fireDomEvent = function() {
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new CustomEvent(name.toLowerCase(), {
              detail: event2,
              cancelable: true
            });
            return !util2.global.dispatchEvent(domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new Event(name.toLowerCase(), {
              cancelable: true
            });
            domEvent.detail = event2;
            return !util2.global.dispatchEvent(domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(
              name.toLowerCase(),
              false,
              true,
              event2
            );
            return !util2.global.dispatchEvent(domEvent);
          };
        }
      } catch (e) {
      }
      return function() {
        return false;
      };
    }();
    var fireGlobalEvent = function() {
      if (util2.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util2.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method2 = util2.global[methodName];
          if (!method2) return false;
          method2.apply(util2.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    }();
    function generatePromiseLifecycleEventObject(name, promise2) {
      return { promise: promise2 };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise2, child) {
        return { promise: promise2, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise2) {
        return { reason, promise: promise2 };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async2.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(
          name,
          eventToObjectGenerator[name].apply(null, arguments)
        );
      } catch (e) {
        async2.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util2.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async2.haveItemsQueued()) {
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve2, reject2) {
      try {
        executor(resolve2, reject2);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {
    };
    Promise2.prototype._setOnCancel = function(handler) {
    };
    Promise2.prototype._attachCancellationCallback = function(onCancel) {
    };
    Promise2.prototype._captureStackTrace = function() {
    };
    Promise2.prototype._attachExtraTrace = function() {
    };
    Promise2.prototype._clearCancellationData = function() {
    };
    Promise2.prototype._propagateFrom = function(parent2, flags) {
    };
    function cancellationExecute(executor, resolve2, reject2) {
      var promise2 = this;
      try {
        executor(resolve2, reject2, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util2.toString(onCancel));
          }
          promise2._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable()) return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== void 0) {
        if (util2.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = void 0;
      this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent2, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent2;
        var branchesRemainingToCancel = parent2._branchesRemainingToCancel;
        if (branchesRemainingToCancel === void 0) {
          branchesRemainingToCancel = 0;
        }
        parent2._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent2._isBound()) {
        this._setBoundTo(parent2._boundTo);
      }
    }
    function bindingPropagateFrom(parent2, flags) {
      if ((flags & 2) !== 0 && parent2._isBound()) {
        this._setBoundTo(parent2._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== void 0) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return void 0;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error2, ignoreSelf) {
      if (canAttachTrace(error2)) {
        var trace = this._trace;
        if (trace !== void 0) {
          if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== void 0) {
          trace.attachExtraTrace(error2);
        } else if (!error2.__stackCleaned__) {
          var parsed = parseStackAndMessage(error2);
          util2.notEnumerableProp(
            error2,
            "stack",
            parsed.message + "\n" + parsed.stack.join("\n")
          );
          util2.notEnumerableProp(error2, "__stackCleaned__", true);
        }
      }
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise2, parent2) {
      if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
        if (parent2 !== void 0 && parent2._returnedNonUndefined()) return;
        if ((promise2._bitField & 65535) === 0) return;
        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split("\n");
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1; i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0; i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = "\n" + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg2 = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
        promise2._warn(msg2, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      if (replacement) message += " Use " + replacement + " instead.";
      return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise2) {
      if (!config.warnings) return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise2._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
      }
      return message + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1; j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint; j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error2) {
      var stack = error2.stack.replace(/\s+$/g, "").split("\n");
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error2.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error2) {
      var stack = error2.stack;
      var message = error2.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error2) : ["    (No stack trace)"];
      return {
        message,
        stack: error2.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error2, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util2.isObject(error2)) {
          var stack = error2.stack;
          message = title + formatStack(stack, error2);
        } else {
          message = title + String(error2);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise2) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise2);
          } else {
            localHandler(reason, promise2);
          }
        }
      } catch (e) {
        async2.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise2) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise2);
      }
    }
    function formatNonError(obj) {
      var str;
      if (typeof obj === "function") {
        str = "[function " + (obj.name || "anonymous") + "]";
      } else {
        str = obj && typeof obj.toString === "function" ? obj.toString() : util2.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj);
            str = newStr;
          } catch (e) {
          }
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported()) return;
      var firstStackLines = firstLineError.stack.split("\n");
      var lastStackLines = lastLineError.stack.split("\n");
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent2) {
      this._parent = parent2;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent2 === void 0 ? 0 : parent2._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32) this.uncycle();
    }
    util2.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2) return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node2 = this; node2 !== void 0; ++i) {
        nodes.push(node2);
        node2 = node2._parent;
      }
      length = this._length = i;
      for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === void 0) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index2 = stackToIndex[currentStack];
        if (index2 !== void 0 && index2 !== i) {
          if (index2 > 0) {
            nodes[index2 - 1]._parent = void 0;
            nodes[index2 - 1]._length = 1;
          }
          nodes[i]._parent = void 0;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index2 < length - 1) {
            cycleEdgeNode._parent = nodes[index2 + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = void 0;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2; j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error2) {
      if (error2.__stackCleaned__) return;
      this.uncycle();
      var parsed = parseStackAndMessage(error2);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== void 0) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util2.notEnumerableProp(error2, "stack", reconstructStack(message, stacks));
      util2.notEnumerableProp(error2, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error2) {
        if (typeof stack === "string") return stack;
        if (error2.name !== void 0 && error2.message !== void 0) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err2 = new Error();
      if (typeof err2.stack === "string" && err2.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace3(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error();
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err2) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace3(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error();
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error2) {
        if (typeof stack === "string") return stack;
        if ((typeof error2 === "object" || typeof error2 === "function") && error2.name !== void 0 && error2.message !== void 0) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      return null;
    }();
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util2.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message + "\x1B[0m\n");
        };
      } else if (!util2.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn(
            "%c" + message,
            isSoft ? "color: darkorange" : "color: red"
          );
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false
    };
    if (longStackTraces) Promise2.longStackTraces();
    return {
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
  return debuggability;
}
var _finally;
var hasRequired_finally;
function require_finally() {
  if (hasRequired_finally) return _finally;
  hasRequired_finally = 1;
  _finally = function(Promise2, tryConvertToPromise) {
    var util2 = requireUtil();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util2.errorObj;
    function PassThroughHandlerContext(promise2, type, handler) {
      this.promise = promise2;
      this.type = type;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason)) return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise2 = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise2._boundValue()) : handler.call(promise2._boundValue(), reasonOrValue);
        if (ret !== void 0) {
          promise2._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise2);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise2._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(
                  new FinallyHandlerCancelReaction(this)
                );
              }
            }
            return maybePromise._then(
              succeed,
              fail,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      if (promise2.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type, success, fail2) {
      if (typeof handler !== "function") return this.then();
      return this._then(
        success,
        fail2,
        void 0,
        new PassThroughHandlerContext(this, type, handler),
        void 0
      );
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(
        handler,
        0,
        finallyHandler,
        finallyHandler
      );
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    return PassThroughHandlerContext;
  };
  return _finally;
}
var catch_filter;
var hasRequiredCatch_filter;
function requireCatch_filter() {
  if (hasRequiredCatch_filter) return catch_filter;
  hasRequiredCatch_filter = 1;
  catch_filter = function(NEXT_FILTER) {
    var util2 = requireUtil();
    var getKeys = requireEs5().keys;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function catchFilter(instances, cb, promise2) {
      return function(e) {
        var boundTo = promise2._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
          var item = instances[i];
          if (item === Error || item != null && item.prototype instanceof Error) {
            if (e instanceof item) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (typeof item === "function") {
            var matchesPredicate = tryCatch(item).call(boundTo, e);
            if (matchesPredicate === errorObj) {
              return matchesPredicate;
            } else if (matchesPredicate) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (util2.isObject(e)) {
            var keys = getKeys(item);
            for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              if (item[key] != e[key]) {
                continue predicateLoop;
              }
            }
            return tryCatch(cb).call(boundTo, e);
          }
        }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
  return catch_filter;
}
var nodeback;
var hasRequiredNodeback;
function requireNodeback() {
  if (hasRequiredNodeback) return nodeback;
  hasRequiredNodeback = 1;
  var util2 = requireUtil();
  var maybeWrapAsError = util2.maybeWrapAsError;
  var errors2 = requireErrors();
  var OperationalError = errors2.OperationalError;
  var es52 = requireEs5();
  function isUntypedError(obj) {
    return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
      ret = new OperationalError(obj);
      ret.name = obj.name;
      ret.message = obj.message;
      ret.stack = obj.stack;
      var keys = es52.keys(obj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    util2.markAsOriginatingFromRejection(obj);
    return obj;
  }
  function nodebackForPromise(promise2, multiArgs) {
    return function(err2, value) {
      if (promise2 === null) return;
      if (err2) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err2));
        promise2._attachExtraTrace(wrapped);
        promise2._reject(wrapped);
      } else if (!multiArgs) {
        promise2._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise2._fulfill(args);
      }
      promise2 = null;
    };
  }
  nodeback = nodebackForPromise;
  return nodeback;
}
var method;
var hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  hasRequiredMethod = 1;
  method = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug2) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util2.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug2.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.method",
          ret
        );
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug2.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util2.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug2.checkForgottenReturns(
        value,
        promiseCreated,
        "Promise.try",
        ret
      );
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util2.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
  return method;
}
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = function(Promise2, INTERNAL, tryConvertToPromise, debug2) {
    var calledBind = false;
    var rejectThis = function(_2, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context2) {
      context2.promiseRejectionQueued = true;
      context2.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context2) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context2.target);
      }
    };
    var bindingRejected = function(e, context2) {
      if (!context2.promiseRejectionQueued) this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug2.propagateFromFunction();
        Promise2.prototype._boundValue = debug2.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context2 = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, void 0, ret, context2);
        maybePromise._then(
          bindingResolved,
          bindingRejected,
          void 0,
          ret,
          context2
        );
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj) {
      if (obj !== void 0) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
      } else {
        this._bitField = this._bitField & -2097153;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
  return bind;
}
var cancel;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel) return cancel;
  hasRequiredCancel = 1;
  cancel = function(Promise2, PromiseArray, apiRejection, debug2) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug2.cancellation()) return this._warn("cancellation is disabled");
      var promise2 = this;
      var child = promise2;
      while (promise2._isCancellable()) {
        if (!promise2._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent2 = promise2._cancellationParent;
        if (parent2 == null || !parent2._isCancellable()) {
          if (promise2._isFollowing()) {
            promise2._followee().cancel();
          } else {
            promise2._cancelBranched();
          }
          break;
        } else {
          if (promise2._isFollowing()) promise2._followee().cancel();
          promise2._setWillBeCancelled();
          child = promise2;
          promise2 = parent2;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable()) return;
      this._setCancelled();
      async2.invoke(this._cancelPromises, this, void 0);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0) this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util2.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== void 0) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async2.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async2.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
  return cancel;
}
var direct_resolve;
var hasRequiredDirect_resolve;
function requireDirect_resolve() {
  if (hasRequiredDirect_resolve) return direct_resolve;
  hasRequiredDirect_resolve = 1;
  direct_resolve = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2) value.suppressUnhandledRejections();
      return this._then(
        returner,
        void 0,
        void 0,
        { value },
        void 0
      );
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(
        thrower,
        void 0,
        void 0,
        { reason },
        void 0
      );
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(
          void 0,
          thrower,
          void 0,
          { reason },
          void 0
        );
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2) value.suppressUnhandledRejections();
        return this._then(
          void 0,
          returner,
          void 0,
          { value },
          void 0
        );
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2) _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
  return direct_resolve;
}
var synchronous_inspection;
var hasRequiredSynchronous_inspection;
function requireSynchronous_inspection() {
  if (hasRequiredSynchronous_inspection) return synchronous_inspection;
  hasRequiredSynchronous_inspection = 1;
  synchronous_inspection = function(Promise2) {
    function PromiseInspection(promise2) {
      if (promise2 !== void 0) {
        promise2 = promise2._target();
        this._bitField = promise2._bitField;
        this._settledValueField = promise2._isFateSealed() ? promise2._settledValue() : void 0;
      } else {
        this._bitField = 0;
        this._settledValueField = void 0;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
  return synchronous_inspection;
}
var join;
var hasRequiredJoin;
function requireJoin() {
  if (hasRequiredJoin) return join;
  hasRequiredJoin = 1;
  join = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async2, getDomain) {
    var util2 = requireUtil();
    var canEvaluate = util2.canEvaluate;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var reject2;
    {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", "                             \n	            'use strict';                                                    \n	            holder.pIndex = value;                                           \n	            holder.checkFulfillment(this);                                   \n	            ".replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", "                           \n	            'use strict';                                                    \n	            holder.pIndex = promise;                                         \n	            ".replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props2 = new Array(total);
          for (var i2 = 0; i2 < props2.length; ++i2) {
            props2[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props2.join(" = ") + " = null;";
          var cancellationCode = "var promise;\n" + props2.map(function(prop) {
            return "                                                         \n	                promise = " + prop + ";                                      \n	                if (promise instanceof Promise) {                            \n	                    promise.cancel();                                        \n	                }                                                            \n	            ";
          }).join("\n");
          var passedArguments = props2.join(", ");
          var name = "Holder$" + total;
          var code = "return function(tryCatch, errorObj, Promise, async) {    \n	            'use strict';                                                    \n	            function [TheName](fn) {                                         \n	                [TheProperties]                                              \n	                this.fn = fn;                                                \n	                this.asyncNeeded = true;                                     \n	                this.now = 0;                                                \n	            }                                                                \n	                                                                             \n	            [TheName].prototype._callFunction = function(promise) {          \n	                promise._pushContext();                                      \n	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n	                promise._popContext();                                       \n	                if (ret === errorObj) {                                      \n	                    promise._rejectCallback(ret.e, false);                   \n	                } else {                                                     \n	                    promise._resolveCallback(ret);                           \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype.checkFulfillment = function(promise) {       \n	                var now = ++this.now;                                        \n	                if (now === [TheTotal]) {                                    \n	                    if (this.asyncNeeded) {                                  \n	                        async.invoke(this._callFunction, this, promise);     \n	                    } else {                                                 \n	                        this._callFunction(promise);                         \n	                    }                                                        \n	                                                                             \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype._resultCancelled = function() {              \n	                [CancellationCode]                                           \n	            };                                                               \n	                                                                             \n	            return [TheName];                                                \n	        }(tryCatch, errorObj, Promise, async);                               \n	        ";
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async2);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0; i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject2 = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        {
          if (last <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0; i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(
                    callbacks[i2],
                    reject2,
                    void 0,
                    ret,
                    holder
                  );
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(
                    ret,
                    maybePromise._value(),
                    holder
                  );
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var domain = getDomain();
                if (domain !== null) {
                  holder.fn = util2.domainBind(domain, holder.fn);
                }
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0; $_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn) args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== void 0 ? ret.spread(fn) : ret;
    };
  };
  return join;
}
var map2;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map2;
  hasRequiredMap = 1;
  map2 = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    function MappingPromiseArray(promises, fn, limit, _filter2) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var domain = getDomain();
      this._callback = domain === null ? fn : util2.domainBind(domain, fn);
      this._preservedValues = _filter2 === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = [];
      async2.invoke(this._asyncInit, this, void 0);
    }
    util2.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    };
    MappingPromiseArray.prototype._init = function() {
    };
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      var values = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (index2 < 0) {
        index2 = index2 * -1 - 1;
        values[index2] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved()) return true;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values[index2] = value;
          this._queue.push(index2);
          return false;
        }
        if (preservedValues !== null) preservedValues[index2] = value;
        var promise2 = this._promise;
        var callback = this._callback;
        var receiver = promise2._boundValue();
        promise2._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index2, length);
        var promiseCreated = promise2._popContext();
        debug2.checkForgottenReturns(
          ret,
          promiseCreated,
          preservedValues !== null ? "Promise.filter" : "Promise.map",
          promise2
        );
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit >= 1) this._inFlight++;
            values[index2] = maybePromise;
            maybePromise._proxy(this, (index2 + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values[index2] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values, preservedValues);
        } else {
          this._resolve(values);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue2 = this._queue;
      var limit = this._limit;
      var values = this._values;
      while (queue2.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index2 = queue2.pop();
        this._promiseFulfilled(values[index2], index2);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
      var len = values.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map3(promises, fn, options, _filter2) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var limit = 0;
      if (options !== void 0) {
        if (typeof options === "object" && options !== null) {
          if (typeof options.concurrency !== "number") {
            return Promise2.reject(
              new TypeError("'concurrency' must be a number but it is " + util2.classString(options.concurrency))
            );
          }
          limit = options.concurrency;
        } else {
          return Promise2.reject(new TypeError(
            "options argument must be an object but it is " + util2.classString(options)
          ));
        }
      }
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises, fn, limit, _filter2).promise();
    }
    Promise2.prototype.map = function(fn, options) {
      return map3(this, fn, options, null);
    };
    Promise2.map = function(promises, fn, options, _filter2) {
      return map3(promises, fn, options, _filter2);
    };
  };
  return map2;
}
var call_get;
var hasRequiredCall_get;
function requireCall_get() {
  if (hasRequiredCall_get) return call_get;
  hasRequiredCall_get = 1;
  var cr = Object.create;
  if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  call_get = function(Promise2) {
    var util2 = requireUtil();
    var canEvaluate = util2.canEvaluate;
    var isIdentifier = util2.isIdentifier;
    var getMethodCaller;
    var getGetter;
    {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", "                                    \n	        return function(obj) {                                               \n	            'use strict'                                                     \n	            var len = this.length;                                           \n	            ensureMethod(obj, 'methodName');                                 \n	            switch(len) {                                                    \n	                case 1: return obj.methodName(this[0]);                      \n	                case 2: return obj.methodName(this[0], this[1]);             \n	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n	                case 0: return obj.methodName();                             \n	                default:                                                     \n	                    return obj.methodName.apply(obj, this);                  \n	            }                                                                \n	        };                                                                   \n	        ".replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", "                                             \n	        'use strict';                                                        \n	        return obj.propertyName;                                             \n	        ".replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj, methodName) {
      var fn;
      if (obj != null) fn = obj[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util2.classString(obj) + " has no method '" + util2.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj) {
      var methodName = this.pop();
      var fn = ensureMethod(obj, methodName);
      return fn.apply(obj, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1; $_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(
              maybeCaller,
              void 0,
              void 0,
              args,
              void 0
            );
          }
        }
      }
      args.push(methodName);
      return this._then(caller, void 0, void 0, args, void 0);
    };
    function namedGetter(obj) {
      return obj[this];
    }
    function indexedGetter(obj) {
      var index2 = +this;
      if (index2 < 0) index2 = Math.max(0, index2 + obj.length);
      return obj[index2];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex2 = typeof propertyName === "number";
      var getter;
      if (!isIndex2) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, void 0, void 0, propertyName, void 0);
    };
  };
  return call_get;
}
var using;
var hasRequiredUsing;
function requireUsing() {
  if (hasRequiredUsing) return using;
  hasRequiredUsing = 1;
  using = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2) {
    var util2 = requireUtil();
    var TypeError2 = requireErrors().TypeError;
    var inherits2 = requireUtil().inherits;
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var NULL = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL);
      function iterator() {
        if (i >= len) return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(
              maybePromise._getDisposer().tryDispose(inspection),
              resources.promise
            );
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(
              iterator,
              thrower,
              null,
              null,
              null
            );
          }
        }
        iterator();
      }
      iterator();
      return ret;
    }
    function Disposer(data, promise2, context2) {
      this._data = data;
      this._promise = promise2;
      this._context = context2;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context2 = this._context;
      if (context2 !== void 0) context2._pushContext();
      var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
      if (context2 !== void 0) context2._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise2, context2) {
      this.constructor$(fn, promise2, context2);
    }
    inherits2(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2) return apiRejection(
        "you must pass at least 2 arguments to Promise.using"
      );
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0; i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, void 0);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0; i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0; i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise2._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
        var promiseCreated = promise2._popContext();
        debug2.checkForgottenReturns(
          ret,
          promiseCreated,
          "Promise.using",
          promise2
        );
        return ret;
      });
      var promise2 = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise2;
      promise2._setOnCancel(resources);
      return promise2;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073;
      this._disposer = void 0;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2();
    };
  };
  return using;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  timers = function(Promise2, INTERNAL, debug2) {
    var util2 = requireUtil();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(ms, value) {
      var ret;
      var handle;
      if (value !== void 0) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
        if (debug2.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL);
        handle = setTimeout(function() {
          ret._fulfill();
        }, +ms);
        if (debug2.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms) {
      return delay(ms, this);
    };
    var afterTimeout = function(promise2, message, parent2) {
      var err2;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err2 = message;
        } else {
          err2 = new TimeoutError("operation timed out");
        }
      } else {
        err2 = new TimeoutError(message);
      }
      util2.markAsOriginatingFromRejection(err2);
      promise2._attachExtraTrace(err2);
      promise2._reject(err2);
      if (parent2 != null) {
        parent2.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message) {
      ms = +ms;
      var ret, parent2;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message, parent2);
        }
      }, ms));
      if (debug2.cancellation()) {
        parent2 = this.then();
        ret = parent2._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
      }
      return ret;
    };
  };
  return timers;
}
var generators;
var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  generators = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2) {
    var errors2 = requireErrors();
    var TypeError2 = errors2.TypeError;
    var util2 = requireUtil();
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0; i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2) return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug2.cancellation()) {
        var internal = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise2 = this._promise = new Promise2(INTERNAL);
        promise2._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = void 0;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util2.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug2.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved()) return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError(
          "generator .return() sentinel"
        );
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(
          this._generator,
          reason
        );
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(
          this._generator,
          void 0
        );
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise2 = this._yieldedPromise;
        this._yieldedPromise = null;
        promise2.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = void 0;
      this._promiseFulfilled(void 0);
    };
    PromiseSpawn.prototype._continue = function(result) {
      var promise2 = this._promise;
      if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._rejectCallback(result.e, false);
        }
      }
      var value = result.value;
      if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(
            maybePromise,
            this._yieldHandlers,
            this._promise
          );
          if (maybePromise === null) {
            this._promiseRejected(
              new TypeError2(
                "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
              )
            );
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(
            this._promiseFulfilled,
            this,
            maybePromise._value()
          );
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(
            this._promiseRejected,
            this,
            maybePromise._reason()
          );
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(
          void 0,
          void 0,
          yieldHandler,
          stack
        );
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(void 0);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug2.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
  return generators;
}
var nodeify;
var hasRequiredNodeify;
function requireNodeify() {
  if (hasRequiredNodeify) return nodeify;
  hasRequiredNodeify = 1;
  nodeify = function(Promise2) {
    var util2 = requireUtil();
    var async2 = Promise2._async;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function spreadAdapter(val, nodeback2) {
      var promise2 = this;
      if (!util2.isArray(val)) return successAdapter.call(promise2, val, nodeback2);
      var ret = tryCatch(nodeback2).apply(promise2._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback2) {
      var promise2 = this;
      var receiver = promise2._boundValue();
      var ret = val === void 0 ? tryCatch(nodeback2).call(receiver, null) : tryCatch(nodeback2).call(receiver, null, val);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback2) {
      var promise2 = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback2).call(promise2._boundValue(), reason);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback2, options) {
      if (typeof nodeback2 == "function") {
        var adapter = successAdapter;
        if (options !== void 0 && Object(options).spread) {
          adapter = spreadAdapter;
        }
        this._then(
          adapter,
          errorAdapter,
          void 0,
          this,
          nodeback2
        );
      }
      return this;
    };
  };
  return nodeify;
}
var promisify;
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify;
  hasRequiredPromisify = 1;
  promisify = function(Promise2, INTERNAL) {
    var THIS = {};
    var util2 = requireUtil();
    var nodebackForPromise = requireNodeback();
    var withAppended = util2.withAppended;
    var maybeWrapAsError = util2.maybeWrapAsError;
    var canEvaluate = util2.canEvaluate;
    var TypeError2 = requireErrors().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util2.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj, key, suffix) {
      var val = util2.getDataPropertyOrDefault(
        obj,
        key + suffix,
        defaultPromisified
      );
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0; j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter2) {
      var keys = util2.inheritedDataKeys(obj);
      var ret = [];
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter2(key, value, obj, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1; i >= min; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util2.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util2.filledRange(
          Math.max(parameterCount2, 3),
          "_arg",
          ""
        );
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _2, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
          } else {
            ret = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += "                                                             \n	        default:                                                             \n	            var args = new Array(len + 1);                                   \n	            var i = 0;                                                       \n	            for (var i = 0; i < len; ++i) {                                  \n	               args[i] = arguments[i];                                       \n	            }                                                                \n	            args[i] = nodeback;                                              \n	            [CodeForCall]                                                    \n	            break;                                                           \n	        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = "'use strict';                                                \n	        var ret = function (Parameters) {                                    \n	            'use strict';                                                    \n	            var len = arguments.length;                                      \n	            var promise = new Promise(INTERNAL);                             \n	            promise._captureStackTrace();                                    \n	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n	            var ret;                                                         \n	            var callback = tryCatch([GetFunctionCode]);                      \n	            switch(len) {                                                    \n	                [CodeForSwitchCase]                                          \n	            }                                                                \n	            if (ret === errorObj) {                                          \n	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n	            }                                                                \n	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n	            return promise;                                                  \n	        };                                                                   \n	        notEnumerableProp(ret, '__isPromisified__', true);                   \n	        return ret;                                                          \n	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          body
        )(
          Promise2,
          fn,
          receiver,
          withAppended,
          maybeWrapAsError,
          nodebackForPromise,
          util2.tryCatch,
          util2.errorObj,
          util2.notEnumerableProp,
          INTERNAL
        );
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _2, fn, __, multiArgs) {
      var defaultThis = /* @__PURE__ */ function() {
        return this;
      }();
      var method2 = callback;
      if (typeof method2 === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise2 = new Promise2(INTERNAL);
        promise2._captureStackTrace();
        var cb = typeof method2 === "string" && this !== defaultThis ? this[method2] : callback;
        var fn2 = nodebackForPromise(promise2, multiArgs);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise2._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise2._isFateSealed()) promise2._setAsyncGuaranteed();
        return promise2;
      }
      util2.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter2, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter2);
      for (var i = 0, len = methods.length; i < len; i += 2) {
        var key = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(
              key,
              THIS,
              key,
              fn,
              suffix,
              multiArgs
            );
          });
          util2.notEnumerableProp(promisified, "__isPromisified__", true);
          obj[promisifiedKey] = promisified;
        }
      }
      util2.toFastProperties(obj);
      return obj;
    }
    function promisify2(callback, receiver, multiArgs) {
      return makeNodePromisified(
        callback,
        receiver,
        void 0,
        callback,
        null,
        multiArgs
      );
    }
    Promise2.promisify = function(fn, options) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options = Object(options);
      var receiver = options.context === void 0 ? THIS : options.context;
      var multiArgs = !!options.multiArgs;
      var ret = promisify2(fn, receiver, multiArgs);
      util2.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      options = Object(options);
      var multiArgs = !!options.multiArgs;
      var suffix = options.suffix;
      if (typeof suffix !== "string") suffix = defaultSuffix;
      var filter2 = options.filter;
      if (typeof filter2 !== "function") filter2 = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function") promisifier = makeNodePromisified;
      if (!util2.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
      }
      var keys = util2.inheritedDataKeys(target);
      for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util2.isClass(value)) {
          promisifyAll(
            value.prototype,
            suffix,
            filter2,
            promisifier,
            multiArgs
          );
          promisifyAll(value, suffix, filter2, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter2, promisifier, multiArgs);
    };
  };
  return promisify;
}
var props;
var hasRequiredProps;
function requireProps() {
  if (hasRequiredProps) return props;
  hasRequiredProps = 1;
  props = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil();
    var isObject2 = util2.isObject;
    var es52 = requireEs5();
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;
    var mapToEntries = /* @__PURE__ */ function() {
      var index2 = 0;
      var size = 0;
      function extractEntry(value, key) {
        this[index2] = value;
        this[index2 + size] = key;
        index2++;
      }
      return function mapToEntries2(map3) {
        size = map3.size;
        index2 = 0;
        var ret = new Array(map3.size * 2);
        map3.forEach(extractEntry, ret);
        return ret;
      };
    }();
    var entriesToMap = function(entries) {
      var ret = new Es6Map();
      var length = entries.length / 2 | 0;
      for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj) {
      var isMap = false;
      var entries;
      if (Es6Map !== void 0 && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
      } else {
        var keys = es52.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
          var key = keys[i];
          entries[i] = obj[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(void 0, -3);
    }
    util2.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      this._values[index2] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props2(promises) {
      var ret;
      var castValue = tryConvertToPromise(promises);
      if (!isObject2(castValue)) {
        return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(
          Promise2.props,
          void 0,
          void 0,
          void 0,
          void 0
        );
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props2(this);
    };
    Promise2.props = function(promises) {
      return props2(promises);
    };
  };
  return props;
}
var race;
var hasRequiredRace;
function requireRace() {
  if (hasRequiredRace) return race;
  hasRequiredRace = 1;
  race = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil();
    var raceLater = function(promise2) {
      return promise2.then(function(array) {
        return race2(array, promise2);
      });
    };
    function race2(promises, parent2) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises = util2.asArray(promises);
        if (promises === null)
          return apiRejection("expecting an array or an iterable object but got " + util2.classString(promises));
      }
      var ret = new Promise2(INTERNAL);
      if (parent2 !== void 0) {
        ret._propagateFrom(parent2, 3);
      }
      var fulfill = ret._fulfill;
      var reject2 = ret._reject;
      for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];
        if (val === void 0 && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject2, void 0, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises) {
      return race2(promises, void 0);
    };
    Promise2.prototype.race = function() {
      return race2(this, void 0);
    };
  };
  return race;
}
var reduce;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce;
  hasRequiredReduce = 1;
  reduce = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
      this.constructor$(promises);
      var domain = getDomain();
      this._fn = domain === null ? fn : util2.domainBind(domain, fn);
      if (initialValue !== void 0) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = void 0;
      }
      this._promise._captureStackTrace();
      this._init$(void 0, -5);
    }
    util2.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {
    };
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue) return this._cancel();
      if (this._isResolved()) return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values) {
      this._values = values;
      var value;
      var i;
      var length = values.length;
      if (this._initialValue !== void 0) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values[0]);
        i = 1;
      }
      this._currentCancellable = value;
      if (!value.isRejected()) {
        for (; i < length; ++i) {
          var ctx = {
            accum: null,
            value: values[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, void 0, void 0, ctx, void 0);
        }
      }
      if (this._eachValues !== void 0) {
        value = value._then(this._eachComplete, void 0, void 0, this, void 0);
      }
      value._then(completed, completed, void 0, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce2(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce2(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce2(promises, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, void 0, void 0, this, void 0);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise2 = array._promise;
      var fn = tryCatch(array._fn);
      promise2._pushContext();
      var ret;
      if (array._eachValues !== void 0) {
        ret = fn.call(promise2._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(
          promise2._boundValue(),
          this.accum,
          value,
          this.index,
          this.length
        );
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise2._popContext();
      debug2.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        promise2
      );
      return ret;
    }
  };
  return reduce;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle) return settle;
  hasRequiredSettle = 1;
  settle = function(Promise2, PromiseArray, debug2) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util2 = requireUtil();
    function SettledPromiseArray(values) {
      this.constructor$(values);
    }
    util2.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index2, inspection) {
      this._values[index2] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      var ret = new PromiseInspection();
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index2, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index2) {
      var ret = new PromiseInspection();
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index2, ret);
    };
    Promise2.settle = function(promises) {
      debug2.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
  return settle;
}
var some2;
var hasRequiredSome;
function requireSome() {
  if (hasRequiredSome) return some2;
  hasRequiredSome = 1;
  some2 = function(Promise2, PromiseArray, apiRejection) {
    var util2 = requireUtil();
    var RangeError2 = requireErrors().RangeError;
    var AggregateError = requireErrors().AggregateError;
    var isArray2 = util2.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values) {
      this.constructor$(values);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util2.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(void 0, -5);
      var isArrayResolved = isArray2(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some3(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
      }
      var ret = new SomePromiseArray(promises);
      var promise2 = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise2;
    }
    Promise2.some = function(promises, howMany) {
      return some3(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some3(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
  return some2;
}
var filter;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter;
  hasRequiredFilter = 1;
  filter = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options) {
      return PromiseMap(promises, fn, options, INTERNAL);
    };
  };
  return filter;
}
var each2;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach) return each2;
  hasRequiredEach = 1;
  each2 = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
  return each2;
}
var any;
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any;
  hasRequiredAny = 1;
  any = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any2(promises) {
      var ret = new SomePromiseArray(promises);
      var promise2 = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise2;
    }
    Promise2.any = function(promises) {
      return any2(promises);
    };
    Promise2.prototype.any = function() {
      return any2(this);
    };
  };
  return any;
}
(function(module) {
  module.exports = function() {
    var makeSelfResolutionError = function() {
      return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
    };
    var reflectHandler = function() {
      return new Promise2.PromiseInspection(this._target());
    };
    var apiRejection = function(msg2) {
      return Promise2.reject(new TypeError2(msg2));
    };
    function Proxyable() {
    }
    var UNDEFINED_BINDING = {};
    var util2 = requireUtil();
    var getDomain;
    if (util2.isNode) {
      getDomain = function() {
        var ret = process.domain;
        if (ret === void 0) ret = null;
        return ret;
      };
    } else {
      getDomain = function() {
        return null;
      };
    }
    util2.notEnumerableProp(Promise2, "_getDomain", getDomain);
    var es52 = requireEs5();
    var Async = requireAsync();
    var async2 = new Async();
    es52.defineProperty(Promise2, "_async", { value: async2 });
    var errors2 = requireErrors();
    var TypeError2 = Promise2.TypeError = errors2.TypeError;
    Promise2.RangeError = errors2.RangeError;
    var CancellationError = Promise2.CancellationError = errors2.CancellationError;
    Promise2.TimeoutError = errors2.TimeoutError;
    Promise2.OperationalError = errors2.OperationalError;
    Promise2.RejectionError = errors2.OperationalError;
    Promise2.AggregateError = errors2.AggregateError;
    var INTERNAL = function() {
    };
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = requireThenables()(Promise2, INTERNAL);
    var PromiseArray = requirePromise_array()(
      Promise2,
      INTERNAL,
      tryConvertToPromise,
      apiRejection,
      Proxyable
    );
    var Context = requireContext()(Promise2);
    var createContext = Context.create;
    var debug2 = requireDebuggability()(Promise2, Context);
    debug2.CapturedTrace;
    var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
    var catchFilter = requireCatch_filter()(NEXT_FILTER);
    var nodebackForPromise = requireNodeback();
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    function check(self2, executor) {
      if (typeof executor !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(executor));
      }
      if (self2.constructor !== Promise2) {
        throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
      }
    }
    function Promise2(executor) {
      this._bitField = 0;
      this._fulfillmentHandler0 = void 0;
      this._rejectionHandler0 = void 0;
      this._promise0 = void 0;
      this._receiver0 = void 0;
      if (executor !== INTERNAL) {
        check(this, executor);
        this._resolveFromExecutor(executor);
      }
      this._promiseCreated();
      this._fireEvent("promiseCreated", this);
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
      var len = arguments.length;
      if (len > 1) {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0; i < len - 1; ++i) {
          var item = arguments[i];
          if (util2.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return apiRejection("expecting an object but got A catch statement predicate " + util2.classString(item));
          }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(void 0, catchFilter(catchInstances, fn, this));
      }
      return this.then(void 0, fn);
    };
    Promise2.prototype.reflect = function() {
      return this._then(
        reflectHandler,
        reflectHandler,
        void 0,
        this,
        void 0
      );
    };
    Promise2.prototype.then = function(didFulfill, didReject) {
      if (debug2.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
        var msg2 = ".then() only accepts functions but was passed: " + util2.classString(didFulfill);
        if (arguments.length > 1) {
          msg2 += ", " + util2.classString(didReject);
        }
        this._warn(msg2);
      }
      return this._then(didFulfill, didReject, void 0, void 0, void 0);
    };
    Promise2.prototype.done = function(didFulfill, didReject) {
      var promise2 = this._then(didFulfill, didReject, void 0, void 0, void 0);
      promise2._setIsFinal();
    };
    Promise2.prototype.spread = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      return this.all()._then(fn, void 0, void 0, APPLY, void 0);
    };
    Promise2.prototype.toJSON = function() {
      var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: void 0,
        rejectionReason: void 0
      };
      if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
      } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
      }
      return ret;
    };
    Promise2.prototype.all = function() {
      if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
      }
      return new PromiseArray(this).promise();
    };
    Promise2.prototype.error = function(fn) {
      return this.caught(util2.originatesFromRejection, fn);
    };
    Promise2.getNewLibraryCopy = module.exports;
    Promise2.is = function(val) {
      return val instanceof Promise2;
    };
    Promise2.fromNode = Promise2.fromCallback = function(fn) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
      var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
      if (result === errorObj) {
        ret._rejectCallback(result.e, true);
      }
      if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.all = function(promises) {
      return new PromiseArray(promises).promise();
    };
    Promise2.cast = function(obj) {
      var ret = tryConvertToPromise(obj);
      if (!(ret instanceof Promise2)) {
        ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
      }
      return ret;
    };
    Promise2.resolve = Promise2.fulfilled = Promise2.cast;
    Promise2.reject = Promise2.rejected = function(reason) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._rejectCallback(reason, true);
      return ret;
    };
    Promise2.setScheduler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      return async2.setScheduler(fn);
    };
    Promise2.prototype._then = function(didFulfill, didReject, _2, receiver, internalData) {
      var haveInternalData = internalData !== void 0;
      var promise2 = haveInternalData ? internalData : new Promise2(INTERNAL);
      var target = this._target();
      var bitField = target._bitField;
      if (!haveInternalData) {
        promise2._propagateFrom(this, 3);
        promise2._captureStackTrace();
        if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
          if (!((bitField & 50397184) === 0)) {
            receiver = this._boundValue();
          } else {
            receiver = target === this ? void 0 : this._boundTo;
          }
        }
        this._fireEvent("promiseChained", this, promise2);
      }
      var domain = getDomain();
      if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if ((bitField & 33554432) !== 0) {
          value = target._rejectionHandler0;
          handler = didFulfill;
        } else if ((bitField & 16777216) !== 0) {
          value = target._fulfillmentHandler0;
          handler = didReject;
          target._unsetRejectionIsUnhandled();
        } else {
          settler = target._settlePromiseLateCancellationObserver;
          value = new CancellationError("late cancellation observer");
          target._attachExtraTrace(value);
          handler = didReject;
        }
        async2.invoke(settler, target, {
          handler: domain === null ? handler : typeof handler === "function" && util2.domainBind(domain, handler),
          promise: promise2,
          receiver,
          value
        });
      } else {
        target._addCallbacks(didFulfill, didReject, promise2, receiver, domain);
      }
      return promise2;
    };
    Promise2.prototype._length = function() {
      return this._bitField & 65535;
    };
    Promise2.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    };
    Promise2.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    };
    Promise2.prototype._setLength = function(len) {
      this._bitField = this._bitField & -65536 | len & 65535;
    };
    Promise2.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432;
      this._fireEvent("promiseFulfilled", this);
    };
    Promise2.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216;
      this._fireEvent("promiseRejected", this);
    };
    Promise2.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864;
      this._fireEvent("promiseResolved", this);
    };
    Promise2.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    };
    Promise2.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    };
    Promise2.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & -65537;
    };
    Promise2.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536;
      this._fireEvent("promiseCancelled", this);
    };
    Promise2.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    };
    Promise2.prototype._setAsyncGuaranteed = function() {
      if (async2.hasCustomScheduler()) return;
      this._bitField = this._bitField | 134217728;
    };
    Promise2.prototype._receiverAt = function(index2) {
      var ret = index2 === 0 ? this._receiver0 : this[index2 * 4 - 4 + 3];
      if (ret === UNDEFINED_BINDING) {
        return void 0;
      } else if (ret === void 0 && this._isBound()) {
        return this._boundValue();
      }
      return ret;
    };
    Promise2.prototype._promiseAt = function(index2) {
      return this[index2 * 4 - 4 + 2];
    };
    Promise2.prototype._fulfillmentHandlerAt = function(index2) {
      return this[index2 * 4 - 4 + 0];
    };
    Promise2.prototype._rejectionHandlerAt = function(index2) {
      return this[index2 * 4 - 4 + 1];
    };
    Promise2.prototype._boundValue = function() {
    };
    Promise2.prototype._migrateCallback0 = function(follower) {
      follower._bitField;
      var fulfill = follower._fulfillmentHandler0;
      var reject2 = follower._rejectionHandler0;
      var promise2 = follower._promise0;
      var receiver = follower._receiverAt(0);
      if (receiver === void 0) receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject2, promise2, receiver, null);
    };
    Promise2.prototype._migrateCallbackAt = function(follower, index2) {
      var fulfill = follower._fulfillmentHandlerAt(index2);
      var reject2 = follower._rejectionHandlerAt(index2);
      var promise2 = follower._promiseAt(index2);
      var receiver = follower._receiverAt(index2);
      if (receiver === void 0) receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject2, promise2, receiver, null);
    };
    Promise2.prototype._addCallbacks = function(fulfill, reject2, promise2, receiver, domain) {
      var index2 = this._length();
      if (index2 >= 65535 - 4) {
        index2 = 0;
        this._setLength(0);
      }
      if (index2 === 0) {
        this._promise0 = promise2;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
          this._fulfillmentHandler0 = domain === null ? fulfill : util2.domainBind(domain, fulfill);
        }
        if (typeof reject2 === "function") {
          this._rejectionHandler0 = domain === null ? reject2 : util2.domainBind(domain, reject2);
        }
      } else {
        var base = index2 * 4 - 4;
        this[base + 2] = promise2;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
          this[base + 0] = domain === null ? fulfill : util2.domainBind(domain, fulfill);
        }
        if (typeof reject2 === "function") {
          this[base + 1] = domain === null ? reject2 : util2.domainBind(domain, reject2);
        }
      }
      this._setLength(index2 + 1);
      return index2;
    };
    Promise2.prototype._proxy = function(proxyable, arg) {
      this._addCallbacks(void 0, void 0, arg, proxyable, null);
    };
    Promise2.prototype._resolveCallback = function(value, shouldBind) {
      if ((this._bitField & 117506048) !== 0) return;
      if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise2)) return this._fulfill(value);
      if (shouldBind) this._propagateFrom(maybePromise, 2);
      var promise2 = maybePromise._target();
      if (promise2 === this) {
        this._reject(makeSelfResolutionError());
        return;
      }
      var bitField = promise2._bitField;
      if ((bitField & 50397184) === 0) {
        var len = this._length();
        if (len > 0) promise2._migrateCallback0(this);
        for (var i = 1; i < len; ++i) {
          promise2._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise2);
      } else if ((bitField & 33554432) !== 0) {
        this._fulfill(promise2._value());
      } else if ((bitField & 16777216) !== 0) {
        this._reject(promise2._reason());
      } else {
        var reason = new CancellationError("late cancellation observer");
        promise2._attachExtraTrace(reason);
        this._reject(reason);
      }
    };
    Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
      var trace = util2.ensureErrorObject(reason);
      var hasStack = trace === reason;
      if (!hasStack && !ignoreNonErrorWarnings && debug2.warnings()) {
        var message = "a promise was rejected with a non-error: " + util2.classString(reason);
        this._warn(message, true);
      }
      this._attachExtraTrace(trace, synchronous ? hasStack : false);
      this._reject(reason);
    };
    Promise2.prototype._resolveFromExecutor = function(executor) {
      var promise2 = this;
      this._captureStackTrace();
      this._pushContext();
      var synchronous = true;
      var r = this._execute(executor, function(value) {
        promise2._resolveCallback(value);
      }, function(reason) {
        promise2._rejectCallback(reason, synchronous);
      });
      synchronous = false;
      this._popContext();
      if (r !== void 0) {
        promise2._rejectCallback(r, true);
      }
    };
    Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise2) {
      var bitField = promise2._bitField;
      if ((bitField & 65536) !== 0) return;
      promise2._pushContext();
      var x;
      if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
          x = errorObj;
          x.e = new TypeError2("cannot .spread() a non-array: " + util2.classString(value));
        } else {
          x = tryCatch(handler).apply(this._boundValue(), value);
        }
      } else {
        x = tryCatch(handler).call(receiver, value);
      }
      var promiseCreated = promise2._popContext();
      bitField = promise2._bitField;
      if ((bitField & 65536) !== 0) return;
      if (x === NEXT_FILTER) {
        promise2._reject(value);
      } else if (x === errorObj) {
        promise2._rejectCallback(x.e, false);
      } else {
        debug2.checkForgottenReturns(x, promiseCreated, "", promise2, this);
        promise2._resolveCallback(x);
      }
    };
    Promise2.prototype._target = function() {
      var ret = this;
      while (ret._isFollowing()) ret = ret._followee();
      return ret;
    };
    Promise2.prototype._followee = function() {
      return this._rejectionHandler0;
    };
    Promise2.prototype._setFollowee = function(promise2) {
      this._rejectionHandler0 = promise2;
    };
    Promise2.prototype._settlePromise = function(promise2, handler, receiver, value) {
      var isPromise = promise2 instanceof Promise2;
      var bitField = this._bitField;
      var asyncGuaranteed = (bitField & 134217728) !== 0;
      if ((bitField & 65536) !== 0) {
        if (isPromise) promise2._invokeInternalOnCancel();
        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
          receiver.cancelPromise = promise2;
          if (tryCatch(handler).call(receiver, value) === errorObj) {
            promise2._reject(errorObj.e);
          }
        } else if (handler === reflectHandler) {
          promise2._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
          receiver._promiseCancelled(promise2);
        } else if (isPromise || promise2 instanceof PromiseArray) {
          promise2._cancel();
        } else {
          receiver.cancel();
        }
      } else if (typeof handler === "function") {
        if (!isPromise) {
          handler.call(receiver, value, promise2);
        } else {
          if (asyncGuaranteed) promise2._setAsyncGuaranteed();
          this._settlePromiseFromHandler(handler, receiver, value, promise2);
        }
      } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
          if ((bitField & 33554432) !== 0) {
            receiver._promiseFulfilled(value, promise2);
          } else {
            receiver._promiseRejected(value, promise2);
          }
        }
      } else if (isPromise) {
        if (asyncGuaranteed) promise2._setAsyncGuaranteed();
        if ((bitField & 33554432) !== 0) {
          promise2._fulfill(value);
        } else {
          promise2._reject(value);
        }
      }
    };
    Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
      var handler = ctx.handler;
      var promise2 = ctx.promise;
      var receiver = ctx.receiver;
      var value = ctx.value;
      if (typeof handler === "function") {
        if (!(promise2 instanceof Promise2)) {
          handler.call(receiver, value, promise2);
        } else {
          this._settlePromiseFromHandler(handler, receiver, value, promise2);
        }
      } else if (promise2 instanceof Promise2) {
        promise2._reject(value);
      }
    };
    Promise2.prototype._settlePromiseCtx = function(ctx) {
      this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };
    Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
      var promise2 = this._promise0;
      var receiver = this._receiverAt(0);
      this._promise0 = void 0;
      this._receiver0 = void 0;
      this._settlePromise(promise2, handler, receiver, value);
    };
    Promise2.prototype._clearCallbackDataAtIndex = function(index2) {
      var base = index2 * 4 - 4;
      this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
    };
    Promise2.prototype._fulfill = function(value) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16) return;
      if (value === this) {
        var err2 = makeSelfResolutionError();
        this._attachExtraTrace(err2);
        return this._reject(err2);
      }
      this._setFulfilled();
      this._rejectionHandler0 = value;
      if ((bitField & 65535) > 0) {
        if ((bitField & 134217728) !== 0) {
          this._settlePromises();
        } else {
          async2.settlePromises(this);
        }
      }
    };
    Promise2.prototype._reject = function(reason) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16) return;
      this._setRejected();
      this._fulfillmentHandler0 = reason;
      if (this._isFinal()) {
        return async2.fatalError(reason, util2.isNode);
      }
      if ((bitField & 65535) > 0) {
        async2.settlePromises(this);
      } else {
        this._ensurePossibleRejectionHandled();
      }
    };
    Promise2.prototype._fulfillPromises = function(len, value) {
      for (var i = 1; i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise2 = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise2, handler, receiver, value);
      }
    };
    Promise2.prototype._rejectPromises = function(len, reason) {
      for (var i = 1; i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise2 = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise2, handler, receiver, reason);
      }
    };
    Promise2.prototype._settlePromises = function() {
      var bitField = this._bitField;
      var len = bitField & 65535;
      if (len > 0) {
        if ((bitField & 16842752) !== 0) {
          var reason = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, reason, bitField);
          this._rejectPromises(len, reason);
        } else {
          var value = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, value, bitField);
          this._fulfillPromises(len, value);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    };
    Promise2.prototype._settledValue = function() {
      var bitField = this._bitField;
      if ((bitField & 33554432) !== 0) {
        return this._rejectionHandler0;
      } else if ((bitField & 16777216) !== 0) {
        return this._fulfillmentHandler0;
      }
    };
    function deferResolve(v) {
      this.promise._resolveCallback(v);
    }
    function deferReject(v) {
      this.promise._rejectCallback(v, false);
    }
    Promise2.defer = Promise2.pending = function() {
      debug2.deprecated("Promise.defer", "new Promise");
      var promise2 = new Promise2(INTERNAL);
      return {
        promise: promise2,
        resolve: deferResolve,
        reject: deferReject
      };
    };
    util2.notEnumerableProp(
      Promise2,
      "_makeSelfResolutionError",
      makeSelfResolutionError
    );
    requireMethod()(
      Promise2,
      INTERNAL,
      tryConvertToPromise,
      apiRejection,
      debug2
    );
    requireBind()(Promise2, INTERNAL, tryConvertToPromise, debug2);
    requireCancel()(Promise2, PromiseArray, apiRejection, debug2);
    requireDirect_resolve()(Promise2);
    requireSynchronous_inspection()(Promise2);
    requireJoin()(
      Promise2,
      PromiseArray,
      tryConvertToPromise,
      INTERNAL,
      async2,
      getDomain
    );
    Promise2.Promise = Promise2;
    Promise2.version = "3.4.7";
    requireMap()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
    requireCall_get()(Promise2);
    requireUsing()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2);
    requireTimers()(Promise2, INTERNAL, debug2);
    requireGenerators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2);
    requireNodeify()(Promise2);
    requirePromisify()(Promise2, INTERNAL);
    requireProps()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
    requireRace()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    requireReduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
    requireSettle()(Promise2, PromiseArray, debug2);
    requireSome()(Promise2, PromiseArray, apiRejection);
    requireFilter()(Promise2, INTERNAL);
    requireEach()(Promise2, INTERNAL);
    requireAny()(Promise2);
    util2.toFastProperties(Promise2);
    util2.toFastProperties(Promise2.prototype);
    function fillTypes(value) {
      var p = new Promise2(INTERNAL);
      p._fulfillmentHandler0 = value;
      p._rejectionHandler0 = value;
      p._promise0 = value;
      p._receiver0 = value;
    }
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function() {
    });
    fillTypes(void 0);
    fillTypes(false);
    fillTypes(new Promise2(INTERNAL));
    debug2.setBounds(Async.firstLineError, util2.lastLineError);
    return Promise2;
  };
})(promise);
var promiseExports = promise.exports;
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
  try {
    if (Promise === bluebird) Promise = old;
  } catch (e) {
  }
  return bluebird;
}
var bluebird = promiseExports();
bluebird.noConflict = noConflict;
var bluebird_1 = bluebird;
var Buffer$6 = require$$0$3.Buffer;
if (Buffer$6.from === void 0) {
  Buffer$6.from = function(a, b, c2) {
    return new Buffer$6(a, b, c2);
  };
  Buffer$6.alloc = Buffer$6.from;
}
var Buffer_1 = Buffer$6;
var readable$1 = { exports: {} };
var stream$3;
var hasRequiredStream$1;
function requireStream$1() {
  if (hasRequiredStream$1) return stream$3;
  hasRequiredStream$1 = 1;
  stream$3 = require$$0$1;
  return stream$3;
}
var safeBuffer$1 = { exports: {} };
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  if (hasRequiredSafeBuffer$1) return safeBuffer$1.exports;
  hasRequiredSafeBuffer$1 = 1;
  (function(module, exports) {
    var buffer = require$$0$3;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$1, safeBuffer$1.exports);
  return safeBuffer$1.exports;
}
var BufferList$1 = { exports: {} };
var hasRequiredBufferList$1;
function requireBufferList$1() {
  if (hasRequiredBufferList$1) return BufferList$1.exports;
  hasRequiredBufferList$1 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$1().Buffer;
    var util2 = require$$0$4;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$1);
  return BufferList$1.exports;
}
var destroy_1$1;
var hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err2, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err2);
      } else if (err2) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err2);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err2);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err2 || null, function(err3) {
      if (!cb && err3) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err3);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err3);
        }
      } else if (cb) {
        cb(err3);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err2) {
    self2.emit("error", err2);
  }
  destroy_1$1 = {
    destroy,
    undestroy
  };
  return destroy_1$1;
}
var _stream_writable$1;
var hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$1 = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream$1();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$1();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable2) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
      return new Writable2(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync3) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err2) {
      state2.pendingcb--;
      if (err2) {
        stream2.emit("error", err2);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err2) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err2, cb) {
    this.end();
    cb(err2);
  };
  return _stream_writable$1;
}
var _stream_duplex$1;
var hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$1 = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$1();
  var Writable2 = require_stream_writable$1();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable2.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err2, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err2);
  };
  return _stream_duplex$1;
}
var string_decoder$1 = {};
var hasRequiredString_decoder$1;
function requireString_decoder$1() {
  if (hasRequiredString_decoder$1) return string_decoder$1;
  hasRequiredString_decoder$1 = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$1.StringDecoder = StringDecoder2;
  function StringDecoder2(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder2.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder2.prototype.end = utf8End;
  StringDecoder2.prototype.text = utf8Text;
  StringDecoder2.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$1;
}
var _stream_readable$1;
var hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$1 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = requireStream$1();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$4;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList$1();
  var destroyImpl = requireDestroy$1();
  var StringDecoder2;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2) StringDecoder2 = requireString_decoder$1().StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err2, cb) {
    this.push(null);
    cb(err2);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder2) StringDecoder2 = requireString_decoder$1().StringDecoder;
    this._readableState.decoder = new StringDecoder2(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug2("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c2 = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c2 = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1;
var hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1;
  _stream_transform$1 = Transform2;
  var Duplex = require_stream_duplex$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err2, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err2, function(err22) {
      cb(err22);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1;
var hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1;
  _stream_passthrough$1 = PassThrough2;
  var Transform2 = require_stream_transform$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$1;
}
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable$1.exports;
  hasRequiredReadable = 1;
  (function(module, exports) {
    var Stream2 = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream2) {
      module.exports = Stream2;
      exports = module.exports = Stream2.Readable;
      exports.Readable = Stream2.Readable;
      exports.Writable = Stream2.Writable;
      exports.Duplex = Stream2.Duplex;
      exports.Transform = Stream2.Transform;
      exports.PassThrough = Stream2.PassThrough;
      exports.Stream = Stream2;
    } else {
      exports = module.exports = require_stream_readable$1();
      exports.Stream = Stream2 || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable$1();
      exports.Duplex = require_stream_duplex$1();
      exports.Transform = require_stream_transform$1();
      exports.PassThrough = require_stream_passthrough$1();
    }
  })(readable$1, readable$1.exports);
  return readable$1.exports;
}
var Stream$8 = require$$0$1;
var Promise$7 = bluebird_1;
var util$2 = require$$0$4;
var Buffer$5 = Buffer_1;
var strFunction = "function";
if (!Stream$8.Writable || !Stream$8.Writable.prototype.destroy)
  Stream$8 = requireReadable();
function PullStream$3() {
  if (!(this instanceof PullStream$3))
    return new PullStream$3();
  Stream$8.Duplex.call(this, { decodeStrings: false, objectMode: true });
  this.buffer = Buffer$5.from("");
  var self2 = this;
  self2.on("finish", function() {
    self2.finished = true;
    self2.emit("chunk", false);
  });
}
util$2.inherits(PullStream$3, Stream$8.Duplex);
PullStream$3.prototype._write = function(chunk, e, cb) {
  this.buffer = Buffer$5.concat([this.buffer, chunk]);
  this.cb = cb;
  this.emit("chunk");
};
PullStream$3.prototype.stream = function(eof, includeEof) {
  var p = Stream$8.PassThrough();
  var done, self2 = this;
  function cb() {
    if (typeof self2.cb === strFunction) {
      var callback = self2.cb;
      self2.cb = void 0;
      return callback();
    }
  }
  function pull() {
    var packet;
    if (self2.buffer && self2.buffer.length) {
      if (typeof eof === "number") {
        packet = self2.buffer.slice(0, eof);
        self2.buffer = self2.buffer.slice(eof);
        eof -= packet.length;
        done = !eof;
      } else {
        var match2 = self2.buffer.indexOf(eof);
        if (match2 !== -1) {
          self2.match = match2;
          if (includeEof) match2 = match2 + eof.length;
          packet = self2.buffer.slice(0, match2);
          self2.buffer = self2.buffer.slice(match2);
          done = true;
        } else {
          var len = self2.buffer.length - eof.length;
          if (len <= 0) {
            cb();
          } else {
            packet = self2.buffer.slice(0, len);
            self2.buffer = self2.buffer.slice(len);
          }
        }
      }
      if (packet) p.write(packet, function() {
        if (self2.buffer.length === 0 || eof.length && self2.buffer.length <= eof.length) cb();
      });
    }
    if (!done) {
      if (self2.finished) {
        self2.removeListener("chunk", pull);
        self2.emit("error", new Error("FILE_ENDED"));
        return;
      }
    } else {
      self2.removeListener("chunk", pull);
      p.end();
    }
  }
  self2.on("chunk", pull);
  pull();
  return p;
};
PullStream$3.prototype.pull = function(eof, includeEof) {
  if (eof === 0) return Promise$7.resolve("");
  if (!isNaN(eof) && this.buffer.length > eof) {
    var data = this.buffer.slice(0, eof);
    this.buffer = this.buffer.slice(eof);
    return Promise$7.resolve(data);
  }
  var buffer = Buffer$5.from(""), self2 = this;
  var concatStream = Stream$8.Transform();
  concatStream._transform = function(d, e, cb) {
    buffer = Buffer$5.concat([buffer, d]);
    cb();
  };
  var rejectHandler;
  var pullStreamRejectHandler;
  return new Promise$7(function(resolve2, reject2) {
    rejectHandler = reject2;
    pullStreamRejectHandler = function(e) {
      self2.__emittedError = e;
      reject2(e);
    };
    if (self2.finished)
      return reject2(new Error("FILE_ENDED"));
    self2.once("error", pullStreamRejectHandler);
    self2.stream(eof, includeEof).on("error", reject2).pipe(concatStream).on("finish", function() {
      resolve2(buffer);
    }).on("error", reject2);
  }).finally(function() {
    self2.removeListener("error", rejectHandler);
    self2.removeListener("error", pullStreamRejectHandler);
  });
};
PullStream$3.prototype._read = function() {
};
var PullStream_1 = PullStream$3;
var Stream$7 = require$$0$1;
var util$1 = require$$0$4;
if (!Stream$7.Writable || !Stream$7.Writable.prototype.destroy)
  Stream$7 = requireReadable();
function NoopStream$1() {
  if (!(this instanceof NoopStream$1)) {
    return new NoopStream$1();
  }
  Stream$7.Transform.call(this);
}
util$1.inherits(NoopStream$1, Stream$7.Transform);
NoopStream$1.prototype._transform = function(d, e, cb) {
  cb();
};
var NoopStream_1 = NoopStream$1;
var Promise$6 = bluebird_1;
var Stream$6 = require$$0$1;
var Buffer$4 = Buffer_1;
if (!Stream$6.Writable || !Stream$6.Writable.prototype.destroy)
  Stream$6 = requireReadable();
var BufferStream$3 = function(entry) {
  return new Promise$6(function(resolve2, reject2) {
    var chunks = [];
    var bufferStream = Stream$6.Transform().on("finish", function() {
      resolve2(Buffer$4.concat(chunks));
    }).on("error", reject2);
    bufferStream._transform = function(d, e, cb) {
      chunks.push(d);
      cb();
    };
    entry.on("error", reject2).pipe(bufferStream);
  });
};
var binary$3 = binaryExports;
var parseExtraField$3 = function(extraField, vars2) {
  var extra;
  while (!extra && extraField && extraField.length) {
    var candidateExtra = binary$3.parse(extraField).word16lu("signature").word16lu("partsize").word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offset").word64lu("disknum").vars;
    if (candidateExtra.signature === 1) {
      extra = candidateExtra;
    } else {
      extraField = extraField.slice(candidateExtra.partsize + 4);
    }
  }
  extra = extra || {};
  if (vars2.compressedSize === 4294967295)
    vars2.compressedSize = extra.compressedSize;
  if (vars2.uncompressedSize === 4294967295)
    vars2.uncompressedSize = extra.uncompressedSize;
  if (vars2.offsetToLocalFileHeader === 4294967295)
    vars2.offsetToLocalFileHeader = extra.offset;
  return extra;
};
var parseDateTime$3 = function parseDateTime(date, time) {
  const day = date & 31;
  const month = date >> 5 & 15;
  const year = (date >> 9 & 127) + 1980;
  const seconds = time ? (time & 31) * 2 : 0;
  const minutes = time ? time >> 5 & 63 : 0;
  const hours = time ? time >> 11 : 0;
  return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
};
var util = require$$0$4;
var zlib$1 = require$$0$7;
var Stream$5 = require$$0$1;
var binary$2 = binaryExports;
var Promise$5 = bluebird_1;
var PullStream$2 = PullStream_1;
var NoopStream = NoopStream_1;
var BufferStream$2 = BufferStream$3;
var parseExtraField$2 = parseExtraField$3;
var Buffer$3 = Buffer_1;
var parseDateTime$2 = parseDateTime$3;
if (!Stream$5.Writable || !Stream$5.Writable.prototype.destroy)
  Stream$5 = requireReadable();
var endDirectorySignature = Buffer$3.alloc(4);
endDirectorySignature.writeUInt32LE(101010256, 0);
function Parse$2(opts) {
  if (!(this instanceof Parse$2)) {
    return new Parse$2(opts);
  }
  var self2 = this;
  self2._opts = opts || { verbose: false };
  PullStream$2.call(self2, self2._opts);
  self2.on("finish", function() {
    self2.emit("end");
    self2.emit("close");
  });
  self2._readRecord().catch(function(e) {
    if (!self2.__emittedError || self2.__emittedError !== e)
      self2.emit("error", e);
  });
}
util.inherits(Parse$2, PullStream$2);
Parse$2.prototype._readRecord = function() {
  var self2 = this;
  return self2.pull(4).then(function(data) {
    if (data.length === 0)
      return;
    var signature2 = data.readUInt32LE(0);
    if (signature2 === 875721283) {
      return self2._readCrxHeader();
    }
    if (signature2 === 67324752) {
      return self2._readFile();
    } else if (signature2 === 33639248) {
      self2.reachedCD = true;
      return self2._readCentralDirectoryFileHeader();
    } else if (signature2 === 101010256) {
      return self2._readEndOfCentralDirectoryRecord();
    } else if (self2.reachedCD) {
      var includeEof = true;
      return self2.pull(endDirectorySignature, includeEof).then(function() {
        return self2._readEndOfCentralDirectoryRecord();
      });
    } else
      self2.emit("error", new Error("invalid signature: 0x" + signature2.toString(16)));
  });
};
Parse$2.prototype._readCrxHeader = function() {
  var self2 = this;
  return self2.pull(12).then(function(data) {
    self2.crxHeader = binary$2.parse(data).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
    return self2.pull(self2.crxHeader.pubKeyLength + self2.crxHeader.signatureLength);
  }).then(function(data) {
    self2.crxHeader.publicKey = data.slice(0, self2.crxHeader.pubKeyLength);
    self2.crxHeader.signature = data.slice(self2.crxHeader.pubKeyLength);
    self2.emit("crx-header", self2.crxHeader);
    return self2._readRecord();
  });
};
Parse$2.prototype._readFile = function() {
  var self2 = this;
  return self2.pull(26).then(function(data) {
    var vars2 = binary$2.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
    vars2.lastModifiedDateTime = parseDateTime$2(vars2.lastModifiedDate, vars2.lastModifiedTime);
    if (self2.crxHeader) vars2.crxHeader = self2.crxHeader;
    return self2.pull(vars2.fileNameLength).then(function(fileNameBuffer) {
      var fileName = fileNameBuffer.toString("utf8");
      var entry = Stream$5.PassThrough();
      var __autodraining = false;
      entry.autodrain = function() {
        __autodraining = true;
        var draining = entry.pipe(NoopStream());
        draining.promise = function() {
          return new Promise$5(function(resolve2, reject2) {
            draining.on("finish", resolve2);
            draining.on("error", reject2);
          });
        };
        return draining;
      };
      entry.buffer = function() {
        return BufferStream$2(entry);
      };
      entry.path = fileName;
      entry.props = {};
      entry.props.path = fileName;
      entry.props.pathBuffer = fileNameBuffer;
      entry.props.flags = {
        "isUnicode": (vars2.flags & 2048) != 0
      };
      entry.type = vars2.uncompressedSize === 0 && /[\/\\]$/.test(fileName) ? "Directory" : "File";
      if (self2._opts.verbose) {
        if (entry.type === "Directory") {
          console.log("   creating:", fileName);
        } else if (entry.type === "File") {
          if (vars2.compressionMethod === 0) {
            console.log(" extracting:", fileName);
          } else {
            console.log("  inflating:", fileName);
          }
        }
      }
      return self2.pull(vars2.extraFieldLength).then(function(extraField) {
        var extra = parseExtraField$2(extraField, vars2);
        entry.vars = vars2;
        entry.extra = extra;
        if (self2._opts.forceStream) {
          self2.push(entry);
        } else {
          self2.emit("entry", entry);
          if (self2._readableState.pipesCount || self2._readableState.pipes && self2._readableState.pipes.length)
            self2.push(entry);
        }
        if (self2._opts.verbose)
          console.log({
            filename: fileName,
            vars: vars2,
            extra
          });
        var fileSizeKnown = !(vars2.flags & 8) || vars2.compressedSize > 0, eof;
        entry.__autodraining = __autodraining;
        var inflater = vars2.compressionMethod && !__autodraining ? zlib$1.createInflateRaw() : Stream$5.PassThrough();
        if (fileSizeKnown) {
          entry.size = vars2.uncompressedSize;
          eof = vars2.compressedSize;
        } else {
          eof = Buffer$3.alloc(4);
          eof.writeUInt32LE(134695760, 0);
        }
        return new Promise$5(function(resolve2, reject2) {
          self2.stream(eof).pipe(inflater).on("error", function(err2) {
            self2.emit("error", err2);
          }).pipe(entry).on("finish", function() {
            return fileSizeKnown ? self2._readRecord().then(resolve2).catch(reject2) : self2._processDataDescriptor(entry).then(resolve2).catch(reject2);
          });
        });
      });
    });
  });
};
Parse$2.prototype._processDataDescriptor = function(entry) {
  var self2 = this;
  return self2.pull(16).then(function(data) {
    var vars2 = binary$2.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
    entry.size = vars2.uncompressedSize;
    return self2._readRecord();
  });
};
Parse$2.prototype._readCentralDirectoryFileHeader = function() {
  var self2 = this;
  return self2.pull(42).then(function(data) {
    var vars2 = binary$2.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
    return self2.pull(vars2.fileNameLength).then(function(fileName) {
      vars2.fileName = fileName.toString("utf8");
      return self2.pull(vars2.extraFieldLength);
    }).then(function(extraField) {
      return self2.pull(vars2.fileCommentLength);
    }).then(function(fileComment) {
      return self2._readRecord();
    });
  });
};
Parse$2.prototype._readEndOfCentralDirectoryRecord = function() {
  var self2 = this;
  return self2.pull(18).then(function(data) {
    var vars2 = binary$2.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
    return self2.pull(vars2.commentLength).then(function(comment) {
      comment = comment.toString("utf8");
      self2.end();
      self2.push(null);
    });
  });
};
Parse$2.prototype.promise = function() {
  var self2 = this;
  return new Promise$5(function(resolve2, reject2) {
    self2.on("finish", resolve2);
    self2.on("error", reject2);
  });
};
var parse = Parse$2;
var duplexer2$2 = { exports: {} };
var readable = { exports: {} };
var stream$2;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream$2;
  hasRequiredStream = 1;
  stream$2 = require$$0$1;
  return stream$2;
}
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer = require$$0$3;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var BufferList = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList) return BufferList.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer().Buffer;
    var util2 = require$$0$4;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList);
  return BufferList.exports;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err2, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err2);
      } else if (err2) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err2);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err2);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err2 || null, function(err3) {
      if (!cb && err3) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err3);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err3);
        }
      } else if (cb) {
        cb(err3);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err2) {
    self2.emit("error", err2);
  }
  destroy_1 = {
    destroy,
    undestroy
  };
  return destroy_1;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable2) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
      return new Writable2(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync3, er, cb) {
    --state2.pendingcb;
    if (sync3) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync3 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync3, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync3) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err2) {
      state2.pendingcb--;
      if (err2) {
        stream2.emit("error", err2);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err2) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err2, cb) {
    this.end();
    cb(err2);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable();
  var Writable2 = require_stream_writable();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable2.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err2, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err2);
  };
  return _stream_duplex;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder2;
  function StringDecoder2(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder2.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder2.prototype.end = utf8End;
  StringDecoder2.prototype.text = utf8Text;
  StringDecoder2.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "�";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = requireStream();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$4;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = requireDestroy();
  var StringDecoder2;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2) StringDecoder2 = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err2, cb) {
    this.push(null);
    cb(err2);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder2) StringDecoder2 = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder2(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug2("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf2(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c2 = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c2 = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c2;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c2;
    }
    list.length -= c2;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform2;
  var Duplex = require_stream_duplex();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err2, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err2, function(err22) {
      cb(err22);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough2;
  var Transform2 = require_stream_transform();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
(function(module, exports) {
  var Stream2 = require$$0$1;
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module.exports = Stream2;
    exports = module.exports = Stream2.Readable;
    exports.Readable = Stream2.Readable;
    exports.Writable = Stream2.Writable;
    exports.Duplex = Stream2.Duplex;
    exports.Transform = Stream2.Transform;
    exports.PassThrough = Stream2.PassThrough;
    exports.Stream = Stream2;
  } else {
    exports = module.exports = require_stream_readable();
    exports.Stream = Stream2 || exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
  }
})(readable, readable.exports);
var readableExports = readable.exports;
var stream$1 = readableExports;
function DuplexWrapper(options, writable, readable2) {
  if (typeof readable2 === "undefined") {
    readable2 = writable;
    writable = options;
    options = null;
  }
  stream$1.Duplex.call(this, options);
  if (typeof readable2.read !== "function") {
    readable2 = new stream$1.Readable(options).wrap(readable2);
  }
  this._writable = writable;
  this._readable = readable2;
  this._waiting = false;
  var self2 = this;
  writable.once("finish", function() {
    self2.end();
  });
  this.once("finish", function() {
    writable.end();
  });
  readable2.on("readable", function() {
    if (self2._waiting) {
      self2._waiting = false;
      self2._read();
    }
  });
  readable2.once("end", function() {
    self2.push(null);
  });
  if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
    writable.on("error", function(err2) {
      self2.emit("error", err2);
    });
    readable2.on("error", function(err2) {
      self2.emit("error", err2);
    });
  }
}
DuplexWrapper.prototype = Object.create(stream$1.Duplex.prototype, { constructor: { value: DuplexWrapper } });
DuplexWrapper.prototype._write = function _write2(input, encoding, done) {
  this._writable.write(input, encoding, done);
};
DuplexWrapper.prototype._read = function _read2() {
  var buf;
  var reads = 0;
  while ((buf = this._readable.read()) !== null) {
    this.push(buf);
    reads++;
  }
  if (reads === 0) {
    this._waiting = true;
  }
};
duplexer2$2.exports = function duplex2(options, writable, readable2) {
  return new DuplexWrapper(options, writable, readable2);
};
duplexer2$2.exports.DuplexWrapper = DuplexWrapper;
var duplexer2Exports = duplexer2$2.exports;
var Stream$4 = require$$0$1;
var Parse$1 = parse;
var duplexer2$1 = duplexer2Exports;
var BufferStream$1 = BufferStream$3;
if (!Stream$4.Writable || !Stream$4.Writable.prototype.destroy)
  Stream$4 = requireReadable();
function parseOne(match2, opts) {
  var inStream = Stream$4.PassThrough({ objectMode: true });
  var outStream = Stream$4.PassThrough();
  var transform2 = Stream$4.Transform({ objectMode: true });
  var re = match2 instanceof RegExp ? match2 : match2 && new RegExp(match2);
  var found;
  transform2._transform = function(entry, e, cb) {
    if (found || re && !re.exec(entry.path)) {
      entry.autodrain();
      return cb();
    } else {
      found = true;
      out2.emit("entry", entry);
      entry.on("error", function(e2) {
        outStream.emit("error", e2);
      });
      entry.pipe(outStream).on("error", function(err2) {
        cb(err2);
      }).on("finish", function(d) {
        cb(null, d);
      });
    }
  };
  inStream.pipe(Parse$1(opts)).on("error", function(err2) {
    outStream.emit("error", err2);
  }).pipe(transform2).on("error", Object).on("finish", function() {
    if (!found)
      outStream.emit("error", new Error("PATTERN_NOT_FOUND"));
    else
      outStream.end();
  });
  var out2 = duplexer2$1(inStream, outStream);
  out2.buffer = function() {
    return BufferStream$1(outStream);
  };
  return out2;
}
var parseOne_1 = parseOne;
var fstream = {};
var abstract = Abstract;
var Stream$3 = require$$0$1.Stream;
var inherits = requireInherits();
function Abstract() {
  Stream$3.call(this);
}
inherits(Abstract, Stream$3);
Abstract.prototype.on = function(ev, fn) {
  if (ev === "ready" && this.ready) {
    process.nextTick(fn.bind(this));
  } else {
    Stream$3.prototype.on.call(this, ev, fn);
  }
  return this;
};
Abstract.prototype.abort = function() {
  this._aborted = true;
  this.emit("abort");
};
Abstract.prototype.destroy = function() {
};
Abstract.prototype.warn = function(msg2, code) {
  var self2 = this;
  var er = decorate(msg2, code, self2);
  if (!self2.listeners("warn")) {
    console.error(
      "%s %s\npath = %s\nsyscall = %s\nfstream_type = %s\nfstream_path = %s\nfstream_unc_path = %s\nfstream_class = %s\nfstream_stack =\n%s\n",
      code || "UNKNOWN",
      er.stack,
      er.path,
      er.syscall,
      er.fstream_type,
      er.fstream_path,
      er.fstream_unc_path,
      er.fstream_class,
      er.fstream_stack.join("\n")
    );
  } else {
    self2.emit("warn", er);
  }
};
Abstract.prototype.info = function(msg2, code) {
  this.emit("info", msg2, code);
};
Abstract.prototype.error = function(msg2, code, th) {
  var er = decorate(msg2, code, this);
  if (th) throw er;
  else this.emit("error", er);
};
function decorate(er, code, self2) {
  if (!(er instanceof Error)) er = new Error(er);
  er.code = er.code || code;
  er.path = er.path || self2.path;
  er.fstream_type = er.fstream_type || self2.type;
  er.fstream_path = er.fstream_path || self2.path;
  if (self2._path !== self2.path) {
    er.fstream_unc_path = er.fstream_unc_path || self2._path;
  }
  if (self2.linkpath) {
    er.fstream_linkpath = er.fstream_linkpath || self2.linkpath;
  }
  er.fstream_class = er.fstream_class || self2.constructor.name;
  er.fstream_stack = er.fstream_stack || new Error().stack.split(/\n/).slice(3).map(function(s) {
    return s.replace(/^ {4}at /, "");
  });
  return er;
}
var getType_1 = getType;
function getType(st) {
  var types2 = [
    "Directory",
    "File",
    "SymbolicLink",
    "Link",
    // special for hardlinks from tarballs
    "BlockDevice",
    "CharacterDevice",
    "FIFO",
    "Socket"
  ];
  var type;
  if (st.type && types2.indexOf(st.type) !== -1) {
    st[st.type] = true;
    return st.type;
  }
  for (var i = 0, l = types2.length; i < l; i++) {
    type = types2[i];
    var is = st[type] || st["is" + type];
    if (typeof is === "function") is = is.call(st);
    if (is) {
      st[type] = true;
      st.type = type;
      return type;
    }
  }
  return null;
}
var linkReader;
var hasRequiredLinkReader;
function requireLinkReader() {
  if (hasRequiredLinkReader) return linkReader;
  hasRequiredLinkReader = 1;
  linkReader = LinkReader;
  var fs2 = gracefulFs;
  var inherits2 = requireInherits();
  var Reader = requireReader();
  inherits2(LinkReader, Reader);
  function LinkReader(props2) {
    var self2 = this;
    if (!(self2 instanceof LinkReader)) {
      throw new Error("LinkReader must be called as constructor.");
    }
    if (!(props2.type === "Link" && props2.Link || props2.type === "SymbolicLink" && props2.SymbolicLink)) {
      throw new Error("Non-link type " + props2.type);
    }
    Reader.call(self2, props2);
  }
  LinkReader.prototype._stat = function(currentStat) {
    var self2 = this;
    fs2.readlink(self2._path, function(er, linkpath) {
      if (er) return self2.error(er);
      self2.linkpath = self2.props.linkpath = linkpath;
      self2.emit("linkpath", linkpath);
      Reader.prototype._stat.call(self2, currentStat);
    });
  };
  LinkReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused) return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
  return linkReader;
}
var dirReader;
var hasRequiredDirReader;
function requireDirReader() {
  if (hasRequiredDirReader) return dirReader;
  hasRequiredDirReader = 1;
  dirReader = DirReader;
  var fs2 = gracefulFs;
  var inherits2 = requireInherits();
  var path2 = require$$1;
  var Reader = requireReader();
  var assert2 = require$$5.ok;
  inherits2(DirReader, Reader);
  function DirReader(props2) {
    var self2 = this;
    if (!(self2 instanceof DirReader)) {
      throw new Error("DirReader must be called as constructor.");
    }
    if (props2.type !== "Directory" || !props2.Directory) {
      throw new Error("Non-directory type " + props2.type);
    }
    self2.entries = null;
    self2._index = -1;
    self2._paused = false;
    self2._length = -1;
    if (props2.sort) {
      this.sort = props2.sort;
    }
    Reader.call(this, props2);
  }
  DirReader.prototype._getEntries = function() {
    var self2 = this;
    if (self2._gotEntries) return;
    self2._gotEntries = true;
    fs2.readdir(self2._path, function(er, entries) {
      if (er) return self2.error(er);
      self2.entries = entries;
      self2.emit("entries", entries);
      if (self2._paused) self2.once("resume", processEntries);
      else processEntries();
      function processEntries() {
        self2._length = self2.entries.length;
        if (typeof self2.sort === "function") {
          self2.entries = self2.entries.sort(self2.sort.bind(self2));
        }
        self2._read();
      }
    });
  };
  DirReader.prototype._read = function() {
    var self2 = this;
    if (!self2.entries) return self2._getEntries();
    if (self2._paused || self2._currentEntry || self2._aborted) {
      return;
    }
    self2._index++;
    if (self2._index >= self2.entries.length) {
      if (!self2._ended) {
        self2._ended = true;
        self2.emit("end");
        self2.emit("close");
      }
      return;
    }
    var p = path2.resolve(self2._path, self2.entries[self2._index]);
    assert2(p !== self2._path);
    assert2(self2.entries[self2._index]);
    self2._currentEntry = p;
    fs2[self2.props.follow ? "stat" : "lstat"](p, function(er, stat2) {
      if (er) return self2.error(er);
      var who = self2._proxy || self2;
      stat2.path = p;
      stat2.basename = path2.basename(p);
      stat2.dirname = path2.dirname(p);
      var childProps = self2.getChildProps.call(who, stat2);
      childProps.path = p;
      childProps.basename = path2.basename(p);
      childProps.dirname = path2.dirname(p);
      var entry = Reader(childProps, stat2);
      self2._currentEntry = entry;
      entry.on("pause", function(who2) {
        if (!self2._paused && !entry._disowned) {
          self2.pause(who2);
        }
      });
      entry.on("resume", function(who2) {
        if (self2._paused && !entry._disowned) {
          self2.resume(who2);
        }
      });
      entry.on("stat", function(props2) {
        self2.emit("_entryStat", entry, props2);
        if (entry._aborted) return;
        if (entry._paused) {
          entry.once("resume", function() {
            self2.emit("entryStat", entry, props2);
          });
        } else self2.emit("entryStat", entry, props2);
      });
      entry.on("ready", function EMITCHILD() {
        if (self2._paused) {
          entry.pause(self2);
          return self2.once("resume", EMITCHILD);
        }
        if (entry.type === "Socket") {
          self2.emit("socket", entry);
        } else {
          self2.emitEntry(entry);
        }
      });
      var ended = false;
      entry.on("close", onend);
      entry.on("disown", onend);
      function onend() {
        if (ended) return;
        ended = true;
        self2.emit("childEnd", entry);
        self2.emit("entryEnd", entry);
        self2._currentEntry = null;
        if (!self2._paused) {
          self2._read();
        }
      }
      entry.on("error", function(er2) {
        if (entry._swallowErrors) {
          self2.warn(er2);
          entry.emit("end");
          entry.emit("close");
        } else {
          self2.emit("error", er2);
        }
      });
      [
        "child",
        "childEnd",
        "warn"
      ].forEach(function(ev) {
        entry.on(ev, self2.emit.bind(self2, ev));
      });
    });
  };
  DirReader.prototype.disown = function(entry) {
    entry.emit("beforeDisown");
    entry._disowned = true;
    entry.parent = entry.root = null;
    if (entry === this._currentEntry) {
      this._currentEntry = null;
    }
    entry.emit("disown");
  };
  DirReader.prototype.getChildProps = function() {
    return {
      depth: this.depth + 1,
      root: this.root || this,
      parent: this,
      follow: this.follow,
      filter: this.filter,
      sort: this.props.sort,
      hardlinks: this.props.hardlinks
    };
  };
  DirReader.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused) return;
    who = who || self2;
    self2._paused = true;
    if (self2._currentEntry && self2._currentEntry.pause) {
      self2._currentEntry.pause(who);
    }
    self2.emit("pause", who);
  };
  DirReader.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused) return;
    who = who || self2;
    self2._paused = false;
    self2.emit("resume", who);
    if (self2._paused) {
      return;
    }
    if (self2._currentEntry) {
      if (self2._currentEntry.resume) self2._currentEntry.resume(who);
    } else self2._read();
  };
  DirReader.prototype.emitEntry = function(entry) {
    this.emit("entry", entry);
    this.emit("child", entry);
  };
  return dirReader;
}
var fileReader;
var hasRequiredFileReader;
function requireFileReader() {
  if (hasRequiredFileReader) return fileReader;
  hasRequiredFileReader = 1;
  fileReader = FileReader2;
  var fs2 = gracefulFs;
  var inherits2 = requireInherits();
  var Reader = requireReader();
  var EOF = { EOF: true };
  var CLOSE = { CLOSE: true };
  inherits2(FileReader2, Reader);
  function FileReader2(props2) {
    var self2 = this;
    if (!(self2 instanceof FileReader2)) {
      throw new Error("FileReader must be called as constructor.");
    }
    if (!(props2.type === "Link" && props2.Link || props2.type === "File" && props2.File)) {
      throw new Error("Non-file type " + props2.type);
    }
    self2._buffer = [];
    self2._bytesEmitted = 0;
    Reader.call(self2, props2);
  }
  FileReader2.prototype._getStream = function() {
    var self2 = this;
    var stream2 = self2._stream = fs2.createReadStream(self2._path, self2.props);
    if (self2.props.blksize) {
      stream2.bufferSize = self2.props.blksize;
    }
    stream2.on("open", self2.emit.bind(self2, "open"));
    stream2.on("data", function(c2) {
      self2._bytesEmitted += c2.length;
      if (!c2.length) {
        return;
      } else if (self2._paused || self2._buffer.length) {
        self2._buffer.push(c2);
        self2._read();
      } else self2.emit("data", c2);
    });
    stream2.on("end", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(EOF);
        self2._read();
      } else {
        self2.emit("end");
      }
      if (self2._bytesEmitted !== self2.props.size) {
        self2.error("Didn't get expected byte count\nexpect: " + self2.props.size + "\nactual: " + self2._bytesEmitted);
      }
    });
    stream2.on("close", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(CLOSE);
        self2._read();
      } else {
        self2.emit("close");
      }
    });
    stream2.on("error", function(e) {
      self2.emit("error", e);
    });
    self2._read();
  };
  FileReader2.prototype._read = function() {
    var self2 = this;
    if (self2._paused) {
      return;
    }
    if (!self2._stream) {
      return self2._getStream();
    }
    if (self2._buffer.length) {
      var buf = self2._buffer;
      for (var i = 0, l = buf.length; i < l; i++) {
        var c2 = buf[i];
        if (c2 === EOF) {
          self2.emit("end");
        } else if (c2 === CLOSE) {
          self2.emit("close");
        } else {
          self2.emit("data", c2);
        }
        if (self2._paused) {
          self2._buffer = buf.slice(i);
          return;
        }
      }
      self2._buffer.length = 0;
    }
  };
  FileReader2.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused) return;
    who = who || self2;
    self2._paused = true;
    if (self2._stream) self2._stream.pause();
    self2.emit("pause", who);
  };
  FileReader2.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused) return;
    who = who || self2;
    self2.emit("resume", who);
    self2._paused = false;
    if (self2._stream) self2._stream.resume();
    self2._read();
  };
  return fileReader;
}
var socketReader;
var hasRequiredSocketReader;
function requireSocketReader() {
  if (hasRequiredSocketReader) return socketReader;
  hasRequiredSocketReader = 1;
  socketReader = SocketReader;
  var inherits2 = requireInherits();
  var Reader = requireReader();
  inherits2(SocketReader, Reader);
  function SocketReader(props2) {
    var self2 = this;
    if (!(self2 instanceof SocketReader)) {
      throw new Error("SocketReader must be called as constructor.");
    }
    if (!(props2.type === "Socket" && props2.Socket)) {
      throw new Error("Non-socket type " + props2.type);
    }
    Reader.call(self2, props2);
  }
  SocketReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused) return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
  return socketReader;
}
var proxyReader;
var hasRequiredProxyReader;
function requireProxyReader() {
  if (hasRequiredProxyReader) return proxyReader;
  hasRequiredProxyReader = 1;
  proxyReader = ProxyReader;
  var Reader = requireReader();
  var getType2 = getType_1;
  var inherits2 = requireInherits();
  var fs2 = gracefulFs;
  inherits2(ProxyReader, Reader);
  function ProxyReader(props2) {
    var self2 = this;
    if (!(self2 instanceof ProxyReader)) {
      throw new Error("ProxyReader must be called as constructor.");
    }
    self2.props = props2;
    self2._buffer = [];
    self2.ready = false;
    Reader.call(self2, props2);
  }
  ProxyReader.prototype._stat = function() {
    var self2 = this;
    var props2 = self2.props;
    var stat2 = props2.follow ? "stat" : "lstat";
    fs2[stat2](props2.path, function(er, current) {
      var type;
      if (er || !current) {
        type = "File";
      } else {
        type = getType2(current);
      }
      props2[type] = true;
      props2.type = self2.type = type;
      self2._old = current;
      self2._addProxy(Reader(props2, current));
    });
  };
  ProxyReader.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxyTarget) {
      return self2.error("proxy already set");
    }
    self2._proxyTarget = proxy;
    proxy._proxy = self2;
    [
      "error",
      "data",
      "end",
      "close",
      "linkpath",
      "entry",
      "entryEnd",
      "child",
      "childEnd",
      "warn",
      "stat"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    proxy.on("ready", function() {
      self2.ready = true;
      self2.emit("ready");
    });
    var calls = self2._buffer;
    self2._buffer.length = 0;
    calls.forEach(function(c2) {
      proxy[c2[0]].apply(proxy, c2[1]);
    });
  };
  ProxyReader.prototype.pause = function() {
    return this._proxyTarget ? this._proxyTarget.pause() : false;
  };
  ProxyReader.prototype.resume = function() {
    return this._proxyTarget ? this._proxyTarget.resume() : false;
  };
  return proxyReader;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  reader = Reader;
  var fs2 = gracefulFs;
  var Stream2 = require$$0$1.Stream;
  var inherits2 = requireInherits();
  var path2 = require$$1;
  var getType2 = getType_1;
  var hardLinks = Reader.hardLinks = {};
  var Abstract2 = abstract;
  inherits2(Reader, Abstract2);
  var LinkReader = requireLinkReader();
  function Reader(props2, currentStat) {
    var self2 = this;
    if (!(self2 instanceof Reader)) return new Reader(props2, currentStat);
    if (typeof props2 === "string") {
      props2 = { path: props2 };
    }
    var type;
    var ClassType;
    if (props2.type && typeof props2.type === "function") {
      type = props2.type;
      ClassType = type;
    } else {
      type = getType2(props2);
      ClassType = Reader;
    }
    if (currentStat && !type) {
      type = getType2(currentStat);
      props2[type] = true;
      props2.type = type;
    }
    switch (type) {
      case "Directory":
        ClassType = requireDirReader();
        break;
      case "Link":
      case "File":
        ClassType = requireFileReader();
        break;
      case "SymbolicLink":
        ClassType = LinkReader;
        break;
      case "Socket":
        ClassType = requireSocketReader();
        break;
      case null:
        ClassType = requireProxyReader();
        break;
    }
    if (!(self2 instanceof ClassType)) {
      return new ClassType(props2);
    }
    Abstract2.call(self2);
    if (!props2.path) {
      self2.error("Must provide a path", null, true);
    }
    self2.readable = true;
    self2.writable = false;
    self2.type = type;
    self2.props = props2;
    self2.depth = props2.depth = props2.depth || 0;
    self2.parent = props2.parent || null;
    self2.root = props2.root || props2.parent && props2.parent.root || self2;
    self2._path = self2.path = path2.resolve(props2.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = props2.basename = path2.basename(self2.path);
    self2.dirname = props2.dirname = path2.dirname(self2.path);
    props2.parent = props2.root = null;
    self2.size = props2.size;
    self2.filter = typeof props2.filter === "function" ? props2.filter : null;
    if (props2.sort === "alpha") props2.sort = alphasort2;
    self2._stat(currentStat);
  }
  function alphasort2(a, b) {
    return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;
  }
  Reader.prototype._stat = function(currentStat) {
    var self2 = this;
    var props2 = self2.props;
    var stat2 = props2.follow ? "stat" : "lstat";
    if (currentStat) process.nextTick(statCb.bind(null, null, currentStat));
    else fs2[stat2](self2._path, statCb);
    function statCb(er, props_) {
      if (er) return self2.error(er);
      Object.keys(props_).forEach(function(k2) {
        props2[k2] = props_[k2];
      });
      if (void 0 !== self2.size && props2.size !== self2.size) {
        return self2.error("incorrect size");
      }
      self2.size = props2.size;
      var type = getType2(props2);
      var handleHardlinks = props2.hardlinks !== false;
      if (handleHardlinks && type !== "Directory" && props2.nlink && props2.nlink > 1) {
        var k = props2.dev + ":" + props2.ino;
        if (hardLinks[k] === self2._path || !hardLinks[k]) {
          hardLinks[k] = self2._path;
        } else {
          type = self2.type = self2.props.type = "Link";
          self2.Link = self2.props.Link = true;
          self2.linkpath = self2.props.linkpath = hardLinks[k];
          self2._stat = self2._read = LinkReader.prototype._read;
        }
      }
      if (self2.type && self2.type !== type) {
        self2.error("Unexpected type: " + type);
      }
      if (self2.filter) {
        var who = self2._proxy || self2;
        if (!self2.filter.call(who, who, props2)) {
          if (!self2._disowned) {
            self2.abort();
            self2.emit("end");
            self2.emit("close");
          }
          return;
        }
      }
      var events2 = ["_stat", "stat", "ready"];
      var e = 0;
      (function go() {
        if (self2._aborted) {
          self2.emit("end");
          self2.emit("close");
          return;
        }
        if (self2._paused && self2.type !== "Directory") {
          self2.once("resume", go);
          return;
        }
        var ev = events2[e++];
        if (!ev) {
          return self2._read();
        }
        self2.emit(ev, props2);
        go();
      })();
    }
  };
  Reader.prototype.pipe = function(dest) {
    var self2 = this;
    if (typeof dest.add === "function") {
      self2.on("entry", function(entry) {
        var ret = dest.add(entry);
        if (ret === false) {
          self2.pause();
        }
      });
    }
    return Stream2.prototype.pipe.apply(this, arguments);
  };
  Reader.prototype.pause = function(who) {
    this._paused = true;
    who = who || this;
    this.emit("pause", who);
    if (this._stream) this._stream.pause(who);
  };
  Reader.prototype.resume = function(who) {
    this._paused = false;
    who = who || this;
    this.emit("resume", who);
    if (this._stream) this._stream.resume(who);
    this._read();
  };
  Reader.prototype._read = function() {
    this.error("Cannot read unknown type: " + this.type);
  };
  return reader;
}
var rimraf_1 = rimraf;
rimraf.sync = rimrafSync;
var assert = require$$5;
var path$3 = require$$1;
var fs$3 = require$$0$2;
var glob = void 0;
try {
  glob = requireGlob();
} catch (_err) {
}
var _0666 = parseInt("666", 8);
var defaultGlobOpts = {
  nosort: true,
  silent: true
};
var timeout = 0;
var isWindows = process.platform === "win32";
function defaults(options) {
  var methods = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ];
  methods.forEach(function(m) {
    options[m] = options[m] || fs$3[m];
    m = m + "Sync";
    options[m] = options[m] || fs$3[m];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
  options.emfileWait = options.emfileWait || 1e3;
  if (options.glob === false) {
    options.disableGlob = true;
  }
  if (options.disableGlob !== true && glob === void 0) {
    throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
  }
  options.disableGlob = options.disableGlob || false;
  options.glob = options.glob || defaultGlobOpts;
}
function rimraf(p, options, cb) {
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert(p, "rimraf: missing path");
  assert.equal(typeof p, "string", "rimraf: path should be a string");
  assert.equal(typeof cb, "function", "rimraf: callback function required");
  assert(options, "rimraf: invalid options argument provided");
  assert.equal(typeof options, "object", "rimraf: options should be object");
  defaults(options);
  var busyTries = 0;
  var errState = null;
  var n = 0;
  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p]);
  options.lstat(p, function(er, stat2) {
    if (!er)
      return afterGlob(null, [p]);
    glob(p, options.glob, afterGlob);
  });
  function next(er) {
    errState = errState || er;
    if (--n === 0)
      cb(errState);
  }
  function afterGlob(er, results) {
    if (er)
      return cb(er);
    n = results.length;
    if (n === 0)
      return cb();
    results.forEach(function(p2) {
      rimraf_(p2, options, function CB(er2) {
        if (er2) {
          if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            var time = busyTries * 100;
            return setTimeout(function() {
              rimraf_(p2, options, CB);
            }, time);
          }
          if (er2.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function() {
              rimraf_(p2, options, CB);
            }, timeout++);
          }
          if (er2.code === "ENOENT") er2 = null;
        }
        timeout = 0;
        next(er2);
      });
    });
  }
}
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.lstat(p, function(er, st) {
    if (er && er.code === "ENOENT")
      return cb(null);
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb);
    if (st && st.isDirectory())
      return rmdir(p, options, er, cb);
    options.unlink(p, function(er2) {
      if (er2) {
        if (er2.code === "ENOENT")
          return cb(null);
        if (er2.code === "EPERM")
          return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
        if (er2.code === "EISDIR")
          return rmdir(p, options, er2, cb);
      }
      return cb(er2);
    });
  });
}
function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  if (er)
    assert(er instanceof Error);
  options.chmod(p, _0666, function(er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er);
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er);
        else if (stats.isDirectory())
          rmdir(p, options, er, cb);
        else
          options.unlink(p, cb);
      });
  });
}
function fixWinEPERMSync(p, options, er) {
  assert(p);
  assert(options);
  if (er)
    assert(er instanceof Error);
  try {
    options.chmodSync(p, _0666);
  } catch (er2) {
    if (er2.code === "ENOENT")
      return;
    else
      throw er;
  }
  try {
    var stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT")
      return;
    else
      throw er;
  }
  if (stats.isDirectory())
    rmdirSync(p, options, er);
  else
    options.unlinkSync(p);
}
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  if (originalEr)
    assert(originalEr instanceof Error);
  assert(typeof cb === "function");
  options.rmdir(p, function(er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb);
    else if (er && er.code === "ENOTDIR")
      cb(originalEr);
    else
      cb(er);
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, function(er, files) {
    if (er)
      return cb(er);
    var n = files.length;
    if (n === 0)
      return options.rmdir(p, cb);
    var errState;
    files.forEach(function(f) {
      rimraf(path$3.join(p, f), options, function(er2) {
        if (errState)
          return;
        if (er2)
          return cb(errState = er2);
        if (--n === 0)
          options.rmdir(p, cb);
      });
    });
  });
}
function rimrafSync(p, options) {
  options = options || {};
  defaults(options);
  assert(p, "rimraf: missing path");
  assert.equal(typeof p, "string", "rimraf: path should be a string");
  assert(options, "rimraf: missing options");
  assert.equal(typeof options, "object", "rimraf: options should be object");
  var results;
  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p];
  } else {
    try {
      options.lstatSync(p);
      results = [p];
    } catch (er) {
      results = glob.sync(p, options.glob);
    }
  }
  if (!results.length)
    return;
  for (var i = 0; i < results.length; i++) {
    var p = results[i];
    try {
      var st = options.lstatSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er);
    }
    try {
      if (st && st.isDirectory())
        rmdirSync(p, options, null);
      else
        options.unlinkSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
      if (er.code !== "EISDIR")
        throw er;
      rmdirSync(p, options, er);
    }
  }
}
function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  if (originalEr)
    assert(originalEr instanceof Error);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOENT")
      return;
    if (er.code === "ENOTDIR")
      throw originalEr;
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options);
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(function(f) {
    rimrafSync(path$3.join(p, f), options);
  });
  var retries = isWindows ? 100 : 1;
  var i = 0;
  do {
    var threw = true;
    try {
      var ret = options.rmdirSync(p, options);
      threw = false;
      return ret;
    } finally {
      if (++i < retries && threw)
        continue;
    }
  } while (true);
}
var path$2 = require$$1;
var fs$2 = require$$0$2;
var _0777 = parseInt("0777", 8);
var mkdirp = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP(p, opts, f, made) {
  if (typeof opts === "function") {
    f = opts;
    opts = {};
  } else if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$2;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made) made = null;
  var cb = f || /* istanbul ignore next */
  function() {
  };
  p = path$2.resolve(p);
  xfs.mkdir(p, mode, function(er) {
    if (!er) {
      made = made || p;
      return cb(null, made);
    }
    switch (er.code) {
      case "ENOENT":
        if (path$2.dirname(p) === p) return cb(er);
        mkdirP(path$2.dirname(p), opts, function(er2, made2) {
          if (er2) cb(er2, made2);
          else mkdirP(p, opts, cb, made2);
        });
        break;
      default:
        xfs.stat(p, function(er2, stat2) {
          if (er2 || !stat2.isDirectory()) cb(er, made);
          else cb(null, made);
        });
        break;
    }
  });
}
mkdirP.sync = function sync2(p, opts, made) {
  if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$2;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made) made = null;
  p = path$2.resolve(p);
  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case "ENOENT":
        made = sync2(path$2.dirname(p), opts, made);
        sync2(p, opts, made);
        break;
      default:
        var stat2;
        try {
          stat2 = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat2.isDirectory()) throw err0;
        break;
    }
  }
  return made;
};
var collect_1 = collect;
function collect(stream2) {
  if (stream2._collected) return;
  if (stream2._paused) return stream2.on("resume", collect.bind(null, stream2));
  stream2._collected = true;
  stream2.pause();
  stream2.on("data", save);
  stream2.on("end", save);
  var buf = [];
  function save(b) {
    if (typeof b === "string") b = new Buffer(b);
    if (Buffer.isBuffer(b) && !b.length) return;
    buf.push(b);
  }
  stream2.on("entry", saveEntry);
  var entryBuffer = [];
  function saveEntry(e) {
    collect(e);
    entryBuffer.push(e);
  }
  stream2.on("proxy", proxyPause);
  function proxyPause(p) {
    p.pause();
  }
  stream2.pipe = /* @__PURE__ */ function(orig) {
    return function(dest) {
      var e = 0;
      (function unblockEntry() {
        var entry = entryBuffer[e++];
        if (!entry) return resume();
        entry.on("end", unblockEntry);
        if (dest) dest.add(entry);
        else stream2.emit("entry", entry);
      })();
      function resume() {
        stream2.removeListener("entry", saveEntry);
        stream2.removeListener("data", save);
        stream2.removeListener("end", save);
        stream2.pipe = orig;
        if (dest) stream2.pipe(dest);
        buf.forEach(function(b) {
          if (b) stream2.emit("data", b);
          else stream2.emit("end");
        });
        stream2.resume();
      }
      return dest;
    };
  }(stream2.pipe);
}
var dirWriter;
var hasRequiredDirWriter;
function requireDirWriter() {
  if (hasRequiredDirWriter) return dirWriter;
  hasRequiredDirWriter = 1;
  dirWriter = DirWriter;
  var Writer2 = requireWriter();
  var inherits2 = requireInherits();
  var mkdir = mkdirp;
  var path2 = require$$1;
  var collect2 = collect_1;
  inherits2(DirWriter, Writer2);
  function DirWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof DirWriter)) {
      self2.error("DirWriter must be called as constructor.", null, true);
    }
    if (props2.type !== "Directory" || !props2.Directory) {
      self2.error("Non-directory type " + props2.type + " " + JSON.stringify(props2), null, true);
    }
    Writer2.call(this, props2);
  }
  DirWriter.prototype._create = function() {
    var self2 = this;
    mkdir(self2._path, Writer2.dirmode, function(er) {
      if (er) return self2.error(er);
      self2.ready = true;
      self2.emit("ready");
      self2._process();
    });
  };
  DirWriter.prototype.write = function() {
    return true;
  };
  DirWriter.prototype.end = function() {
    this._ended = true;
    this._process();
  };
  DirWriter.prototype.add = function(entry) {
    var self2 = this;
    collect2(entry);
    if (!self2.ready || self2._currentEntry) {
      self2._buffer.push(entry);
      return false;
    }
    if (self2._ended) {
      return self2.error("add after end");
    }
    self2._buffer.push(entry);
    self2._process();
    return this._buffer.length === 0;
  };
  DirWriter.prototype._process = function() {
    var self2 = this;
    if (self2._processing) return;
    var entry = self2._buffer.shift();
    if (!entry) {
      self2.emit("drain");
      if (self2._ended) self2._finish();
      return;
    }
    self2._processing = true;
    self2.emit("entry", entry);
    var p = entry;
    var pp;
    do {
      pp = p._path || p.path;
      if (pp === self2.root._path || pp === self2._path || pp && pp.indexOf(self2._path) === 0) {
        self2._processing = false;
        if (entry._collected) entry.pipe();
        return self2._process();
      }
      p = p.parent;
    } while (p);
    var props2 = {
      parent: self2,
      root: self2.root || self2,
      type: entry.type,
      depth: self2.depth + 1
    };
    pp = entry._path || entry.path || entry.props.path;
    if (entry.parent) {
      pp = pp.substr(entry.parent._path.length + 1);
    }
    props2.path = path2.join(self2.path, path2.join("/", pp));
    props2.filter = self2.filter;
    Object.keys(entry.props).forEach(function(k) {
      if (!props2.hasOwnProperty(k)) {
        props2[k] = entry.props[k];
      }
    });
    var child = self2._currentChild = new Writer2(props2);
    child.on("ready", function() {
      entry.pipe(child);
      entry.resume();
    });
    child.on("error", function(er) {
      if (child._swallowErrors) {
        self2.warn(er);
        child.emit("end");
        child.emit("close");
      } else {
        self2.emit("error", er);
      }
    });
    child.on("close", onend);
    var ended = false;
    function onend() {
      if (ended) return;
      ended = true;
      self2._currentChild = null;
      self2._processing = false;
      self2._process();
    }
  };
  return dirWriter;
}
var linkWriter;
var hasRequiredLinkWriter;
function requireLinkWriter() {
  if (hasRequiredLinkWriter) return linkWriter;
  hasRequiredLinkWriter = 1;
  linkWriter = LinkWriter;
  var fs2 = gracefulFs;
  var Writer2 = requireWriter();
  var inherits2 = requireInherits();
  var path2 = require$$1;
  var rimraf2 = rimraf_1;
  inherits2(LinkWriter, Writer2);
  function LinkWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof LinkWriter)) {
      throw new Error("LinkWriter must be called as constructor.");
    }
    if (!(props2.type === "Link" && props2.Link || props2.type === "SymbolicLink" && props2.SymbolicLink)) {
      throw new Error("Non-link type " + props2.type);
    }
    if (props2.linkpath === "") props2.linkpath = ".";
    if (!props2.linkpath) {
      self2.error("Need linkpath property to create " + props2.type);
    }
    Writer2.call(this, props2);
  }
  LinkWriter.prototype._create = function() {
    var self2 = this;
    var hard = self2.type === "Link" || process.platform === "win32";
    var link = hard ? "link" : "symlink";
    var lp = hard ? path2.resolve(self2.dirname, self2.linkpath) : self2.linkpath;
    if (hard) return clobber(self2, lp, link);
    fs2.readlink(self2._path, function(er, p) {
      if (p && p === lp) return finish2(self2);
      clobber(self2, lp, link);
    });
  };
  function clobber(self2, lp, link) {
    rimraf2(self2._path, function(er) {
      if (er) return self2.error(er);
      create(self2, lp, link);
    });
  }
  function create(self2, lp, link) {
    fs2[link](lp, self2._path, function(er) {
      if (er) {
        if ((er.code === "ENOENT" || er.code === "EACCES" || er.code === "EPERM") && process.platform === "win32") {
          self2.ready = true;
          self2.emit("ready");
          self2.emit("end");
          self2.emit("close");
          self2.end = self2._finish = function() {
          };
        } else return self2.error(er);
      }
      finish2(self2);
    });
  }
  function finish2(self2) {
    self2.ready = true;
    self2.emit("ready");
    if (self2._ended && !self2._finished) self2._finish();
  }
  LinkWriter.prototype.end = function() {
    this._ended = true;
    if (this.ready) {
      this._finished = true;
      this._finish();
    }
  };
  return linkWriter;
}
var fileWriter;
var hasRequiredFileWriter;
function requireFileWriter() {
  if (hasRequiredFileWriter) return fileWriter;
  hasRequiredFileWriter = 1;
  fileWriter = FileWriter;
  var fs2 = gracefulFs;
  var Writer2 = requireWriter();
  var inherits2 = requireInherits();
  var EOF = {};
  inherits2(FileWriter, Writer2);
  function FileWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof FileWriter)) {
      throw new Error("FileWriter must be called as constructor.");
    }
    if (props2.type !== "File" || !props2.File) {
      throw new Error("Non-file type " + props2.type);
    }
    self2._buffer = [];
    self2._bytesWritten = 0;
    Writer2.call(this, props2);
  }
  FileWriter.prototype._create = function() {
    var self2 = this;
    if (self2._stream) return;
    var so = {};
    if (self2.props.flags) so.flags = self2.props.flags;
    so.mode = Writer2.filemode;
    if (self2._old && self2._old.blksize) so.bufferSize = self2._old.blksize;
    self2._stream = fs2.createWriteStream(self2._path, so);
    self2._stream.on("open", function() {
      self2.ready = true;
      self2._buffer.forEach(function(c2) {
        if (c2 === EOF) self2._stream.end();
        else self2._stream.write(c2);
      });
      self2.emit("ready");
      self2.emit("drain");
    });
    self2._stream.on("error", function(er) {
      self2.emit("error", er);
    });
    self2._stream.on("drain", function() {
      self2.emit("drain");
    });
    self2._stream.on("close", function() {
      self2._finish();
    });
  };
  FileWriter.prototype.write = function(c2) {
    var self2 = this;
    self2._bytesWritten += c2.length;
    if (!self2.ready) {
      if (!Buffer.isBuffer(c2) && typeof c2 !== "string") {
        throw new Error("invalid write data");
      }
      self2._buffer.push(c2);
      return false;
    }
    var ret = self2._stream.write(c2);
    if (ret === false && self2._stream._queue) {
      return self2._stream._queue.length <= 2;
    } else {
      return ret;
    }
  };
  FileWriter.prototype.end = function(c2) {
    var self2 = this;
    if (c2) self2.write(c2);
    if (!self2.ready) {
      self2._buffer.push(EOF);
      return false;
    }
    return self2._stream.end();
  };
  FileWriter.prototype._finish = function() {
    var self2 = this;
    if (typeof self2.size === "number" && self2._bytesWritten !== self2.size) {
      self2.error(
        "Did not get expected byte count.\nexpect: " + self2.size + "\nactual: " + self2._bytesWritten
      );
    }
    Writer2.prototype._finish.call(self2);
  };
  return fileWriter;
}
var proxyWriter;
var hasRequiredProxyWriter;
function requireProxyWriter() {
  if (hasRequiredProxyWriter) return proxyWriter;
  hasRequiredProxyWriter = 1;
  proxyWriter = ProxyWriter;
  var Writer2 = requireWriter();
  var getType2 = getType_1;
  var inherits2 = requireInherits();
  var collect2 = collect_1;
  var fs2 = require$$0$2;
  inherits2(ProxyWriter, Writer2);
  function ProxyWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof ProxyWriter)) {
      throw new Error("ProxyWriter must be called as constructor.");
    }
    self2.props = props2;
    self2._needDrain = false;
    Writer2.call(self2, props2);
  }
  ProxyWriter.prototype._stat = function() {
    var self2 = this;
    var props2 = self2.props;
    var stat2 = props2.follow ? "stat" : "lstat";
    fs2[stat2](props2.path, function(er, current) {
      var type;
      if (er || !current) {
        type = "File";
      } else {
        type = getType2(current);
      }
      props2[type] = true;
      props2.type = self2.type = type;
      self2._old = current;
      self2._addProxy(Writer2(props2, current));
    });
  };
  ProxyWriter.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxy) {
      return self2.error("proxy already set");
    }
    self2._proxy = proxy;
    [
      "ready",
      "error",
      "close",
      "pipe",
      "drain",
      "warn"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    var calls = self2._buffer;
    calls.forEach(function(c2) {
      proxy[c2[0]].apply(proxy, c2[1]);
    });
    self2._buffer.length = 0;
    if (self2._needsDrain) self2.emit("drain");
  };
  ProxyWriter.prototype.add = function(entry) {
    collect2(entry);
    if (!this._proxy) {
      this._buffer.push(["add", [entry]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.add(entry);
  };
  ProxyWriter.prototype.write = function(c2) {
    if (!this._proxy) {
      this._buffer.push(["write", [c2]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.write(c2);
  };
  ProxyWriter.prototype.end = function(c2) {
    if (!this._proxy) {
      this._buffer.push(["end", [c2]]);
      return false;
    }
    return this._proxy.end(c2);
  };
  return proxyWriter;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  writer = Writer2;
  var fs2 = gracefulFs;
  var inherits2 = requireInherits();
  var rimraf2 = rimraf_1;
  var mkdir = mkdirp;
  var path2 = require$$1;
  var umask = process.platform === "win32" ? 0 : process.umask();
  var getType2 = getType_1;
  var Abstract2 = abstract;
  inherits2(Writer2, Abstract2);
  Writer2.dirmode = parseInt("0777", 8) & ~umask;
  Writer2.filemode = parseInt("0666", 8) & ~umask;
  var DirWriter = requireDirWriter();
  var LinkWriter = requireLinkWriter();
  var FileWriter = requireFileWriter();
  var ProxyWriter = requireProxyWriter();
  function Writer2(props2, current) {
    var self2 = this;
    if (typeof props2 === "string") {
      props2 = { path: props2 };
    }
    var type = getType2(props2);
    var ClassType = Writer2;
    switch (type) {
      case "Directory":
        ClassType = DirWriter;
        break;
      case "File":
        ClassType = FileWriter;
        break;
      case "Link":
      case "SymbolicLink":
        ClassType = LinkWriter;
        break;
      case null:
      default:
        ClassType = ProxyWriter;
        break;
    }
    if (!(self2 instanceof ClassType)) return new ClassType(props2);
    Abstract2.call(self2);
    if (!props2.path) self2.error("Must provide a path", null, true);
    self2.type = props2.type;
    self2.props = props2;
    self2.depth = props2.depth || 0;
    self2.clobber = props2.clobber === false ? props2.clobber : true;
    self2.parent = props2.parent || null;
    self2.root = props2.root || props2.parent && props2.parent.root || self2;
    self2._path = self2.path = path2.resolve(props2.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = path2.basename(props2.path);
    self2.dirname = path2.dirname(props2.path);
    self2.linkpath = props2.linkpath || null;
    props2.parent = props2.root = null;
    self2.size = props2.size;
    if (typeof props2.mode === "string") {
      props2.mode = parseInt(props2.mode, 8);
    }
    self2.readable = false;
    self2.writable = true;
    self2._buffer = [];
    self2.ready = false;
    self2.filter = typeof props2.filter === "function" ? props2.filter : null;
    self2._stat(current);
  }
  Writer2.prototype._create = function() {
    var self2 = this;
    fs2[self2.props.follow ? "stat" : "lstat"](self2._path, function(er) {
      if (er) {
        return self2.warn("Cannot create " + self2._path + "\nUnsupported type: " + self2.type, "ENOTSUP");
      }
      self2._finish();
    });
  };
  Writer2.prototype._stat = function(current) {
    var self2 = this;
    var props2 = self2.props;
    var stat2 = props2.follow ? "stat" : "lstat";
    var who = self2._proxy || self2;
    if (current) statCb(null, current);
    else fs2[stat2](self2._path, statCb);
    function statCb(er, current2) {
      if (self2.filter && !self2.filter.call(who, who, current2)) {
        self2._aborted = true;
        self2.emit("end");
        self2.emit("close");
        return;
      }
      if (er || !current2) {
        return create(self2);
      }
      self2._old = current2;
      var currentType = getType2(current2);
      if (currentType !== self2.type || self2.type === "File" && current2.nlink > 1) {
        return rimraf2(self2._path, function(er2) {
          if (er2) return self2.error(er2);
          self2._old = null;
          create(self2);
        });
      }
      create(self2);
    }
  };
  function create(self2) {
    mkdir(path2.dirname(self2._path), Writer2.dirmode, function(er, made) {
      if (er) return self2.error(er);
      self2._madeDir = made;
      return self2._create();
    });
  }
  function endChmod(self2, want, current, path3, cb) {
    var wantMode = want.mode;
    var chmod = want.follow || self2.type !== "SymbolicLink" ? "chmod" : "lchmod";
    if (!fs2[chmod]) return cb();
    if (typeof wantMode !== "number") return cb();
    var curMode = current.mode & parseInt("0777", 8);
    wantMode = wantMode & parseInt("0777", 8);
    if (wantMode === curMode) return cb();
    fs2[chmod](path3, wantMode, cb);
  }
  function endChown(self2, want, current, path3, cb) {
    if (process.platform === "win32") return cb();
    if (!process.getuid || process.getuid() !== 0) return cb();
    if (typeof want.uid !== "number" && typeof want.gid !== "number") return cb();
    if (current.uid === want.uid && current.gid === want.gid) return cb();
    var chown = self2.props.follow || self2.type !== "SymbolicLink" ? "chown" : "lchown";
    if (!fs2[chown]) return cb();
    if (typeof want.uid !== "number") want.uid = current.uid;
    if (typeof want.gid !== "number") want.gid = current.gid;
    fs2[chown](path3, want.uid, want.gid, cb);
  }
  function endUtimes(self2, want, current, path3, cb) {
    if (!fs2.utimes || process.platform === "win32") return cb();
    var utimes = want.follow || self2.type !== "SymbolicLink" ? "utimes" : "lutimes";
    if (utimes === "lutimes" && !fs2[utimes]) {
      utimes = "utimes";
    }
    if (!fs2[utimes]) return cb();
    var curA = current.atime;
    var curM = current.mtime;
    var meA = want.atime;
    var meM = want.mtime;
    if (meA === void 0) meA = curA;
    if (meM === void 0) meM = curM;
    if (!isDate(meA)) meA = new Date(meA);
    if (!isDate(meM)) meA = new Date(meM);
    if (meA.getTime() === curA.getTime() && meM.getTime() === curM.getTime()) return cb();
    fs2[utimes](path3, meA, meM, cb);
  }
  Writer2.prototype._finish = function() {
    var self2 = this;
    if (self2._finishing) return;
    self2._finishing = true;
    var todo = 0;
    var errState = null;
    var done = false;
    if (self2._old) {
      self2._old.atime = /* @__PURE__ */ new Date(0);
      self2._old.mtime = /* @__PURE__ */ new Date(0);
      setProps(self2._old);
    } else {
      var stat2 = self2.props.follow ? "stat" : "lstat";
      fs2[stat2](self2._path, function(er, current) {
        if (er) {
          if (er.code === "ENOENT" && (self2.type === "Link" || self2.type === "SymbolicLink") && process.platform === "win32") {
            self2.ready = true;
            self2.emit("ready");
            self2.emit("end");
            self2.emit("close");
            self2.end = self2._finish = function() {
            };
            return;
          } else return self2.error(er);
        }
        setProps(self2._old = current);
      });
    }
    return;
    function setProps(current) {
      todo += 3;
      endChmod(self2, self2.props, current, self2._path, next("chmod"));
      endChown(self2, self2.props, current, self2._path, next("chown"));
      endUtimes(self2, self2.props, current, self2._path, next("utimes"));
    }
    function next(what) {
      return function(er) {
        if (errState) return;
        if (er) {
          er.fstream_finish_call = what;
          return self2.error(errState = er);
        }
        if (--todo > 0) return;
        if (done) return;
        done = true;
        if (!self2._madeDir) return end2();
        else endMadeDir(self2, self2._path, end2);
        function end2(er2) {
          if (er2) {
            er2.fstream_finish_call = "setupMadeDir";
            return self2.error(er2);
          }
          self2.emit("end");
          self2.emit("close");
        }
      };
    }
  };
  function endMadeDir(self2, p, cb) {
    var made = self2._madeDir;
    var d = path2.dirname(p);
    endMadeDir_(self2, d, function(er) {
      if (er) return cb(er);
      if (d === made) {
        return cb();
      }
      endMadeDir(self2, d, cb);
    });
  }
  function endMadeDir_(self2, p, cb) {
    var dirProps = {};
    Object.keys(self2.props).forEach(function(k) {
      dirProps[k] = self2.props[k];
      if (k === "mode" && self2.type !== "Directory") {
        dirProps[k] = dirProps[k] | parseInt("0111", 8);
      }
    });
    var todo = 3;
    var errState = null;
    fs2.stat(p, function(er, current) {
      if (er) return cb(errState = er);
      endChmod(self2, dirProps, current, p, next);
      endChown(self2, dirProps, current, p, next);
      endUtimes(self2, dirProps, current, p, next);
    });
    function next(er) {
      if (errState) return;
      if (er) return cb(errState = er);
      if (--todo === 0) return cb();
    }
  }
  Writer2.prototype.pipe = function() {
    this.error("Can't pipe from writable stream");
  };
  Writer2.prototype.add = function() {
    this.error("Can't add to non-Directory type");
  };
  Writer2.prototype.write = function() {
    return true;
  };
  function objectToString2(d) {
    return Object.prototype.toString.call(d);
  }
  function isDate(d) {
    return typeof d === "object" && objectToString2(d) === "[object Date]";
  }
  return writer;
}
(function(exports) {
  exports.Abstract = abstract;
  exports.Reader = requireReader();
  exports.Writer = requireWriter();
  exports.File = {
    Reader: requireFileReader(),
    Writer: requireFileWriter()
  };
  exports.Dir = {
    Reader: requireDirReader(),
    Writer: requireDirWriter()
  };
  exports.Link = {
    Reader: requireLinkReader(),
    Writer: requireLinkWriter()
  };
  exports.Proxy = {
    Reader: requireProxyReader(),
    Writer: requireProxyWriter()
  };
  exports.Reader.Dir = exports.DirReader = exports.Dir.Reader;
  exports.Reader.File = exports.FileReader = exports.File.Reader;
  exports.Reader.Link = exports.LinkReader = exports.Link.Reader;
  exports.Reader.Proxy = exports.ProxyReader = exports.Proxy.Reader;
  exports.Writer.Dir = exports.DirWriter = exports.Dir.Writer;
  exports.Writer.File = exports.FileWriter = exports.File.Writer;
  exports.Writer.Link = exports.LinkWriter = exports.Link.Writer;
  exports.Writer.Proxy = exports.ProxyWriter = exports.Proxy.Writer;
  exports.collect = collect_1;
})(fstream);
var extract = Extract;
var Parse = parse;
var Writer$1 = fstream.Writer;
var path$1 = require$$1;
var stream = require$$0$1;
var duplexer2 = duplexer2Exports;
var Promise$4 = bluebird_1;
function Extract(opts) {
  opts.path = path$1.resolve(path$1.normalize(opts.path));
  var parser2 = new Parse(opts);
  var outStream = new stream.Writable({ objectMode: true });
  outStream._write = function(entry, encoding, cb) {
    if (entry.type == "Directory") return cb();
    var extractPath = path$1.join(opts.path, entry.path);
    if (extractPath.indexOf(opts.path) != 0) {
      return cb();
    }
    const writer2 = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer$1({ path: extractPath });
    entry.pipe(writer2).on("error", cb).on("close", cb);
  };
  var extract2 = duplexer2(parser2, outStream);
  parser2.once("crx-header", function(crxHeader) {
    extract2.crxHeader = crxHeader;
  });
  parser2.pipe(outStream).on("finish", function() {
    extract2.emit("close");
  });
  extract2.promise = function() {
    return new Promise$4(function(resolve2, reject2) {
      extract2.on("close", resolve2);
      extract2.on("error", reject2);
    });
  };
  return extract2;
}
var BigInteger = { exports: {} };
(function(module) {
  var bigInt2 = function(undefined$1) {
    var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
    var supportsNativeBigInt = typeof BigInt === "function";
    function Integer(v, radix, alphabet, caseSensitive) {
      if (typeof v === "undefined") return Integer[0];
      if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
      return parseValue(v);
    }
    function BigInteger2(value, sign) {
      this.value = value;
      this.sign = sign;
      this.isSmall = false;
    }
    BigInteger2.prototype = Object.create(Integer.prototype);
    function SmallInteger(value) {
      this.value = value;
      this.sign = value < 0;
      this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);
    function NativeBigInt(value) {
      this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);
    function isPrecise(n) {
      return -9007199254740992 < n && n < MAX_INT;
    }
    function smallToArray(n) {
      if (n < 1e7)
        return [n];
      if (n < 1e14)
        return [n % 1e7, Math.floor(n / 1e7)];
      return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }
    function arrayToSmall(arr) {
      trim(arr);
      var length = arr.length;
      if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
        switch (length) {
          case 0:
            return 0;
          case 1:
            return arr[0];
          case 2:
            return arr[0] + arr[1] * BASE;
          default:
            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
        }
      }
      return arr;
    }
    function trim(v) {
      var i2 = v.length;
      while (v[--i2] === 0) ;
      v.length = i2 + 1;
    }
    function createArray(length) {
      var x = new Array(length);
      var i2 = -1;
      while (++i2 < length) {
        x[i2] = 0;
      }
      return x;
    }
    function truncate(n) {
      if (n > 0) return Math.floor(n);
      return Math.ceil(n);
    }
    function add(a, b) {
      var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i2;
      for (i2 = 0; i2 < l_b; i2++) {
        sum = a[i2] + b[i2] + carry;
        carry = sum >= base ? 1 : 0;
        r[i2] = sum - carry * base;
      }
      while (i2 < l_a) {
        sum = a[i2] + carry;
        carry = sum === base ? 1 : 0;
        r[i2++] = sum - carry * base;
      }
      if (carry > 0) r.push(carry);
      return r;
    }
    function addAny(a, b) {
      if (a.length >= b.length) return add(a, b);
      return add(b, a);
    }
    function addSmall(a, carry) {
      var l = a.length, r = new Array(l), base = BASE, sum, i2;
      for (i2 = 0; i2 < l; i2++) {
        sum = a[i2] - base + carry;
        carry = Math.floor(sum / base);
        r[i2] = sum - carry * base;
        carry += 1;
      }
      while (carry > 0) {
        r[i2++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    BigInteger2.prototype.add = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.subtract(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall) {
        return new BigInteger2(addSmall(a, Math.abs(b)), this.sign);
      }
      return new BigInteger2(addAny(a, b), this.sign);
    };
    BigInteger2.prototype.plus = BigInteger2.prototype.add;
    SmallInteger.prototype.add = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.subtract(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        if (isPrecise(a + b)) return new SmallInteger(a + b);
        b = smallToArray(Math.abs(b));
      }
      return new BigInteger2(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;
    NativeBigInt.prototype.add = function(v) {
      return new NativeBigInt(this.value + parseValue(v).value);
    };
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
    function subtract(a, b) {
      var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference2;
      for (i2 = 0; i2 < b_l; i2++) {
        difference2 = a[i2] - borrow - b[i2];
        if (difference2 < 0) {
          difference2 += base;
          borrow = 1;
        } else borrow = 0;
        r[i2] = difference2;
      }
      for (i2 = b_l; i2 < a_l; i2++) {
        difference2 = a[i2] - borrow;
        if (difference2 < 0) difference2 += base;
        else {
          r[i2++] = difference2;
          break;
        }
        r[i2] = difference2;
      }
      for (; i2 < a_l; i2++) {
        r[i2] = a[i2];
      }
      trim(r);
      return r;
    }
    function subtractAny(a, b, sign) {
      var value;
      if (compareAbs(a, b) >= 0) {
        value = subtract(a, b);
      } else {
        value = subtract(b, a);
        sign = !sign;
      }
      value = arrayToSmall(value);
      if (typeof value === "number") {
        if (sign) value = -value;
        return new SmallInteger(value);
      }
      return new BigInteger2(value, sign);
    }
    function subtractSmall(a, b, sign) {
      var l = a.length, r = new Array(l), carry = -b, base = BASE, i2, difference2;
      for (i2 = 0; i2 < l; i2++) {
        difference2 = a[i2] + carry;
        carry = Math.floor(difference2 / base);
        difference2 %= base;
        r[i2] = difference2 < 0 ? difference2 + base : difference2;
      }
      r = arrayToSmall(r);
      if (typeof r === "number") {
        if (sign) r = -r;
        return new SmallInteger(r);
      }
      return new BigInteger2(r, sign);
    }
    BigInteger2.prototype.subtract = function(v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.add(n.negate());
      }
      var a = this.value, b = n.value;
      if (n.isSmall)
        return subtractSmall(a, Math.abs(b), this.sign);
      return subtractAny(a, b, this.sign);
    };
    BigInteger2.prototype.minus = BigInteger2.prototype.subtract;
    SmallInteger.prototype.subtract = function(v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.add(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        return new SmallInteger(a - b);
      }
      return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
    NativeBigInt.prototype.subtract = function(v) {
      return new NativeBigInt(this.value - parseValue(v).value);
    };
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
    BigInteger2.prototype.negate = function() {
      return new BigInteger2(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function() {
      var sign = this.sign;
      var small = new SmallInteger(-this.value);
      small.sign = !sign;
      return small;
    };
    NativeBigInt.prototype.negate = function() {
      return new NativeBigInt(-this.value);
    };
    BigInteger2.prototype.abs = function() {
      return new BigInteger2(this.value, false);
    };
    SmallInteger.prototype.abs = function() {
      return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function() {
      return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };
    function multiplyLong(a, b) {
      var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i2, a_i, b_j;
      for (i2 = 0; i2 < a_l; ++i2) {
        a_i = a[i2];
        for (var j = 0; j < b_l; ++j) {
          b_j = b[j];
          product = a_i * b_j + r[i2 + j];
          carry = Math.floor(product / base);
          r[i2 + j] = product - carry * base;
          r[i2 + j + 1] += carry;
        }
      }
      trim(r);
      return r;
    }
    function multiplySmall(a, b) {
      var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i2;
      for (i2 = 0; i2 < l; i2++) {
        product = a[i2] * b + carry;
        carry = Math.floor(product / base);
        r[i2] = product - carry * base;
      }
      while (carry > 0) {
        r[i2++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    function shiftLeft(x, n) {
      var r = [];
      while (n-- > 0) r.push(0);
      return r.concat(x);
    }
    function multiplyKaratsuba(x, y) {
      var n = Math.max(x.length, y.length);
      if (n <= 30) return multiplyLong(x, y);
      n = Math.ceil(n / 2);
      var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c2 = y.slice(0, n);
      var ac = multiplyKaratsuba(a, c2), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c2, d));
      var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
      trim(product);
      return product;
    }
    function useKaratsuba(l1, l2) {
      return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
    }
    BigInteger2.prototype.multiply = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
      if (n.isSmall) {
        if (b === 0) return Integer[0];
        if (b === 1) return this;
        if (b === -1) return this.negate();
        abs = Math.abs(b);
        if (abs < BASE) {
          return new BigInteger2(multiplySmall(a, abs), sign);
        }
        b = smallToArray(abs);
      }
      if (useKaratsuba(a.length, b.length))
        return new BigInteger2(multiplyKaratsuba(a, b), sign);
      return new BigInteger2(multiplyLong(a, b), sign);
    };
    BigInteger2.prototype.times = BigInteger2.prototype.multiply;
    function multiplySmallAndArray(a, b, sign) {
      if (a < BASE) {
        return new BigInteger2(multiplySmall(b, a), sign);
      }
      return new BigInteger2(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function(a) {
      if (isPrecise(a.value * this.value)) {
        return new SmallInteger(a.value * this.value);
      }
      return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger2.prototype._multiplyBySmall = function(a) {
      if (a.value === 0) return Integer[0];
      if (a.value === 1) return this;
      if (a.value === -1) return this.negate();
      return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function(v) {
      return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;
    NativeBigInt.prototype.multiply = function(v) {
      return new NativeBigInt(this.value * parseValue(v).value);
    };
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
    function square(a) {
      var l = a.length, r = createArray(l + l), base = BASE, product, carry, i2, a_i, a_j;
      for (i2 = 0; i2 < l; i2++) {
        a_i = a[i2];
        carry = 0 - a_i * a_i;
        for (var j = i2; j < l; j++) {
          a_j = a[j];
          product = 2 * (a_i * a_j) + r[i2 + j] + carry;
          carry = Math.floor(product / base);
          r[i2 + j] = product - carry * base;
        }
        r[i2 + l] = carry;
      }
      trim(r);
      return r;
    }
    BigInteger2.prototype.square = function() {
      return new BigInteger2(square(this.value), false);
    };
    SmallInteger.prototype.square = function() {
      var value = this.value * this.value;
      if (isPrecise(value)) return new SmallInteger(value);
      return new BigInteger2(square(smallToArray(Math.abs(this.value))), false);
    };
    NativeBigInt.prototype.square = function(v) {
      return new NativeBigInt(this.value * this.value);
    };
    function divMod1(a, b) {
      var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;
      if (remainder.length <= a_l) remainder.push(0);
      divisor.push(0);
      divisorMostSignificantDigit = divisor[b_l - 1];
      for (shift = a_l - b_l; shift >= 0; shift--) {
        quotientDigit = base - 1;
        if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
          quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
        }
        carry = 0;
        borrow = 0;
        l = divisor.length;
        for (i2 = 0; i2 < l; i2++) {
          carry += quotientDigit * divisor[i2];
          q = Math.floor(carry / base);
          borrow += remainder[shift + i2] - (carry - q * base);
          carry = q;
          if (borrow < 0) {
            remainder[shift + i2] = borrow + base;
            borrow = -1;
          } else {
            remainder[shift + i2] = borrow;
            borrow = 0;
          }
        }
        while (borrow !== 0) {
          quotientDigit -= 1;
          carry = 0;
          for (i2 = 0; i2 < l; i2++) {
            carry += remainder[shift + i2] - base + divisor[i2];
            if (carry < 0) {
              remainder[shift + i2] = carry + base;
              carry = 0;
            } else {
              remainder[shift + i2] = carry;
              carry = 1;
            }
          }
          borrow += carry;
        }
        result[shift] = quotientDigit;
      }
      remainder = divModSmall(remainder, lambda)[0];
      return [arrayToSmall(result), arrayToSmall(remainder)];
    }
    function divMod2(a, b) {
      var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
      while (a_l) {
        part.unshift(a[--a_l]);
        trim(part);
        if (compareAbs(part, b) < 0) {
          result.push(0);
          continue;
        }
        xlen = part.length;
        highx = part[xlen - 1] * base + part[xlen - 2];
        highy = b[b_l - 1] * base + b[b_l - 2];
        if (xlen > b_l) {
          highx = (highx + 1) * base;
        }
        guess = Math.ceil(highx / highy);
        do {
          check = multiplySmall(b, guess);
          if (compareAbs(check, part) <= 0) break;
          guess--;
        } while (guess);
        result.push(guess);
        part = subtract(part, check);
      }
      result.reverse();
      return [arrayToSmall(result), arrayToSmall(part)];
    }
    function divModSmall(value, lambda) {
      var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
      remainder = 0;
      for (i2 = length - 1; i2 >= 0; --i2) {
        divisor = remainder * base + value[i2];
        q = truncate(divisor / lambda);
        remainder = divisor - q * lambda;
        quotient[i2] = q | 0;
      }
      return [quotient, remainder | 0];
    }
    function divModAny(self2, v) {
      var value, n = parseValue(v);
      if (supportsNativeBigInt) {
        return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
      }
      var a = self2.value, b = n.value;
      var quotient;
      if (b === 0) throw new Error("Cannot divide by zero");
      if (self2.isSmall) {
        if (n.isSmall) {
          return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
        }
        return [Integer[0], self2];
      }
      if (n.isSmall) {
        if (b === 1) return [self2, Integer[0]];
        if (b == -1) return [self2.negate(), Integer[0]];
        var abs = Math.abs(b);
        if (abs < BASE) {
          value = divModSmall(a, abs);
          quotient = arrayToSmall(value[0]);
          var remainder = value[1];
          if (self2.sign) remainder = -remainder;
          if (typeof quotient === "number") {
            if (self2.sign !== n.sign) quotient = -quotient;
            return [new SmallInteger(quotient), new SmallInteger(remainder)];
          }
          return [new BigInteger2(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
        }
        b = smallToArray(abs);
      }
      var comparison = compareAbs(a, b);
      if (comparison === -1) return [Integer[0], self2];
      if (comparison === 0) return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
      if (a.length + b.length <= 200)
        value = divMod1(a, b);
      else value = divMod2(a, b);
      quotient = value[0];
      var qSign = self2.sign !== n.sign, mod = value[1], mSign = self2.sign;
      if (typeof quotient === "number") {
        if (qSign) quotient = -quotient;
        quotient = new SmallInteger(quotient);
      } else quotient = new BigInteger2(quotient, qSign);
      if (typeof mod === "number") {
        if (mSign) mod = -mod;
        mod = new SmallInteger(mod);
      } else mod = new BigInteger2(mod, mSign);
      return [quotient, mod];
    }
    BigInteger2.prototype.divmod = function(v) {
      var result = divModAny(this, v);
      return {
        quotient: result[0],
        remainder: result[1]
      };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger2.prototype.divmod;
    BigInteger2.prototype.divide = function(v) {
      return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
      return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger2.prototype.over = BigInteger2.prototype.divide;
    BigInteger2.prototype.mod = function(v) {
      return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
      return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger2.prototype.remainder = BigInteger2.prototype.mod;
    BigInteger2.prototype.pow = function(v) {
      var n = parseValue(v), a = this.value, b = n.value, value, x, y;
      if (b === 0) return Integer[1];
      if (a === 0) return Integer[0];
      if (a === 1) return Integer[1];
      if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
      if (n.sign) {
        return Integer[0];
      }
      if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
      if (this.isSmall) {
        if (isPrecise(value = Math.pow(a, b)))
          return new SmallInteger(truncate(value));
      }
      x = this;
      y = Integer[1];
      while (true) {
        if (b & true) {
          y = y.times(x);
          --b;
        }
        if (b === 0) break;
        b /= 2;
        x = x.square();
      }
      return y;
    };
    SmallInteger.prototype.pow = BigInteger2.prototype.pow;
    NativeBigInt.prototype.pow = function(v) {
      var n = parseValue(v);
      var a = this.value, b = n.value;
      var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
      if (b === _0) return Integer[1];
      if (a === _0) return Integer[0];
      if (a === _1) return Integer[1];
      if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
      if (n.isNegative()) return new NativeBigInt(_0);
      var x = this;
      var y = Integer[1];
      while (true) {
        if ((b & _1) === _1) {
          y = y.times(x);
          --b;
        }
        if (b === _0) break;
        b /= _2;
        x = x.square();
      }
      return y;
    };
    BigInteger2.prototype.modPow = function(exp, mod) {
      exp = parseValue(exp);
      mod = parseValue(mod);
      if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
      var r = Integer[1], base = this.mod(mod);
      if (exp.isNegative()) {
        exp = exp.multiply(Integer[-1]);
        base = base.modInv(mod);
      }
      while (exp.isPositive()) {
        if (base.isZero()) return Integer[0];
        if (exp.isOdd()) r = r.multiply(base).mod(mod);
        exp = exp.divide(2);
        base = base.square().mod(mod);
      }
      return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger2.prototype.modPow;
    function compareAbs(a, b) {
      if (a.length !== b.length) {
        return a.length > b.length ? 1 : -1;
      }
      for (var i2 = a.length - 1; i2 >= 0; i2--) {
        if (a[i2] !== b[i2]) return a[i2] > b[i2] ? 1 : -1;
      }
      return 0;
    }
    BigInteger2.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall) return 1;
      return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function(v) {
      var n = parseValue(v), a = Math.abs(this.value), b = n.value;
      if (n.isSmall) {
        b = Math.abs(b);
        return a === b ? 0 : a > b ? 1 : -1;
      }
      return -1;
    };
    NativeBigInt.prototype.compareAbs = function(v) {
      var a = this.value;
      var b = parseValue(v).value;
      a = a >= 0 ? a : -a;
      b = b >= 0 ? b : -b;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    BigInteger2.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (this.sign !== n.sign) {
        return n.sign ? 1 : -1;
      }
      if (n.isSmall) {
        return this.sign ? -1 : 1;
      }
      return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger2.prototype.compareTo = BigInteger2.prototype.compare;
    SmallInteger.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v), a = this.value, b = n.value;
      if (n.isSmall) {
        return a == b ? 0 : a > b ? 1 : -1;
      }
      if (a < 0 !== n.sign) {
        return a < 0 ? -1 : 1;
      }
      return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
    NativeBigInt.prototype.compare = function(v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var a = this.value;
      var b = parseValue(v).value;
      return a === b ? 0 : a > b ? 1 : -1;
    };
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
    BigInteger2.prototype.equals = function(v) {
      return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger2.prototype.eq = BigInteger2.prototype.equals;
    BigInteger2.prototype.notEquals = function(v) {
      return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger2.prototype.neq = BigInteger2.prototype.notEquals;
    BigInteger2.prototype.greater = function(v) {
      return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger2.prototype.gt = BigInteger2.prototype.greater;
    BigInteger2.prototype.lesser = function(v) {
      return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger2.prototype.lt = BigInteger2.prototype.lesser;
    BigInteger2.prototype.greaterOrEquals = function(v) {
      return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger2.prototype.geq = BigInteger2.prototype.greaterOrEquals;
    BigInteger2.prototype.lesserOrEquals = function(v) {
      return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger2.prototype.leq = BigInteger2.prototype.lesserOrEquals;
    BigInteger2.prototype.isEven = function() {
      return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function() {
      return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function() {
      return (this.value & BigInt(1)) === BigInt(0);
    };
    BigInteger2.prototype.isOdd = function() {
      return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function() {
      return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function() {
      return (this.value & BigInt(1)) === BigInt(1);
    };
    BigInteger2.prototype.isPositive = function() {
      return !this.sign;
    };
    SmallInteger.prototype.isPositive = function() {
      return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
    BigInteger2.prototype.isNegative = function() {
      return this.sign;
    };
    SmallInteger.prototype.isNegative = function() {
      return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
    BigInteger2.prototype.isUnit = function() {
      return false;
    };
    SmallInteger.prototype.isUnit = function() {
      return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function() {
      return this.abs().value === BigInt(1);
    };
    BigInteger2.prototype.isZero = function() {
      return false;
    };
    SmallInteger.prototype.isZero = function() {
      return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function() {
      return this.value === BigInt(0);
    };
    BigInteger2.prototype.isDivisibleBy = function(v) {
      var n = parseValue(v);
      if (n.isZero()) return false;
      if (n.isUnit()) return true;
      if (n.compareAbs(2) === 0) return this.isEven();
      return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger2.prototype.isDivisibleBy;
    function isBasicPrime(v) {
      var n = v.abs();
      if (n.isUnit()) return false;
      if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
      if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
      if (n.lesser(49)) return true;
    }
    function millerRabinTest(n, a) {
      var nPrev = n.prev(), b = nPrev, r = 0, d, i2, x;
      while (b.isEven()) b = b.divide(2), r++;
      next: for (i2 = 0; i2 < a.length; i2++) {
        if (n.lesser(a[i2])) continue;
        x = bigInt2(a[i2]).modPow(b, n);
        if (x.isUnit() || x.equals(nPrev)) continue;
        for (d = r - 1; d != 0; d--) {
          x = x.square().mod(n);
          if (x.isUnit()) return false;
          if (x.equals(nPrev)) continue next;
        }
        return false;
      }
      return true;
    }
    BigInteger2.prototype.isPrime = function(strict) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var bits = n.bitLength();
      if (bits <= 64)
        return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
      var logN = Math.log(2) * bits.toJSNumber();
      var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
      for (var a = [], i2 = 0; i2 < t; i2++) {
        a.push(bigInt2(i2 + 2));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger2.prototype.isPrime;
    BigInteger2.prototype.isProbablePrime = function(iterations, rng2) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var t = iterations === undefined$1 ? 5 : iterations;
      for (var a = [], i2 = 0; i2 < t; i2++) {
        a.push(bigInt2.randBetween(2, n.minus(2), rng2));
      }
      return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger2.prototype.isProbablePrime;
    BigInteger2.prototype.modInv = function(n) {
      var t = bigInt2.zero, newT = bigInt2.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
      while (!newR.isZero()) {
        q = r.divide(newR);
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT.subtract(q.multiply(newT));
        newR = lastR.subtract(q.multiply(newR));
      }
      if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
      if (t.compare(0) === -1) {
        t = t.add(n);
      }
      if (this.isNegative()) {
        return t.negate();
      }
      return t;
    };
    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger2.prototype.modInv;
    BigInteger2.prototype.next = function() {
      var value = this.value;
      if (this.sign) {
        return subtractSmall(value, 1, this.sign);
      }
      return new BigInteger2(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function() {
      var value = this.value;
      if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
      return new BigInteger2(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function() {
      return new NativeBigInt(this.value + BigInt(1));
    };
    BigInteger2.prototype.prev = function() {
      var value = this.value;
      if (this.sign) {
        return new BigInteger2(addSmall(value, 1), true);
      }
      return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function() {
      var value = this.value;
      if (value - 1 > -9007199254740992) return new SmallInteger(value - 1);
      return new BigInteger2(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function() {
      return new NativeBigInt(this.value - BigInt(1));
    };
    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
    function shift_isSmall(n) {
      return Math.abs(n) <= BASE;
    }
    BigInteger2.prototype.shiftLeft = function(v) {
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0) return this.shiftRight(-n);
      var result = this;
      if (result.isZero()) return result;
      while (n >= powers2Length) {
        result = result.multiply(highestPower2);
        n -= powers2Length - 1;
      }
      return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger2.prototype.shiftLeft;
    BigInteger2.prototype.shiftRight = function(v) {
      var remQuo;
      var n = parseValue(v).toJSNumber();
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      if (n < 0) return this.shiftLeft(-n);
      var result = this;
      while (n >= powers2Length) {
        if (result.isZero() || result.isNegative() && result.isUnit()) return result;
        remQuo = divModAny(result, highestPower2);
        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        n -= powers2Length - 1;
      }
      remQuo = divModAny(result, powersOfTwo[n]);
      return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger2.prototype.shiftRight;
    function bitwise(x, y, fn) {
      y = parseValue(y);
      var xSign = x.isNegative(), ySign = y.isNegative();
      var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
      var xDigit = 0, yDigit = 0;
      var xDivMod = null, yDivMod = null;
      var result = [];
      while (!xRem.isZero() || !yRem.isZero()) {
        xDivMod = divModAny(xRem, highestPower2);
        xDigit = xDivMod[1].toJSNumber();
        if (xSign) {
          xDigit = highestPower2 - 1 - xDigit;
        }
        yDivMod = divModAny(yRem, highestPower2);
        yDigit = yDivMod[1].toJSNumber();
        if (ySign) {
          yDigit = highestPower2 - 1 - yDigit;
        }
        xRem = xDivMod[0];
        yRem = yDivMod[0];
        result.push(fn(xDigit, yDigit));
      }
      var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);
      for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
        sum = sum.multiply(highestPower2).add(bigInt2(result[i2]));
      }
      return sum;
    }
    BigInteger2.prototype.not = function() {
      return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger2.prototype.not;
    BigInteger2.prototype.and = function(n) {
      return bitwise(this, n, function(a, b) {
        return a & b;
      });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger2.prototype.and;
    BigInteger2.prototype.or = function(n) {
      return bitwise(this, n, function(a, b) {
        return a | b;
      });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger2.prototype.or;
    BigInteger2.prototype.xor = function(n) {
      return bitwise(this, n, function(a, b) {
        return a ^ b;
      });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger2.prototype.xor;
    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -1e7) * (BASE & -1e7) | LOBMASK_I;
    function roughLOB(n) {
      var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
      return x & -x;
    }
    function integerLogarithm(value, base) {
      if (base.compareTo(value) <= 0) {
        var tmp2 = integerLogarithm(value, base.square(base));
        var p = tmp2.p;
        var e = tmp2.e;
        var t = p.multiply(base);
        return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
      }
      return { p: bigInt2(1), e: 0 };
    }
    BigInteger2.prototype.bitLength = function() {
      var n = this;
      if (n.compareTo(bigInt2(0)) < 0) {
        n = n.negate().subtract(bigInt2(1));
      }
      if (n.compareTo(bigInt2(0)) === 0) {
        return bigInt2(0);
      }
      return bigInt2(integerLogarithm(n, bigInt2(2)).e).add(bigInt2(1));
    };
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger2.prototype.bitLength;
    function max(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.greater(b) ? a : b;
    }
    function min(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      if (a.equals(b)) return a;
      if (a.isZero()) return b;
      if (b.isZero()) return a;
      var c2 = Integer[1], d, t;
      while (a.isEven() && b.isEven()) {
        d = min(roughLOB(a), roughLOB(b));
        a = a.divide(d);
        b = b.divide(d);
        c2 = c2.multiply(d);
      }
      while (a.isEven()) {
        a = a.divide(roughLOB(a));
      }
      do {
        while (b.isEven()) {
          b = b.divide(roughLOB(b));
        }
        if (a.greater(b)) {
          t = b;
          b = a;
          a = t;
        }
        b = b.subtract(a);
      } while (!b.isZero());
      return c2.isUnit() ? a : a.multiply(c2);
    }
    function lcm(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng2) {
      a = parseValue(a);
      b = parseValue(b);
      var usedRNG = rng2 || Math.random;
      var low = min(a, b), high = max(a, b);
      var range2 = high.subtract(low).add(1);
      if (range2.isSmall) return low.add(Math.floor(usedRNG() * range2));
      var digits = toBase(range2, BASE).value;
      var result = [], restricted = true;
      for (var i2 = 0; i2 < digits.length; i2++) {
        var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
        var digit = truncate(usedRNG() * top);
        result.push(digit);
        if (digit < digits[i2]) restricted = false;
      }
      return low.add(Integer.fromArray(result, BASE, false));
    }
    var parseBase = function(text, base, alphabet, caseSensitive) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      text = String(text);
      if (!caseSensitive) {
        text = text.toLowerCase();
        alphabet = alphabet.toLowerCase();
      }
      var length = text.length;
      var i2;
      var absBase = Math.abs(base);
      var alphabetValues = {};
      for (i2 = 0; i2 < alphabet.length; i2++) {
        alphabetValues[alphabet[i2]] = i2;
      }
      for (i2 = 0; i2 < length; i2++) {
        var c2 = text[i2];
        if (c2 === "-") continue;
        if (c2 in alphabetValues) {
          if (alphabetValues[c2] >= absBase) {
            if (c2 === "1" && absBase === 1) continue;
            throw new Error(c2 + " is not a valid digit in base " + base + ".");
          }
        }
      }
      base = parseValue(base);
      var digits = [];
      var isNegative = text[0] === "-";
      for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {
        var c2 = text[i2];
        if (c2 in alphabetValues) digits.push(parseValue(alphabetValues[c2]));
        else if (c2 === "<") {
          var start = i2;
          do {
            i2++;
          } while (text[i2] !== ">" && i2 < text.length);
          digits.push(parseValue(text.slice(start + 1, i2)));
        } else throw new Error(c2 + " is not a valid character");
      }
      return parseBaseFromArray(digits, base, isNegative);
    };
    function parseBaseFromArray(digits, base, isNegative) {
      var val = Integer[0], pow = Integer[1], i2;
      for (i2 = digits.length - 1; i2 >= 0; i2--) {
        val = val.add(digits[i2].times(pow));
        pow = pow.times(base);
      }
      return isNegative ? val.negate() : val;
    }
    function stringify2(digit, alphabet) {
      alphabet = alphabet || DEFAULT_ALPHABET;
      if (digit < alphabet.length) {
        return alphabet[digit];
      }
      return "<" + digit + ">";
    }
    function toBase(n, base) {
      base = bigInt2(base);
      if (base.isZero()) {
        if (n.isZero()) return { value: [0], isNegative: false };
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }
      if (base.equals(-1)) {
        if (n.isZero()) return { value: [0], isNegative: false };
        if (n.isNegative())
          return {
            value: [].concat.apply(
              [],
              Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
            ),
            isNegative: false
          };
        var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
        arr.unshift([1]);
        return {
          value: [].concat.apply([], arr),
          isNegative: false
        };
      }
      var neg = false;
      if (n.isNegative() && base.isPositive()) {
        neg = true;
        n = n.abs();
      }
      if (base.isUnit()) {
        if (n.isZero()) return { value: [0], isNegative: false };
        return {
          value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
          isNegative: neg
        };
      }
      var out2 = [];
      var left = n, divmod;
      while (left.isNegative() || left.compareAbs(base) >= 0) {
        divmod = left.divmod(base);
        left = divmod.quotient;
        var digit = divmod.remainder;
        if (digit.isNegative()) {
          digit = base.minus(digit).abs();
          left = left.next();
        }
        out2.push(digit.toJSNumber());
      }
      out2.push(left.toJSNumber());
      return { value: out2.reverse(), isNegative: neg };
    }
    function toBaseString(n, base, alphabet) {
      var arr = toBase(n, base);
      return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
        return stringify2(x, alphabet);
      }).join("");
    }
    BigInteger2.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    SmallInteger.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    NativeBigInt.prototype.toArray = function(radix) {
      return toBase(this, radix);
    };
    BigInteger2.prototype.toString = function(radix, alphabet) {
      if (radix === undefined$1) radix = 10;
      if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
      var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
      while (--l >= 0) {
        digit = String(v[l]);
        str += zeros.slice(digit.length) + digit;
      }
      var sign = this.sign ? "-" : "";
      return sign + str;
    };
    SmallInteger.prototype.toString = function(radix, alphabet) {
      if (radix === undefined$1) radix = 10;
      if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
      return String(this.value);
    };
    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
    NativeBigInt.prototype.toJSON = BigInteger2.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
      return this.toString();
    };
    BigInteger2.prototype.valueOf = function() {
      return parseInt(this.toString(), 10);
    };
    BigInteger2.prototype.toJSNumber = BigInteger2.prototype.valueOf;
    SmallInteger.prototype.valueOf = function() {
      return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
      return parseInt(this.toString(), 10);
    };
    function parseStringValue(v) {
      if (isPrecise(+v)) {
        var x = +v;
        if (x === truncate(x))
          return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
        throw new Error("Invalid integer: " + v);
      }
      var sign = v[0] === "-";
      if (sign) v = v.slice(1);
      var split = v.split(/e/i);
      if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
      if (split.length === 2) {
        var exp = split[1];
        if (exp[0] === "+") exp = exp.slice(1);
        exp = +exp;
        if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
        var text = split[0];
        var decimalPlace = text.indexOf(".");
        if (decimalPlace >= 0) {
          exp -= text.length - decimalPlace - 1;
          text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
        }
        if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
        text += new Array(exp + 1).join("0");
        v = text;
      }
      var isValid = /^([0-9][0-9]*)$/.test(v);
      if (!isValid) throw new Error("Invalid integer: " + v);
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(sign ? "-" + v : v));
      }
      var r = [], max2 = v.length, l = LOG_BASE, min2 = max2 - l;
      while (max2 > 0) {
        r.push(+v.slice(min2, max2));
        min2 -= l;
        if (min2 < 0) min2 = 0;
        max2 -= l;
      }
      trim(r);
      return new BigInteger2(r, sign);
    }
    function parseNumberValue(v) {
      if (supportsNativeBigInt) {
        return new NativeBigInt(BigInt(v));
      }
      if (isPrecise(v)) {
        if (v !== truncate(v)) throw new Error(v + " is not an integer.");
        return new SmallInteger(v);
      }
      return parseStringValue(v.toString());
    }
    function parseValue(v) {
      if (typeof v === "number") {
        return parseNumberValue(v);
      }
      if (typeof v === "string") {
        return parseStringValue(v);
      }
      if (typeof v === "bigint") {
        return new NativeBigInt(v);
      }
      return v;
    }
    for (var i = 0; i < 1e3; i++) {
      Integer[i] = parseValue(i);
      if (i > 0) Integer[-i] = parseValue(-i);
    }
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function(x) {
      return x instanceof BigInteger2 || x instanceof SmallInteger || x instanceof NativeBigInt;
    };
    Integer.randBetween = randBetween;
    Integer.fromArray = function(digits, base, isNegative) {
      return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };
    return Integer;
  }();
  if (module.hasOwnProperty("exports")) {
    module.exports = bigInt2;
  }
})(BigInteger);
var BigIntegerExports = BigInteger.exports;
var bigInt = BigIntegerExports;
var Stream$2 = require$$0$1;
if (!Stream$2.Writable || !Stream$2.Writable.prototype.destroy)
  Stream$2 = requireReadable();
var table;
function generateTable() {
  var poly = 3988292384, c2, n, k;
  table = [];
  for (n = 0; n < 256; n++) {
    c2 = n;
    for (k = 0; k < 8; k++)
      c2 = c2 & 1 ? poly ^ c2 >>> 1 : c2 = c2 >>> 1;
    table[n] = c2 >>> 0;
  }
}
function crc(ch, crc2) {
  if (!table)
    generateTable();
  if (ch.charCodeAt)
    ch = ch.charCodeAt(0);
  return bigInt(crc2).shiftRight(8).and(16777215).xor(table[bigInt(crc2).xor(ch).and(255)]).value;
}
function Decrypt$1() {
  if (!(this instanceof Decrypt$1))
    return new Decrypt$1();
  this.key0 = 305419896;
  this.key1 = 591751049;
  this.key2 = 878082192;
}
Decrypt$1.prototype.update = function(h) {
  this.key0 = crc(h, this.key0);
  this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1);
  this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;
  this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);
};
Decrypt$1.prototype.decryptByte = function(c2) {
  var k = bigInt(this.key2).or(2);
  c2 = c2 ^ bigInt(k).multiply(bigInt(k ^ 1)).shiftRight(8).and(255);
  this.update(c2);
  return c2;
};
Decrypt$1.prototype.stream = function() {
  var stream2 = Stream$2.Transform(), self2 = this;
  stream2._transform = function(d, e, cb) {
    for (var i = 0; i < d.length; i++) {
      d[i] = self2.decryptByte(d[i]);
    }
    this.push(d);
    cb();
  };
  return stream2;
};
var Decrypt_1 = Decrypt$1;
var Promise$3 = bluebird_1;
var Decrypt = Decrypt_1;
var PullStream$1 = PullStream_1;
var Stream$1 = require$$0$1;
var binary$1 = binaryExports;
var zlib = require$$0$7;
var parseExtraField$1 = parseExtraField$3;
var Buffer$2 = Buffer_1;
var parseDateTime$1 = parseDateTime$3;
if (!Stream$1.Writable || !Stream$1.Writable.prototype.destroy)
  Stream$1 = requireReadable();
var unzip$2 = function unzip(source, offset, _password, directoryVars) {
  var file2 = PullStream$1(), entry = Stream$1.PassThrough();
  var req = source.stream(offset);
  req.pipe(file2).on("error", function(e) {
    entry.emit("error", e);
  });
  entry.vars = file2.pull(30).then(function(data) {
    var vars2 = binary$1.parse(data).word32lu("signature").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
    vars2.lastModifiedDateTime = parseDateTime$1(vars2.lastModifiedDate, vars2.lastModifiedTime);
    return file2.pull(vars2.fileNameLength).then(function(fileName) {
      vars2.fileName = fileName.toString("utf8");
      return file2.pull(vars2.extraFieldLength);
    }).then(function(extraField) {
      var checkEncryption;
      vars2.extra = parseExtraField$1(extraField, vars2);
      if (directoryVars && directoryVars.compressedSize) vars2 = directoryVars;
      if (vars2.flags & 1) checkEncryption = file2.pull(12).then(function(header) {
        if (!_password)
          throw new Error("MISSING_PASSWORD");
        var decrypt = Decrypt();
        String(_password).split("").forEach(function(d) {
          decrypt.update(d);
        });
        for (var i = 0; i < header.length; i++)
          header[i] = decrypt.decryptByte(header[i]);
        vars2.decrypt = decrypt;
        vars2.compressedSize -= 12;
        var check = vars2.flags & 8 ? vars2.lastModifiedTime >> 8 & 255 : vars2.crc32 >> 24 & 255;
        if (header[11] !== check)
          throw new Error("BAD_PASSWORD");
        return vars2;
      });
      return Promise$3.resolve(checkEncryption).then(function() {
        entry.emit("vars", vars2);
        return vars2;
      });
    });
  });
  entry.vars.then(function(vars2) {
    var fileSizeKnown = !(vars2.flags & 8) || vars2.compressedSize > 0, eof;
    var inflater = vars2.compressionMethod ? zlib.createInflateRaw() : Stream$1.PassThrough();
    if (fileSizeKnown) {
      entry.size = vars2.uncompressedSize;
      eof = vars2.compressedSize;
    } else {
      eof = Buffer$2.alloc(4);
      eof.writeUInt32LE(134695760, 0);
    }
    var stream2 = file2.stream(eof);
    if (vars2.decrypt)
      stream2 = stream2.pipe(vars2.decrypt.stream());
    stream2.pipe(inflater).on("error", function(err2) {
      entry.emit("error", err2);
    }).pipe(entry).on("finish", function() {
      if (req.destroy)
        req.destroy();
      else if (req.abort)
        req.abort();
      else if (req.close)
        req.close();
      else if (req.push)
        req.push();
      else
        console.log("warning - unable to close stream");
    });
  }).catch(function(e) {
    entry.emit("error", e);
  });
  return entry;
};
var binary = binaryExports;
var PullStream = PullStream_1;
var unzip$1 = unzip$2;
var Promise$2 = bluebird_1;
var BufferStream = BufferStream$3;
var parseExtraField = parseExtraField$3;
var Buffer$1 = Buffer_1;
var path = require$$1;
var Writer = fstream.Writer;
var parseDateTime2 = parseDateTime$3;
var signature = Buffer$1.alloc(4);
signature.writeUInt32LE(101010256, 0);
function getCrxHeader(source) {
  var sourceStream = source.stream(0).pipe(PullStream());
  return sourceStream.pull(4).then(function(data) {
    var signature2 = data.readUInt32LE(0);
    if (signature2 === 875721283) {
      var crxHeader;
      return sourceStream.pull(12).then(function(data2) {
        crxHeader = binary.parse(data2).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
      }).then(function() {
        return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);
      }).then(function(data2) {
        crxHeader.publicKey = data2.slice(0, crxHeader.pubKeyLength);
        crxHeader.signature = data2.slice(crxHeader.pubKeyLength);
        crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;
        return crxHeader;
      });
    }
  });
}
function getZip64CentralDirectory(source, zip64CDL) {
  var d64loc = binary.parse(zip64CDL).word32lu("signature").word32lu("diskNumber").word64lu("offsetToStartOfCentralDirectory").word32lu("numberOfDisks").vars;
  if (d64loc.signature != 117853008) {
    throw new Error("invalid zip64 end of central dir locator signature (0x07064b50): 0x" + d64loc.signature.toString(16));
  }
  var dir64 = PullStream();
  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);
  return dir64.pull(56);
}
function parseZip64DirRecord(dir64record) {
  var vars2 = binary.parse(dir64record).word32lu("signature").word64lu("sizeOfCentralDirectory").word16lu("version").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskStart").word64lu("numberOfRecordsOnDisk").word64lu("numberOfRecords").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
  if (vars2.signature != 101075792) {
    throw new Error("invalid zip64 end of central dir locator signature (0x06064b50): 0x0" + vars2.signature.toString(16));
  }
  return vars2;
}
var directory$1 = function centralDirectory(source, options) {
  var endDir = PullStream(), records = PullStream(), tailSize = options && options.tailSize || 80, sourceSize, crxHeader, startOffset, vars2;
  if (options && options.crx)
    crxHeader = getCrxHeader(source);
  return source.size().then(function(size) {
    sourceSize = size;
    source.stream(Math.max(0, size - tailSize)).on("error", function(error2) {
      endDir.emit("error", error2);
    }).pipe(endDir);
    return endDir.pull(signature);
  }).then(function() {
    return Promise$2.props({ directory: endDir.pull(22), crxHeader });
  }).then(function(d) {
    var data = d.directory;
    startOffset = d.crxHeader && d.crxHeader.size || 0;
    vars2 = binary.parse(data).word32lu("signature").word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
    if (vars2.numberOfRecords == 65535 || vars2.numberOfRecords == 65535 || vars2.offsetToStartOfCentralDirectory == 4294967295) {
      const zip64CDLSize = 20;
      const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);
      const zip64CDLStream = PullStream();
      source.stream(zip64CDLOffset).pipe(zip64CDLStream);
      return zip64CDLStream.pull(zip64CDLSize).then(function(d2) {
        return getZip64CentralDirectory(source, d2);
      }).then(function(dir64record) {
        vars2 = parseZip64DirRecord(dir64record);
      });
    } else {
      vars2.offsetToStartOfCentralDirectory += startOffset;
    }
  }).then(function() {
    if (vars2.commentLength) return endDir.pull(vars2.commentLength).then(function(comment) {
      vars2.comment = comment.toString("utf8");
    });
  }).then(function() {
    source.stream(vars2.offsetToStartOfCentralDirectory).pipe(records);
    vars2.extract = function(opts) {
      if (!opts || !opts.path) throw new Error("PATH_MISSING");
      opts.path = path.resolve(path.normalize(opts.path));
      return vars2.files.then(function(files) {
        return Promise$2.map(files, function(entry) {
          if (entry.type == "Directory") return;
          var extractPath = path.join(opts.path, entry.path);
          if (extractPath.indexOf(opts.path) != 0) {
            return;
          }
          var writer2 = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer({ path: extractPath });
          return new Promise$2(function(resolve2, reject2) {
            entry.stream(opts.password).on("error", reject2).pipe(writer2).on("close", resolve2).on("error", reject2);
          });
        }, { concurrency: opts.concurrency > 1 ? opts.concurrency : 1 });
      });
    };
    vars2.files = Promise$2.mapSeries(Array(vars2.numberOfRecords), function() {
      return records.pull(46).then(function(data) {
        var vars3 = binary.parse(data).word32lu("signature").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
        vars3.offsetToLocalFileHeader += startOffset;
        vars3.lastModifiedDateTime = parseDateTime2(vars3.lastModifiedDate, vars3.lastModifiedTime);
        return records.pull(vars3.fileNameLength).then(function(fileNameBuffer) {
          vars3.pathBuffer = fileNameBuffer;
          vars3.path = fileNameBuffer.toString("utf8");
          vars3.isUnicode = (vars3.flags & 2048) != 0;
          return records.pull(vars3.extraFieldLength);
        }).then(function(extraField) {
          vars3.extra = parseExtraField(extraField, vars3);
          return records.pull(vars3.fileCommentLength);
        }).then(function(comment) {
          vars3.comment = comment;
          vars3.type = vars3.uncompressedSize === 0 && /[\/\\]$/.test(vars3.path) ? "Directory" : "File";
          vars3.stream = function(_password) {
            return unzip$1(source, vars3.offsetToLocalFileHeader, _password, vars3);
          };
          vars3.buffer = function(_password) {
            return BufferStream(vars3.stream(_password));
          };
          return vars3;
        });
      });
    });
    return Promise$2.props(vars2);
  });
};
var fs$1 = gracefulFs;
var Promise$1 = bluebird_1;
var directory = directory$1;
var Stream = require$$0$1;
if (!Stream.Writable || !Stream.Writable.prototype.destroy)
  Stream = requireReadable();
var Open = {
  buffer: function(buffer, options) {
    var source = {
      stream: function(offset, length) {
        var stream2 = Stream.PassThrough();
        stream2.end(buffer.slice(offset, length));
        return stream2;
      },
      size: function() {
        return Promise$1.resolve(buffer.length);
      }
    };
    return directory(source, options);
  },
  file: function(filename, options) {
    var source = {
      stream: function(offset, length) {
        return fs$1.createReadStream(filename, { start: offset, end: length && offset + length });
      },
      size: function() {
        return new Promise$1(function(resolve2, reject2) {
          fs$1.stat(filename, function(err2, d) {
            if (err2)
              reject2(err2);
            else
              resolve2(d.size);
          });
        });
      }
    };
    return directory(source, options);
  },
  url: function(request, params, options) {
    if (typeof params === "string")
      params = { url: params };
    if (!params.url)
      throw "URL missing";
    params.headers = params.headers || {};
    var source = {
      stream: function(offset, length) {
        var options2 = Object.create(params);
        options2.headers = Object.create(params.headers);
        options2.headers.range = "bytes=" + offset + "-" + (length ? length : "");
        return request(options2);
      },
      size: function() {
        return new Promise$1(function(resolve2, reject2) {
          var req = request(params);
          req.on("response", function(d) {
            req.abort();
            if (!d.headers["content-length"])
              reject2(new Error("Missing content length header"));
            else
              resolve2(d.headers["content-length"]);
          }).on("error", reject2);
        });
      }
    };
    return directory(source, options);
  },
  s3: function(client, params, options) {
    var source = {
      size: function() {
        return new Promise$1(function(resolve2, reject2) {
          client.headObject(params, function(err2, d) {
            if (err2)
              reject2(err2);
            else
              resolve2(d.ContentLength);
          });
        });
      },
      stream: function(offset, length) {
        var d = {};
        for (var key in params)
          d[key] = params[key];
        d.Range = "bytes=" + offset + "-" + (length ? length : "");
        return client.getObject(d).createReadStream();
      }
    };
    return directory(source, options);
  },
  custom: function(source, options) {
    return directory(source, options);
  }
};
unzip$3.Parse = parse;
unzip$3.ParseOne = parseOne_1;
unzip$3.Extract = extract;
unzip$3.Open = Open;
var tmp$1 = { exports: {} };
/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */
(function(module) {
  const fs2 = require$$0$2;
  const os = require$$1$1;
  const path2 = require$$1;
  const crypto2 = crypto$1;
  const _c = { fs: fs2.constants, os: os.constants };
  const RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), IS_WIN32 = os.platform() === "win32", EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448, FILE_MODE = 384, EXIT = "exit", _removeObjects = [], FN_RMDIR_SYNC = fs2.rmdirSync.bind(fs2);
  let _gracefulCleanup = false;
  function rimraf2(dirPath, callback) {
    return fs2.rm(dirPath, { recursive: true }, callback);
  }
  function FN_RIMRAF_SYNC(dirPath) {
    return fs2.rmSync(dirPath, { recursive: true });
  }
  function tmpName(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    try {
      _assertAndSanitizeOptions(opts);
    } catch (err2) {
      return cb(err2);
    }
    let tries = opts.tries;
    (function _getUniqueName() {
      try {
        const name = _generateTmpName(opts);
        fs2.stat(name, function(err2) {
          if (!err2) {
            if (tries-- > 0) return _getUniqueName();
            return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
          }
          cb(null, name);
        });
      } catch (err2) {
        cb(err2);
      }
    })();
  }
  function tmpNameSync(options) {
    const args = _parseArguments(options), opts = args[0];
    _assertAndSanitizeOptions(opts);
    let tries = opts.tries;
    do {
      const name = _generateTmpName(opts);
      try {
        fs2.statSync(name);
      } catch (e) {
        return name;
      }
    } while (tries-- > 0);
    throw new Error("Could not get a unique tmp filename, max tries reached");
  }
  function file2(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    tmpName(opts, function _tmpNameCreated(err2, name) {
      if (err2) return cb(err2);
      fs2.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err3, fd) {
        if (err3) return cb(err3);
        if (opts.discardDescriptor) {
          return fs2.close(fd, function _discardCallback(possibleErr) {
            return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
          });
        } else {
          const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
          cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
        }
      });
    });
  }
  function fileSync(options) {
    const args = _parseArguments(options), opts = args[0];
    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
    const name = tmpNameSync(opts);
    var fd = fs2.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    if (opts.discardDescriptor) {
      fs2.closeSync(fd);
      fd = void 0;
    }
    return {
      name,
      fd,
      removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
    };
  }
  function dir2(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    tmpName(opts, function _tmpNameCreated(err2, name) {
      if (err2) return cb(err2);
      fs2.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err3) {
        if (err3) return cb(err3);
        cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
      });
    });
  }
  function dirSync(options) {
    const args = _parseArguments(options), opts = args[0];
    const name = tmpNameSync(opts);
    fs2.mkdirSync(name, opts.mode || DIR_MODE);
    return {
      name,
      removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
    };
  }
  function _removeFileAsync(fdPath, next) {
    const _handler = function(err2) {
      if (err2 && !_isENOENT(err2)) {
        return next(err2);
      }
      next();
    };
    if (0 <= fdPath[0])
      fs2.close(fdPath[0], function() {
        fs2.unlink(fdPath[1], _handler);
      });
    else fs2.unlink(fdPath[1], _handler);
  }
  function _removeFileSync(fdPath) {
    let rethrownException = null;
    try {
      if (0 <= fdPath[0]) fs2.closeSync(fdPath[0]);
    } catch (e) {
      if (!_isEBADF(e) && !_isENOENT(e)) throw e;
    } finally {
      try {
        fs2.unlinkSync(fdPath[1]);
      } catch (e) {
        if (!_isENOENT(e)) rethrownException = e;
      }
    }
    if (rethrownException !== null) {
      throw rethrownException;
    }
  }
  function _prepareTmpFileRemoveCallback(name, fd, opts, sync3) {
    const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync3);
    const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync3, removeCallbackSync);
    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);
    return sync3 ? removeCallbackSync : removeCallback;
  }
  function _prepareTmpDirRemoveCallback(name, opts, sync3) {
    const removeFunction = opts.unsafeCleanup ? rimraf2 : fs2.rmdir.bind(fs2);
    const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
    const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync3);
    const removeCallback = _prepareRemoveCallback(removeFunction, name, sync3, removeCallbackSync);
    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);
    return sync3 ? removeCallbackSync : removeCallback;
  }
  function _prepareRemoveCallback(removeFunction, fileOrDirName, sync3, cleanupCallbackSync) {
    let called = false;
    return function _cleanupCallback(next) {
      if (!called) {
        const toRemove = cleanupCallbackSync || _cleanupCallback;
        const index2 = _removeObjects.indexOf(toRemove);
        if (index2 >= 0) _removeObjects.splice(index2, 1);
        called = true;
        if (sync3 || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
          return removeFunction(fileOrDirName);
        } else {
          return removeFunction(fileOrDirName, next || function() {
          });
        }
      }
    };
  }
  function _garbageCollector() {
    if (!_gracefulCleanup) return;
    while (_removeObjects.length) {
      try {
        _removeObjects[0]();
      } catch (e) {
      }
    }
  }
  function _randomChars(howMany) {
    let value = [], rnd = null;
    try {
      rnd = crypto2.randomBytes(howMany);
    } catch (e) {
      rnd = crypto2.pseudoRandomBytes(howMany);
    }
    for (var i = 0; i < howMany; i++) {
      value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
    }
    return value.join("");
  }
  function _isBlank(s) {
    return s === null || _isUndefined(s) || !s.trim();
  }
  function _isUndefined(obj) {
    return typeof obj === "undefined";
  }
  function _parseArguments(options, callback) {
    if (typeof options === "function") {
      return [{}, options];
    }
    if (_isUndefined(options)) {
      return [{}, callback];
    }
    const actualOptions = {};
    for (const key of Object.getOwnPropertyNames(options)) {
      actualOptions[key] = options[key];
    }
    return [actualOptions, callback];
  }
  function _generateTmpName(opts) {
    const tmpDir = opts.tmpdir;
    if (!_isUndefined(opts.name))
      return path2.join(tmpDir, opts.dir, opts.name);
    if (!_isUndefined(opts.template))
      return path2.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
    const name = [
      opts.prefix ? opts.prefix : "tmp",
      "-",
      process.pid,
      "-",
      _randomChars(12),
      opts.postfix ? "-" + opts.postfix : ""
    ].join("");
    return path2.join(tmpDir, opts.dir, name);
  }
  function _assertAndSanitizeOptions(options) {
    options.tmpdir = _getTmpDir(options);
    const tmpDir = options.tmpdir;
    if (!_isUndefined(options.name))
      _assertIsRelative(options.name, "name", tmpDir);
    if (!_isUndefined(options.dir))
      _assertIsRelative(options.dir, "dir", tmpDir);
    if (!_isUndefined(options.template)) {
      _assertIsRelative(options.template, "template", tmpDir);
      if (!options.template.match(TEMPLATE_PATTERN))
        throw new Error(`Invalid template, found "${options.template}".`);
    }
    if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
      throw new Error(`Invalid tries, found "${options.tries}".`);
    options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
    options.keep = !!options.keep;
    options.detachDescriptor = !!options.detachDescriptor;
    options.discardDescriptor = !!options.discardDescriptor;
    options.unsafeCleanup = !!options.unsafeCleanup;
    options.dir = _isUndefined(options.dir) ? "" : path2.relative(tmpDir, _resolvePath(options.dir, tmpDir));
    options.template = _isUndefined(options.template) ? void 0 : path2.relative(tmpDir, _resolvePath(options.template, tmpDir));
    options.template = _isBlank(options.template) ? void 0 : path2.relative(options.dir, options.template);
    options.name = _isUndefined(options.name) ? void 0 : options.name;
    options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
    options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
  }
  function _resolvePath(name, tmpDir) {
    if (name.startsWith(tmpDir)) {
      return path2.resolve(name);
    } else {
      return path2.resolve(path2.join(tmpDir, name));
    }
  }
  function _assertIsRelative(name, option, tmpDir) {
    if (option === "name") {
      if (path2.isAbsolute(name))
        throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
      let basename = path2.basename(name);
      if (basename === ".." || basename === "." || basename !== name)
        throw new Error(`${option} option must not contain a path, found "${name}".`);
    } else {
      if (path2.isAbsolute(name) && !name.startsWith(tmpDir)) {
        throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
      }
      let resolvedPath = _resolvePath(name, tmpDir);
      if (!resolvedPath.startsWith(tmpDir))
        throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
    }
  }
  function _isEBADF(error2) {
    return _isExpectedError(error2, -EBADF, "EBADF");
  }
  function _isENOENT(error2) {
    return _isExpectedError(error2, -ENOENT, "ENOENT");
  }
  function _isExpectedError(error2, errno, code) {
    return IS_WIN32 ? error2.code === code : error2.code === code && error2.errno === errno;
  }
  function setGracefulCleanup() {
    _gracefulCleanup = true;
  }
  function _getTmpDir(options) {
    return path2.resolve(options && options.tmpdir || os.tmpdir());
  }
  process.addListener(EXIT, _garbageCollector);
  Object.defineProperty(module.exports, "tmpdir", {
    enumerable: true,
    configurable: false,
    get: function() {
      return _getTmpDir();
    }
  });
  module.exports.dir = dir2;
  module.exports.dirSync = dirSync;
  module.exports.file = file2;
  module.exports.fileSync = fileSync;
  module.exports.tmpName = tmpName;
  module.exports.tmpNameSync = tmpNameSync;
  module.exports.setGracefulCleanup = setGracefulCleanup;
})(tmp$1);
var tmpExports = tmp$1.exports;
var iterateStream$1 = async function* iterateStream(stream2) {
  const contents = [];
  stream2.on("data", (data) => contents.push(data));
  let resolveStreamEndedPromise;
  const streamEndedPromise = new Promise((resolve2) => resolveStreamEndedPromise = resolve2);
  let ended = false;
  stream2.on("end", () => {
    ended = true;
    resolveStreamEndedPromise();
  });
  let error2 = false;
  stream2.on("error", (err2) => {
    error2 = err2;
    resolveStreamEndedPromise();
  });
  while (!ended || contents.length > 0) {
    if (contents.length === 0) {
      stream2.resume();
      await Promise.race([once(stream2, "data"), streamEndedPromise]);
    } else {
      stream2.pause();
      const data = contents.shift();
      yield data;
    }
    if (error2) throw error2;
  }
  resolveStreamEndedPromise();
};
function once(eventEmitter, type) {
  return new Promise((resolve2) => {
    let fired = false;
    const handler = () => {
      if (!fired) {
        fired = true;
        eventEmitter.removeListener(type, handler);
        resolve2();
      }
    };
    eventEmitter.addListener(type, handler);
  });
}
const { EventEmitter: EventEmitter$2 } = require$$2$1;
const parseSax$2 = parseSax$4;
const _$1 = underDash;
const utils = utils_1;
const colCache = colCache_1;
const Dimensions = range$2;
const Row2 = row;
const Column3 = column$1;
let WorksheetReader$1 = class WorksheetReader extends EventEmitter$2 {
  constructor({ workbook: workbook2, id, iterator, options }) {
    super();
    this.workbook = workbook2;
    this.id = id;
    this.iterator = iterator;
    this.options = options || {};
    this.name = `Sheet${this.id}`;
    this._columns = null;
    this._keys = {};
    this._dimensions = new Dimensions();
  }
  // destroy - not a valid operation for a streaming writer
  // even though some streamers might be able to, it's a bad idea.
  destroy() {
    throw new Error("Invalid Operation: destroy");
  }
  // return the current dimensions of the writer
  get dimensions() {
    return this._dimensions;
  }
  // =========================================================================
  // Columns
  // get the current columns array.
  get columns() {
    return this._columns;
  }
  // get a single column by col number. If it doesn't exist, it and any gaps before it
  // are created.
  getColumn(c2) {
    if (typeof c2 === "string") {
      const col = this._keys[c2];
      if (col) {
        return col;
      }
      c2 = colCache.l2n(c2);
    }
    if (!this._columns) {
      this._columns = [];
    }
    if (c2 > this._columns.length) {
      let n = this._columns.length + 1;
      while (n <= c2) {
        this._columns.push(new Column3(this, n++));
      }
    }
    return this._columns[c2 - 1];
  }
  getColumnKey(key) {
    return this._keys[key];
  }
  setColumnKey(key, value) {
    this._keys[key] = value;
  }
  deleteColumnKey(key) {
    delete this._keys[key];
  }
  eachColumnKey(f) {
    _$1.each(this._keys, f);
  }
  async read() {
    try {
      for await (const events2 of this.parse()) {
        for (const { eventType, value } of events2) {
          this.emit(eventType, value);
        }
      }
      this.emit("finished");
    } catch (error2) {
      this.emit("error", error2);
    }
  }
  async *[Symbol.asyncIterator]() {
    for await (const events2 of this.parse()) {
      for (const { eventType, value } of events2) {
        if (eventType === "row") {
          yield value;
        }
      }
    }
  }
  async *parse() {
    const { iterator, options } = this;
    let emitSheet = false;
    let emitHyperlinks = false;
    let hyperlinks = null;
    switch (options.worksheets) {
      case "emit":
        emitSheet = true;
        break;
    }
    switch (options.hyperlinks) {
      case "emit":
        emitHyperlinks = true;
        break;
      case "cache":
        this.hyperlinks = hyperlinks = {};
        break;
    }
    if (!emitSheet && !emitHyperlinks && !hyperlinks) {
      return;
    }
    const { sharedStrings: sharedStrings2, styles, properties } = this.workbook;
    let inCols = false;
    let inRows = false;
    let inHyperlinks = false;
    let cols = null;
    let row2 = null;
    let c2 = null;
    let current = null;
    for await (const events2 of parseSax$2(iterator)) {
      const worksheetEvents = [];
      for (const { eventType, value } of events2) {
        if (eventType === "opentag") {
          const node2 = value;
          if (emitSheet) {
            switch (node2.name) {
              case "cols":
                inCols = true;
                cols = [];
                break;
              case "sheetData":
                inRows = true;
                break;
              case "col":
                if (inCols) {
                  cols.push({
                    min: parseInt(node2.attributes.min, 10),
                    max: parseInt(node2.attributes.max, 10),
                    width: parseFloat(node2.attributes.width),
                    styleId: parseInt(node2.attributes.style || "0", 10)
                  });
                }
                break;
              case "row":
                if (inRows) {
                  const r = parseInt(node2.attributes.r, 10);
                  row2 = new Row2(this, r);
                  if (node2.attributes.ht) {
                    row2.height = parseFloat(node2.attributes.ht);
                  }
                  if (node2.attributes.s) {
                    const styleId = parseInt(node2.attributes.s, 10);
                    const style = styles.getStyleModel(styleId);
                    if (style) {
                      row2.style = style;
                    }
                  }
                }
                break;
              case "c":
                if (row2) {
                  c2 = {
                    ref: node2.attributes.r,
                    s: parseInt(node2.attributes.s, 10),
                    t: node2.attributes.t
                  };
                }
                break;
              case "f":
                if (c2) {
                  current = c2.f = { text: "" };
                }
                break;
              case "v":
                if (c2) {
                  current = c2.v = { text: "" };
                }
                break;
              case "is":
              case "t":
                if (c2) {
                  current = c2.v = { text: "" };
                }
                break;
            }
          }
          if (emitHyperlinks || hyperlinks) {
            switch (node2.name) {
              case "hyperlinks":
                inHyperlinks = true;
                break;
              case "hyperlink":
                if (inHyperlinks) {
                  const hyperlink = {
                    ref: node2.attributes.ref,
                    rId: node2.attributes["r:id"]
                  };
                  if (emitHyperlinks) {
                    worksheetEvents.push({ eventType: "hyperlink", value: hyperlink });
                  } else {
                    hyperlinks[hyperlink.ref] = hyperlink;
                  }
                }
                break;
            }
          }
        } else if (eventType === "text") {
          if (emitSheet) {
            if (current) {
              current.text += value;
            }
          }
        } else if (eventType === "closetag") {
          const node2 = value;
          if (emitSheet) {
            switch (node2.name) {
              case "cols":
                inCols = false;
                this._columns = Column3.fromModel(cols);
                break;
              case "sheetData":
                inRows = false;
                break;
              case "row":
                this._dimensions.expandRow(row2);
                worksheetEvents.push({ eventType: "row", value: row2 });
                row2 = null;
                break;
              case "c":
                if (row2 && c2) {
                  const address = colCache.decodeAddress(c2.ref);
                  const cell2 = row2.getCell(address.col);
                  if (c2.s) {
                    const style = styles.getStyleModel(c2.s);
                    if (style) {
                      cell2.style = style;
                    }
                  }
                  if (c2.f) {
                    const cellValue = {
                      formula: c2.f.text
                    };
                    if (c2.v) {
                      if (c2.t === "str") {
                        cellValue.result = utils.xmlDecode(c2.v.text);
                      } else {
                        cellValue.result = parseFloat(c2.v.text);
                      }
                    }
                    cell2.value = cellValue;
                  } else if (c2.v) {
                    switch (c2.t) {
                      case "s": {
                        const index2 = parseInt(c2.v.text, 10);
                        if (sharedStrings2) {
                          cell2.value = sharedStrings2[index2];
                        } else {
                          cell2.value = {
                            sharedString: index2
                          };
                        }
                        break;
                      }
                      case "inlineStr":
                      case "str":
                        cell2.value = utils.xmlDecode(c2.v.text);
                        break;
                      case "e":
                        cell2.value = { error: c2.v.text };
                        break;
                      case "b":
                        cell2.value = parseInt(c2.v.text, 10) !== 0;
                        break;
                      default:
                        if (utils.isDateFmt(cell2.numFmt)) {
                          cell2.value = utils.excelToDate(
                            parseFloat(c2.v.text),
                            properties.model && properties.model.date1904
                          );
                        } else {
                          cell2.value = parseFloat(c2.v.text);
                        }
                        break;
                    }
                  }
                  if (hyperlinks) {
                    const hyperlink = hyperlinks[c2.ref];
                    if (hyperlink) {
                      cell2.text = cell2.value;
                      cell2.value = void 0;
                      cell2.hyperlink = hyperlink;
                    }
                  }
                  c2 = null;
                }
                break;
            }
          }
          if (emitHyperlinks || hyperlinks) {
            switch (node2.name) {
              case "hyperlinks":
                inHyperlinks = false;
                break;
            }
          }
        }
      }
      if (worksheetEvents.length > 0) {
        yield worksheetEvents;
      }
    }
  }
};
var worksheetReader = WorksheetReader$1;
const { EventEmitter: EventEmitter$1 } = require$$2$1;
const parseSax$1 = parseSax$4;
const Enums = enums;
const RelType = relType;
let HyperlinkReader$1 = class HyperlinkReader extends EventEmitter$1 {
  constructor({ workbook: workbook2, id, iterator, options }) {
    super();
    this.workbook = workbook2;
    this.id = id;
    this.iterator = iterator;
    this.options = options;
  }
  get count() {
    return this.hyperlinks && this.hyperlinks.length || 0;
  }
  each(fn) {
    return this.hyperlinks.forEach(fn);
  }
  async read() {
    const { iterator, options } = this;
    let emitHyperlinks = false;
    let hyperlinks = null;
    switch (options.hyperlinks) {
      case "emit":
        emitHyperlinks = true;
        break;
      case "cache":
        this.hyperlinks = hyperlinks = {};
        break;
    }
    if (!emitHyperlinks && !hyperlinks) {
      this.emit("finished");
      return;
    }
    try {
      for await (const events2 of parseSax$1(iterator)) {
        for (const { eventType, value } of events2) {
          if (eventType === "opentag") {
            const node2 = value;
            if (node2.name === "Relationship") {
              const rId = node2.attributes.Id;
              switch (node2.attributes.Type) {
                case RelType.Hyperlink:
                  {
                    const relationship = {
                      type: Enums.RelationshipType.Styles,
                      rId,
                      target: node2.attributes.Target,
                      targetMode: node2.attributes.TargetMode
                    };
                    if (emitHyperlinks) {
                      this.emit("hyperlink", relationship);
                    } else {
                      hyperlinks[relationship.rId] = relationship;
                    }
                  }
                  break;
                default:
                  break;
              }
            }
          }
        }
      }
      this.emit("finished");
    } catch (error2) {
      this.emit("error", error2);
    }
  }
};
var hyperlinkReader = HyperlinkReader$1;
const fs = require$$0$2;
const { EventEmitter } = require$$2$1;
const { PassThrough, Readable } = readableExports$3;
const nodeStream = require$$0$1;
const unzip2 = unzip$3;
const tmp = tmpExports;
const iterateStream2 = iterateStream$1;
const parseSax = parseSax$4;
const StyleManager = stylesXform;
const WorkbookXform2 = workbookXform;
const RelationshipsXform2 = relationshipsXform;
const WorksheetReader2 = worksheetReader;
const HyperlinkReader2 = hyperlinkReader;
tmp.setGracefulCleanup();
class WorkbookReader extends EventEmitter {
  constructor(input, options = {}) {
    super();
    this.input = input;
    this.options = {
      worksheets: "emit",
      sharedStrings: "cache",
      hyperlinks: "ignore",
      styles: "ignore",
      entries: "ignore",
      ...options
    };
    this.styles = new StyleManager();
    this.styles.init();
  }
  _getStream(input) {
    if (input instanceof nodeStream.Readable || input instanceof Readable) {
      return input;
    }
    if (typeof input === "string") {
      return fs.createReadStream(input);
    }
    throw new Error(`Could not recognise input: ${input}`);
  }
  async read(input, options) {
    try {
      for await (const { eventType, value } of this.parse(input, options)) {
        switch (eventType) {
          case "shared-strings":
            this.emit(eventType, value);
            break;
          case "worksheet":
            this.emit(eventType, value);
            await value.read();
            break;
          case "hyperlinks":
            this.emit(eventType, value);
            break;
        }
      }
      this.emit("end");
      this.emit("finished");
    } catch (error2) {
      this.emit("error", error2);
    }
  }
  async *[Symbol.asyncIterator]() {
    for await (const { eventType, value } of this.parse()) {
      if (eventType === "worksheet") {
        yield value;
      }
    }
  }
  async *parse(input, options) {
    if (options) this.options = options;
    const stream2 = this.stream = this._getStream(input || this.input);
    const zip2 = unzip2.Parse({ forceStream: true });
    stream2.pipe(zip2);
    const waitingWorkSheets = [];
    for await (const entry of iterateStream2(zip2)) {
      let match2;
      let sheetNo;
      switch (entry.path) {
        case "_rels/.rels":
          break;
        case "xl/_rels/workbook.xml.rels":
          await this._parseRels(entry);
          break;
        case "xl/workbook.xml":
          await this._parseWorkbook(entry);
          break;
        case "xl/sharedStrings.xml":
          yield* this._parseSharedStrings(entry);
          break;
        case "xl/styles.xml":
          await this._parseStyles(entry);
          break;
        default:
          if (entry.path.match(/xl\/worksheets\/sheet\d+[.]xml/)) {
            match2 = entry.path.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
            sheetNo = match2[1];
            if (this.sharedStrings && this.workbookRels) {
              yield* this._parseWorksheet(iterateStream2(entry), sheetNo);
            } else {
              await new Promise((resolve2, reject2) => {
                tmp.file((err2, path2, fd, tempFileCleanupCallback) => {
                  if (err2) {
                    return reject2(err2);
                  }
                  waitingWorkSheets.push({ sheetNo, path: path2, tempFileCleanupCallback });
                  const tempStream = fs.createWriteStream(path2);
                  tempStream.on("error", reject2);
                  entry.pipe(tempStream);
                  return tempStream.on("finish", () => {
                    return resolve2();
                  });
                });
              });
            }
          } else if (entry.path.match(/xl\/worksheets\/_rels\/sheet\d+[.]xml.rels/)) {
            match2 = entry.path.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
            sheetNo = match2[1];
            yield* this._parseHyperlinks(iterateStream2(entry), sheetNo);
          }
          break;
      }
      entry.autodrain();
    }
    for (const { sheetNo, path: path2, tempFileCleanupCallback } of waitingWorkSheets) {
      let fileStream = fs.createReadStream(path2);
      if (!fileStream[Symbol.asyncIterator]) {
        fileStream = fileStream.pipe(new PassThrough());
      }
      yield* this._parseWorksheet(fileStream, sheetNo);
      tempFileCleanupCallback();
    }
  }
  _emitEntry(payload) {
    if (this.options.entries === "emit") {
      this.emit("entry", payload);
    }
  }
  async _parseRels(entry) {
    const xform2 = new RelationshipsXform2();
    this.workbookRels = await xform2.parseStream(iterateStream2(entry));
  }
  async _parseWorkbook(entry) {
    this._emitEntry({ type: "workbook" });
    const workbook2 = new WorkbookXform2();
    await workbook2.parseStream(iterateStream2(entry));
    this.properties = workbook2.map.workbookPr;
    this.model = workbook2.model;
  }
  async *_parseSharedStrings(entry) {
    this._emitEntry({ type: "shared-strings" });
    switch (this.options.sharedStrings) {
      case "cache":
        this.sharedStrings = [];
        break;
      case "emit":
        break;
      default:
        return;
    }
    let text = null;
    let richText = [];
    let index2 = 0;
    let font = null;
    for await (const events2 of parseSax(iterateStream2(entry))) {
      for (const { eventType, value } of events2) {
        if (eventType === "opentag") {
          const node2 = value;
          switch (node2.name) {
            case "b":
              font = font || {};
              font.bold = true;
              break;
            case "charset":
              font = font || {};
              font.charset = parseInt(node2.attributes.charset, 10);
              break;
            case "color":
              font = font || {};
              font.color = {};
              if (node2.attributes.rgb) {
                font.color.argb = node2.attributes.argb;
              }
              if (node2.attributes.val) {
                font.color.argb = node2.attributes.val;
              }
              if (node2.attributes.theme) {
                font.color.theme = node2.attributes.theme;
              }
              break;
            case "family":
              font = font || {};
              font.family = parseInt(node2.attributes.val, 10);
              break;
            case "i":
              font = font || {};
              font.italic = true;
              break;
            case "outline":
              font = font || {};
              font.outline = true;
              break;
            case "rFont":
              font = font || {};
              font.name = node2.value;
              break;
            case "si":
              font = null;
              richText = [];
              text = null;
              break;
            case "sz":
              font = font || {};
              font.size = parseInt(node2.attributes.val, 10);
              break;
            case "strike":
              break;
            case "t":
              text = null;
              break;
            case "u":
              font = font || {};
              font.underline = true;
              break;
            case "vertAlign":
              font = font || {};
              font.vertAlign = node2.attributes.val;
              break;
          }
        } else if (eventType === "text") {
          text = text ? text + value : value;
        } else if (eventType === "closetag") {
          const node2 = value;
          switch (node2.name) {
            case "r":
              richText.push({
                font,
                text
              });
              font = null;
              text = null;
              break;
            case "si":
              if (this.options.sharedStrings === "cache") {
                this.sharedStrings.push(richText.length ? { richText } : text);
              } else if (this.options.sharedStrings === "emit") {
                yield { index: index2++, text: richText.length ? { richText } : text };
              }
              richText = [];
              font = null;
              text = null;
              break;
          }
        }
      }
    }
  }
  async _parseStyles(entry) {
    this._emitEntry({ type: "styles" });
    if (this.options.styles === "cache") {
      this.styles = new StyleManager();
      await this.styles.parseStream(iterateStream2(entry));
    }
  }
  *_parseWorksheet(iterator, sheetNo) {
    this._emitEntry({ type: "worksheet", id: sheetNo });
    const worksheetReader2 = new WorksheetReader2({
      workbook: this,
      id: sheetNo,
      iterator,
      options: this.options
    });
    const matchingRel = (this.workbookRels || []).find((rel) => rel.Target === `worksheets/sheet${sheetNo}.xml`);
    const matchingSheet = matchingRel && (this.model.sheets || []).find((sheet) => sheet.rId === matchingRel.Id);
    if (matchingSheet) {
      worksheetReader2.id = matchingSheet.id;
      worksheetReader2.name = matchingSheet.name;
      worksheetReader2.state = matchingSheet.state;
    }
    if (this.options.worksheets === "emit") {
      yield { eventType: "worksheet", value: worksheetReader2 };
    }
  }
  *_parseHyperlinks(iterator, sheetNo) {
    this._emitEntry({ type: "hyperlinks", id: sheetNo });
    const hyperlinksReader = new HyperlinkReader2({
      workbook: this,
      id: sheetNo,
      iterator,
      options: this.options
    });
    if (this.options.hyperlinks === "emit") {
      yield { eventType: "hyperlinks", value: hyperlinksReader };
    }
  }
}
WorkbookReader.Options = {
  worksheets: ["emit", "ignore"],
  sharedStrings: ["cache", "emit", "ignore"],
  hyperlinks: ["cache", "emit", "ignore"],
  styles: ["cache", "ignore"],
  entries: ["emit", "ignore"]
};
var workbookReader = WorkbookReader;
const ExcelJS$1 = {
  Workbook: workbook,
  ModelContainer: modelcontainer,
  stream: {
    xlsx: {
      WorkbookWriter: workbookWriter,
      WorkbookReader: workbookReader
    }
  }
};
Object.assign(ExcelJS$1, enums);
var exceljs_nodejs = ExcelJS$1;
if (parseInt(process.versions.node.split(".")[0], 10) < 10) {
  throw new Error(
    "For node versions older than 10, please use the ES5 Import: https://github.com/exceljs/exceljs#es5-imports"
  );
}
var excel = exceljs_nodejs;
const ExcelJS = /* @__PURE__ */ getDefaultExportFromCjs(excel);
class Room {
  // Stores student IDs
  constructor(name, columns, buildingLocation = "DE-MORGAN BLOCK FIRST FLOOR") {
    __publicField(this, "name");
    __publicField(this, "columns");
    __publicField(this, "capacity");
    __publicField(this, "buildingLocation");
    __publicField(this, "seatingGrid");
    this.name = name;
    this.columns = columns;
    this.capacity = columns.reduce((sum, col) => sum + col.rowCount, 0);
    this.buildingLocation = buildingLocation;
    const maxRows = Math.max(...columns.map((col) => col.rowCount));
    this.seatingGrid = Array(maxRows).fill(null).map(() => Array(columns.length).fill(null));
  }
}
function assignSeatsByGroup(studentGroups, rooms) {
  studentGroups.forEach((g) => {
    console.log(g.branchCode, g.subjectCode);
  });
  const groupMap = /* @__PURE__ */ new Map();
  studentGroups.forEach((group, index2) => {
    groupMap.set(index2, [...group.studentList]);
  });
  const groupIndices = Array.from(groupMap.keys());
  if (groupIndices.length === 0) {
    return rooms;
  }
  let totalStudentsToAssign = studentGroups.reduce((sum, group) => sum + group.studentList.length, 0);
  let studentsAssigned = 0;
  for (const room of rooms) {
    for (let colIdx = 0; colIdx < room.columns.length; colIdx++) {
      const targetGroupIndex = groupIndices[colIdx % groupIndices.length];
      const groupStudentList = groupMap.get(targetGroupIndex);
      const columnRowCount = room.columns[colIdx].rowCount;
      for (let rowIdx = 0; rowIdx < columnRowCount; rowIdx++) {
        if (groupStudentList && groupStudentList.length > 0) {
          const studentId = groupStudentList.shift();
          room.seatingGrid[rowIdx][colIdx] = studentId;
          studentsAssigned++;
        } else {
          room.seatingGrid[rowIdx][colIdx] = null;
        }
        if (studentsAssigned >= totalStudentsToAssign) {
          colIdx = room.columns.length;
          break;
        }
      }
      if (studentsAssigned >= totalStudentsToAssign) {
        break;
      }
    }
    if (studentsAssigned >= totalStudentsToAssign) {
      break;
    }
  }
  return rooms;
}
function generateSeatingPlan(options) {
  const { studentGroups, rooms, examConfig } = options;
  const roomsClone = rooms.map((room) => {
    const newRoom = new Room(room.name, room.columns, room.buildingLocation);
    return newRoom;
  });
  const assignedRooms = assignSeatsByGroup(studentGroups, roomsClone);
  const workbook2 = new ExcelJS.Workbook();
  workbook2.creator = "Seating Plan Generator";
  workbook2.lastModifiedBy = "Seating Plan Generator";
  workbook2.created = /* @__PURE__ */ new Date();
  workbook2.modified = /* @__PURE__ */ new Date();
  for (let roomIdx = 0; roomIdx < assignedRooms.length; roomIdx++) {
    const room = assignedRooms[roomIdx];
    const worksheet2 = workbook2.addWorksheet(`${room.name}`, {
      pageSetup: {
        paperSize: 9,
        // A4
        orientation: "landscape",
        fitToPage: true,
        fitToWidth: 1,
        fitToHeight: 1,
        horizontalCentered: true,
        verticalCentered: false
      }
    });
    const colCount = room.columns.length;
    worksheet2.columns = [
      { width: 8 },
      // S.No. column
      ...Array(colCount).fill({ width: 15 })
      // Columns for student IDs
    ];
    const titleRow = worksheet2.addRow([""]);
    titleRow.height = 20;
    const titleCell = worksheet2.getCell("A1");
    titleCell.value = `SEATING PLAN FOR ${examConfig.examName}, DATED: ${examConfig.examDate}, TIMINGS: ${examConfig.examTime}`;
    titleCell.font = { bold: true, size: 12 };
    worksheet2.mergeCells(1, 1, 1, colCount + 1 + 8);
    titleCell.alignment = { horizontal: "center", vertical: "middle" };
    const cloakRow = worksheet2.addRow([""]);
    cloakRow.height = 20;
    const cloakCell = worksheet2.getCell("A2");
    cloakCell.value = `CLOAK ROOM VENUE - ${examConfig.cloakRoom}`;
    cloakCell.font = { bold: true, size: 11 };
    worksheet2.mergeCells(2, 1, 2, colCount + 1 + 8);
    cloakCell.alignment = { horizontal: "center", vertical: "middle" };
    const instrHeaderRow = worksheet2.addRow([""]);
    instrHeaderRow.height = 20;
    const instrHeaderCell = worksheet2.getCell("A3");
    instrHeaderCell.value = "Mandatory Instructions to be announced by the Invigilator(s) to candidates before distribution of the question papers.";
    instrHeaderCell.font = { size: 10, italic: true };
    worksheet2.mergeCells(3, 1, 3, colCount + 1 + 8);
    instrHeaderCell.alignment = { horizontal: "center", vertical: "middle" };
    let currentRow = 4;
    for (const instruction of examConfig.instructions) {
      const instrRow = worksheet2.addRow([instruction]);
      instrRow.height = 12;
      const instrCell = worksheet2.getCell(`A${currentRow}`);
      instrCell.font = { size: 9 };
      worksheet2.mergeCells(currentRow, 1, currentRow, colCount + 1 + 8);
      currentRow++;
    }
    const roomHeaderRow = worksheet2.addRow([""]);
    roomHeaderRow.height = 20;
    currentRow++;
    const roomHeaderCell = worksheet2.getCell(`A${currentRow}`);
    roomHeaderCell.value = room.name;
    roomHeaderCell.font = { bold: true, size: 12 };
    worksheet2.mergeCells(currentRow, 1, currentRow, colCount + 1);
    roomHeaderCell.alignment = { horizontal: "center", vertical: "middle" };
    currentRow++;
    worksheet2.addRow([]);
    currentRow++;
    const tableHeaderRow1 = worksheet2.addRow(["S.No."]);
    tableHeaderRow1.height = 20;
    for (let col = 0; col < colCount; col++) {
      tableHeaderRow1.getCell(col + 2).value = `Col ${col + 1}`;
      tableHeaderRow1.getCell(col + 2).font = { bold: true };
      tableHeaderRow1.getCell(col + 2).alignment = { horizontal: "center", vertical: "middle" };
    }
    tableHeaderRow1.eachCell((cell2) => {
      cell2.font = { bold: true };
      cell2.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "FFE0E0E0" }
        // Light gray
      };
      cell2.border = {
        top: { style: "thin" },
        left: { style: "thin" },
        bottom: { style: "thin" },
        right: { style: "thin" }
      };
      cell2.alignment = { horizontal: "center", vertical: "middle" };
    });
    currentRow++;
    const tableHeaderRow2 = worksheet2.addRow([""]);
    tableHeaderRow2.height = 20;
    for (let col = 0; col < colCount; col++) {
      const targetGroupIndex = col % studentGroups.length;
      const group = studentGroups[targetGroupIndex];
      tableHeaderRow2.getCell(col + 2).value = group.branchCode;
      tableHeaderRow2.getCell(col + 2).font = { bold: true };
      tableHeaderRow2.getCell(col + 2).alignment = { horizontal: "center", vertical: "middle" };
    }
    tableHeaderRow2.eachCell((cell2, colNumber) => {
      cell2.font = { bold: true };
      cell2.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "FFE0E0E0" }
        // Light gray
      };
      cell2.border = {
        top: { style: "thin" },
        left: { style: "thin" },
        bottom: { style: "thin" },
        right: { style: "thin" }
      };
      cell2.alignment = { horizontal: "center", vertical: "middle" };
    });
    currentRow++;
    const maxRows = Math.max(...room.columns.map((col) => col.rowCount));
    for (let rowIdx = 0; rowIdx < maxRows; rowIdx++) {
      const dataRow = worksheet2.addRow([rowIdx + 1]);
      dataRow.height = 18;
      for (let colIdx = 0; colIdx < colCount; colIdx++) {
        const columnRowCount = room.columns[colIdx].rowCount;
        const studentId = rowIdx < columnRowCount ? room.seatingGrid[rowIdx][colIdx] : null;
        dataRow.getCell(colIdx + 2).value = studentId || "---";
        dataRow.getCell(colIdx + 2).alignment = { horizontal: "center", vertical: "middle" };
      }
      dataRow.eachCell((cell2) => {
        cell2.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" }
        };
      });
      currentRow++;
    }
    worksheet2.addRow([]);
    currentRow++;
    const summaryHeaderRow = worksheet2.addRow(["Branch", "Appearing", "Subject"]);
    summaryHeaderRow.height = 20;
    summaryHeaderRow.eachCell((cell2, colNumber) => {
      if (colNumber <= 3) {
        cell2.font = { bold: true };
        cell2.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FFE0E0E0" }
          // Light gray
        };
        cell2.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" }
        };
        cell2.alignment = { horizontal: "center", vertical: "middle" };
      }
    });
    currentRow++;
    for (const group of studentGroups) {
      const groupAppearances = room.seatingGrid.flat().filter((id) => id !== null && group.studentList.includes(id)).length;
      const summaryDataRow = worksheet2.addRow([
        group.branchCode,
        groupAppearances,
        group.subjectCode
      ]);
      summaryDataRow.eachCell((cell2, colNumber) => {
        if (colNumber <= 3) {
          cell2.border = {
            top: { style: "thin" },
            left: { style: "thin" },
            bottom: { style: "thin" },
            right: { style: "thin" }
          };
          cell2.alignment = { horizontal: "center", vertical: "middle" };
        }
      });
      currentRow++;
    }
    const totalPresent = room.seatingGrid.flat().filter((id) => id !== null).length;
    const totalRow = worksheet2.addRow(["Total", totalPresent, ""]);
    totalRow.eachCell((cell2, colNumber) => {
      if (colNumber <= 3) {
        cell2.font = { bold: true };
        cell2.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" }
        };
        cell2.alignment = { horizontal: "center", vertical: "middle" };
      }
    });
    currentRow++;
    worksheet2.addRow([]);
    currentRow++;
    worksheet2.addRow(["UMC Roll Number (if any): _____________________________ Absent Roll Number : _____________________________ Remarks: _____________________________"]);
    worksheet2.mergeCells(currentRow, 1, currentRow, colCount + 1 + 8);
    currentRow++;
    worksheet2.addRow(["Name of the Invigilator - 1: _____________________________ Employee Code: _____________________________ Signature: _____________________________"]);
    worksheet2.mergeCells(currentRow, 1, currentRow, colCount + 1 + 8);
    currentRow++;
    worksheet2.addRow(["Name of the Invigilator - 2: _____________________________ Employee Code: _____________________________ Signature: _____________________________"]);
    worksheet2.mergeCells(currentRow, 1, currentRow, colCount + 1 + 8);
  }
  return new Promise((resolve2, reject2) => {
    workbook2.xlsx.writeFile(options.outputFile).then(() => {
      resolve2(options.outputFile);
    }).catch((error2) => {
      reject2(error2);
    });
  });
}
function getDefaultExamConfig() {
  return {
    examName: "END TERM EXAMINATIONS",
    examDate: (/* @__PURE__ */ new Date()).toLocaleDateString(),
    examTime: "01:00 p.m. - 04:00 p.m.",
    cloakRoom: "OAT, Ground Floor, Le Corbusier Block",
    instructions: [
      "1. No student should be allowed to leave the Examination Hall before half time.",
      "2. Mobile phones/Smart Watches/Electronic devices are strictly prohibited in examination halls; candidates are strictly banned",
      "   from carrying these devices. If found with any such device, the same shall be confiscated and UMC will be registered.",
      "3. No student is allowed to leave the examination hall before half time.",
      "4. Students without admit card must report to Conduct Branch, Examination Wing (First Floor) with University Identity Card.",
      "5. No student is allowed to carry any paper/book/notes/mobile/calculator etc. inside the examination venue.",
      "6. Students must reach at least 15 minutes before the start of Examination at the respective examination venue."
    ]
  };
}
async function generateExampleSeatingPlanExcel() {
  const rooms = [
    new Room("DM-101", [
      { rowCount: 3 },
      { rowCount: 4 },
      { rowCount: 4 },
      { rowCount: 2 }
    ], "DE-MORGAN BLOCK FIRST FLOOR"),
    new Room("DM-102", [
      { rowCount: 7 },
      { rowCount: 5 },
      { rowCount: 4 }
    ], "DE-MORGAN BLOCK FIRST FLOOR")
  ];
  const studentGroups = [
    {
      branchCode: "CSE",
      subjectCode: "CS-101",
      studentList: [
        "CSE001",
        "CSE002",
        "CSE003",
        "CSE004",
        "CSE005",
        "CSE006",
        "CSE007",
        "CSE008",
        "CSE009",
        "CSE010",
        "CSE011",
        "CSE012",
        "CSE013",
        "CSE014",
        "CSE015"
      ]
    },
    {
      branchCode: "ECE",
      subjectCode: "EC-101",
      studentList: [
        "ECE001",
        "ECE002",
        "ECE003",
        "ECE004",
        "ECE005",
        "ECE006",
        "ECE007",
        "ECE008",
        "ECE009",
        "ECE010"
      ]
    },
    {
      branchCode: "ME",
      subjectCode: "ME-101",
      studentList: [
        "ME001",
        "ME002",
        "ME003",
        "ME004",
        "ME005",
        "ME006",
        "ME007",
        "ME008",
        "ME009",
        "ME010"
      ]
    }
  ];
  const examConfig = getDefaultExamConfig();
  examConfig.examName = "MID TERM EXAMINATIONS";
  examConfig.examDate = "May 10, 2025";
  examConfig.examTime = "09:30 a.m. - 11:30 a.m.";
  const options = {
    outputFile: "seating-plan.xlsx",
    examConfig,
    studentGroups,
    rooms
  };
  try {
    const filePath = await generateSeatingPlan(options);
    console.log(`Seating plan generated successfully at: ${filePath}`);
  } catch (error2) {
    console.error("Error generating seating plan:", error2);
  }
}
createRequire(import.meta.url);
const __dirname = path$d.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$d.join(__dirname, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$d.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$d.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$d.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
function createWindow() {
  win = new BrowserWindow({
    icon: path$d.join(process.env.VITE_PUBLIC, "logo.png"),
    autoHideMenuBar: true,
    webPreferences: {
      preload: path$d.join(__dirname, "preload.mjs")
    }
  });
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$d.join(RENDERER_DIST, "index.html"));
  }
}
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
});
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
ipcMain.handle("generate-seating-plan", async (_2, arg) => {
  try {
    console.log("Received data in main process:", arg);
    const { examConfig, studentGroups: studentGroupsFromRenderer, rooms: roomsFromRenderer } = arg;
    const processedStudentGroups = [];
    for (const group of studentGroupsFromRenderer) {
      if (!group.csvFilePath || typeof group.csvFilePath !== "string") {
        console.warn(`Skipping group ${group.branchCode}-${group.subjectCode} due to missing or invalid csvFilePath.`);
        continue;
      }
      try {
        const fileContent = await fs$i.readFile(group.csvFilePath, "utf8");
        const parseResult = Papa.parse(fileContent.trim(), {
          header: false,
          // Assuming CSV has no header, just one column of IDs
          skipEmptyLines: true
        });
        if (parseResult.errors.length > 0) {
          console.error(`Error parsing CSV for ${group.branchCode}-${group.subjectCode}:`, parseResult.errors);
          throw new Error(`Failed to parse CSV: ${parseResult.errors[0].message}`);
        }
        const studentList = parseResult.data.map((row2) => row2[0]).filter((id) => id);
        if (studentList.length === 0) {
          console.warn(`CSV for ${group.branchCode}-${group.subjectCode} is empty or contains no valid IDs.`);
        }
        processedStudentGroups.push({
          branchCode: group.branchCode,
          subjectCode: group.subjectCode,
          studentList
        });
      } catch (readError) {
        console.error(`Error reading or parsing CSV file ${group.csvFilePath}:`, readError);
        throw new Error(`Failed to process student file ${group.csvFilePath}: ${readError.message}`);
      }
    }
    if (processedStudentGroups.length === 0) {
      throw new Error("No valid student data could be processed from the provided files.");
    }
    const rooms = roomsFromRenderer.map((r) => new Room(r.name, r.rows, r.cols || "Default Location"));
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[T:.-]/g, "").slice(0, 14);
    const defaultDownloadsPath = app.getPath("downloads");
    const outputFile = path$d.join(defaultDownloadsPath, `SeatingPlan_${timestamp}.xlsx`);
    const resultPath = await generateSeatingPlan({
      outputFile,
      examConfig,
      studentGroups: processedStudentGroups,
      rooms
    });
    console.log(`Seating plan generated successfully: ${resultPath}`);
    return { success: true, path: resultPath };
  } catch (error2) {
    console.error("IPC Handler Error:", error2);
    return { success: false, error: error2.message || "Unknown error" };
  }
});
ipcMain.handle("generate-attendance-sheet", async (_2, arg) => {
  console.log("[IPC] Received generate-attendance-sheet request with args:", arg);
  try {
    const { branchCode, subjectCode, semester, batchYear, csvFilePath } = arg;
    if (!csvFilePath || typeof csvFilePath !== "string") {
      throw new Error("CSV file path is missing or invalid.");
    }
    let studentList = [];
    try {
      const fileContent = await fs$i.readFile(csvFilePath, "utf8");
      const parseResult = Papa.parse(fileContent.trim(), {
        header: false,
        // No header row
        skipEmptyLines: true
      });
      if (parseResult.errors.length > 0) {
        console.error(`Error parsing CSV ${csvFilePath}:`, parseResult.errors);
        throw new Error(`Failed to parse CSV: ${parseResult.errors[0].message}`);
      }
      studentList = parseResult.data.map((row2, index2) => {
        if (row2.length < 2 || !row2[0] || !row2[1]) {
          console.warn(`Skipping invalid row ${index2 + 1} in ${csvFilePath}:`, row2);
          return null;
        }
        return { rollNo: row2[0].trim(), name: row2[1].trim() };
      }).filter((student) => student !== null);
      if (studentList.length === 0) {
        throw new Error(`CSV file ${csvFilePath} is empty or contains no valid student data (expected rollnumber, name).`);
      }
      console.log(`[IPC] Parsed ${studentList.length} students from ${csvFilePath}`);
    } catch (readError) {
      console.error(`Error reading or parsing CSV file ${csvFilePath}:`, readError);
      throw new Error(`Failed to process student file ${csvFilePath}: ${readError.message}`);
    }
    const attendanceStudents = studentList.map((student, index2) => ({
      sNo: index2 + 1,
      batch: batchYear,
      // Use batchYear from args
      sem: semester,
      // Use semester from args
      studentName: student.name,
      universityRollNo: student.rollNo
    }));
    const attendanceData = {
      universityName: "Chitkara University, Punjab",
      // Placeholder
      examTitle: `Attendance (${arg.examType == "regular" ? "Regular" : "Reappear"}) for End Term Examinations, December 2024`,
      // Placeholder
      noteLines: [
        "1. Centre Superintendents are requested to send this slip to the Assistant Registrar (Examinations) securely put inside the packet along with the answer-books\n2. Please ensure that the memo is not sent separately in any case."
      ],
      dateAndSession: `${arg.date} (Session-${arg.session})`,
      // Placeholder
      subject: `${subjectCode} - ${branchCode}`,
      // Use provided codes
      modeOfExamination: arg.mode,
      // Assuming offline, maybe make configurable?
      branchSemBatch: `${branchCode}/${semester}/${batchYear}`,
      subjectCode,
      session: "1",
      // Placeholder
      students: attendanceStudents,
      logoPath: path$d.join(process.env.VITE_PUBLIC || "public", "image.png")
      // Example logo path
    };
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[T:.-]/g, "").slice(0, 14);
    const defaultDownloadsPath = app.getPath("downloads");
    const safeBranchCode = branchCode.replace(/[^a-z0-9]/gi, "_");
    const safeSubjectCode = subjectCode.replace(/[^a-z0-9]/gi, "_");
    const outputFile = path$d.join(defaultDownloadsPath, `Attendance_${safeBranchCode}_${safeSubjectCode}_${timestamp}.pdf`);
    console.log(`[IPC] Generating attendance sheet at: ${outputFile}`);
    const resultPath = await generateAttendanceSheet({
      outputFile,
      data: attendanceData
    });
    console.log(`[IPC] Attendance sheet generated successfully: ${resultPath}`);
    return { success: true, path: resultPath };
  } catch (error2) {
    console.error("[IPC] Error handling generate-attendance-sheet:", error2);
    return { success: false, error: error2.message || "Unknown error generating attendance sheet." };
  }
});
ipcMain.handle("count-students", async (_2, arg) => {
  const { csvFilePath } = arg;
  try {
    if (!csvFilePath || typeof csvFilePath !== "string") {
      throw new Error("CSV file path is missing or invalid.");
    }
    const fileContent = await fs$i.readFile(csvFilePath, "utf8");
    const parseResult = Papa.parse(fileContent.trim(), {
      header: false,
      skipEmptyLines: true
    });
    if (parseResult.errors.length > 0) {
      console.error(`Error parsing CSV ${csvFilePath}:`, parseResult.errors);
      throw new Error(`Failed to parse CSV: ${parseResult.errors[0].message}`);
    }
    const validRowCount = parseResult.data.filter((row2) => row2.length > 0 && row2[0].trim()).length;
    return { success: true, count: validRowCount };
  } catch (error2) {
    console.error("[IPC] Error counting students:", error2);
    return { success: false, error: error2.message || "Unknown error counting students." };
  }
});
generateExampleSeatingPlanExcel().catch(console.error);
app.whenReady().then(createWindow);
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
};
